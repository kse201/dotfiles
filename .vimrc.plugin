"============================================================
"                  *** .vimrc.plugin ***                    |
"                 Last Change: 09-Aug-2013.                 |
"============================================================

augroup MyAutoCmd
    autocmd!
augroup END

" vimproc.vim{{{
if has('win64')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/autoload/vimproc_win64.dll'
elseif has('win32')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/autoload/vimproc_win32.dll'
elseif has('win32unix')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/autoload/vimproc_cygwin.dll'
elseif has('mac')
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/autoload/vimproc_mac.so'
else
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/autoload/vimproc_unix.so'
endif
" }}}

" neobundle.vim{{{
set nocompatible
filetype plugin indent off
let g:bundle_dir = $VIMFILE_DIR."/bundle/"
if has('vim_starting')
    exe "set rtp+=".g:bundle_dir."neobundle.vim"
endif
call neobundle#rc(expand(g:bundle_dir))
let g:neobundle#types#git#default_protocol = 'https'
unlet g:bundle_dir

" 必須ライブラリ {{{
NeoBundle 'Shougo/vimproc', {'build' : {
            \ 'windows' : 'echo "Sorry, cannot update vimproc binary file in Windows."',
            \ 'cygwin' : 'make -f make_cygwin.mak',
            \ 'mac'    : 'make -f make_mac.mak',
            \ 'unix'   : 'make -f make_unix.mak',
            \ },
            \}
NeoBundleLazy 'mattn/webapi-vim'
NeoBundleLazy 'basyura/twibill.vim'
NeoBundleLazy 'basyura/bitly.vim'
" }}}
" Plugin管理 {{{
NeoBundle 'Shougo/neobundle.vim'
" }}}
" ドキュメント管理 {{{
" NeoBundleLazy 'thinca/vim-ref'
NeoBundleLazy 'thinca/vim-ref',
            \{'autoload' : { 'mappings' : ['<Plug>(ref-keyword)']}}
NeoBundleLazy 'vim-jp/vimdoc-ja.git'
" }}}
" 補完 neocom{{{
NeoBundleLazy 'Shougo/neocomplcache'
NeoBundleLazy 'Shougo/neosnippet'
NeoBundleLazy 'Shougo/neocomplcache-clang'
NeoBundleLazy 'Shougo/neocomplcache-clang_complete'
NeoBundleLazy 'clang-complete'
NeoBundleLazy 'neco-look'
NeoBundleLazy 'yomi322/neco-tweetvim'
NeoBundleLazy 'Shougo/neocomplcache-rsense', {
            \ 'depends': 'Shougo/neocomplcache',
            \ 'autoload': { 'filetypes': 'ruby' }}
NeoBundleLazy 'taichouchou2/rsense-0.3', {
            \ 'build' : {
            \    'mac': 'ruby etc/config.rb > ~/.rsense',
            \    'unix': 'ruby etc/config.rb > ~/.rsense',
            \ },
            \ 'autoload' : {'filetypes' : 'ruby'}}
NeoBundleLazy 'davidhalter/jedi',
            \ { 'autoload' :{ 'filetypes' :['python',   'jedi' ]}}
" }}}
" ファイラ {{{
NeoBundleLazy 'scrooloose/nerdtree',
            \{ 'autoload' : {'commands' : ['NERDTreeToggle','NERDTree']}}
NeoBundleLazy 'Shougo/vimfiler',
            \ { 'depends' : 'Shougo/unite.vim' ,
            \ 'autoload' : {'commands' : ['VimFilerCurrentDir', 'VimFilerDouble']}}
NeoBundleLazy 'kien/ctrlp.vim'
" }}}
" 入力補助 {{{
NeoBundle 'kana/vim-smartchr'
NeoBundleLazy 'mattn/emmet-vim',
            \{ 'autoload' : { 'filetypes' : ['html','css','js','php']}}
NeoBundleLazy 'msanders/cocoa.vim' , 
            \ {'autoload' : {'filetypes' : 'objc'}}
NeoBundleLazy 'jelera/vim-javascript-syntax',
            \ { 'autoload' : { 'filetypes' : 'vim-javascript-syntax'}}
" }}}
" unite関連 {{{
NeoBundle 'Shougo/unite.vim'
NeoBundleLazy 'tsukkee/unite-tag'
NeoBundleLazy 'tsukkee/unite-help'
NeoBundleLazy 'h1mesuke/unite-outline'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundle 'thinca/vim-unite-history'
NeoBundleLazy 'unite-colorscheme'
" NeoBundle 'choplin/unite-vim_hacks'
NeoBundleLazy 'ujihisa/unite-font'
NeoBundleLazy 'Shougo/unite-build'
NeoBundleLazy 'sgur/unite-everything'
NeoBundleLazy 'zhaocai/unite-scriptnames'
NeoBundleLazy 'yomi322/unite-tweetvim'
NeoBundleLazy 'taka84u9/unite-git'
NeoBundleLazy 'kmnk/vim-unite-giti'
NeoBundleLazy 'Shougo/unite-ssh', {
            \ 'depends' : 'Shougo/unite.vim' }
NeoBundleLazy 'basyura/unite-rails', {
            \ 'depends' : 'Shougo/unite.vim' }
NeoBundleLazy 'taichouchou2/unite-rails_best_practices', {
            \ 'depends' : 'Shougo/unite.vim',
            \ 'build' : {
            \    'mac': 'gem install rails_best_practices',
            \    'unix': 'gem install rails_best_practices',
            \   }
            \ }
NeoBundleLazy 'taichouchou2/unite-reek', {
            \ 'build' : {
            \    'mac': 'gem install reek',
            \    'unix': 'gem install reek',
            \ },
            \ 'autoload': { 'filetypes': ['ruby', 'eruby', 'haml'] },
            \ 'depends' : 'Shougo/unite.vim' }
" NeoBundle 'Kocha/vim-unite-tig'
" }}}
" テキスト整形 {{{
NeoBundle 'h1mesuke/vim-alignta'
NeoBundle 'The-NERD-Commenter'
NeoBundleLazy 'vim-scripts/sequence'
NeoBundle "fuenor/JpFormat.vim"
" }}}
" 機能追加 {{{
NeoBundleLazy 'Shougo/vimshell'  , 
            \{"autoload" : {'commands' : ['VimShell', 'VimShellCurrentDir' ]} }
NeoBundle 'basyura/TweetVim' ,
            \{'depends' : 
            \ ['open-browser.vim',
            \ 'mattn/webapi-vim',
            \ 'basyura/twibill.vim',
            \ 'basyura/bitly.vim',
            \ 'Shougo/unite.vim',
            \ 'yomi322/unite-tweetvim',
            \ 'h1mesuke/unite-outline',
            \ 'TweetVim-powerline-theme'
            \ ],
            \ 'autoload' : 
            \{ 'commands' : ['TweetVim', 'TweetVimSay'],
            \ 'mappings' : ['<Plug>(tweetvim_action_enter)' , '<Plug>(tweetvim_action_retweet)','<Plug>(tweetvim_action_page_next)','<Plug>(tweetvim_action_page_previous)']
            \}}
NeoBundle 'delphinus35/TweetVim-powerline-theme'
NeoBundleLazy 'mattn/calendar-vim' ,
            \{'autoload' : 
            \{'commands' : ['Calendar']}}
NeoBundleLazy 'thinca/vim-quickrun',
            \{ 'autoload' : {
            \'mappings' : ['<Plug>(quickrun)'],
            \ 'commands' : ['QuickRun']}}
" NeoBundle 'surround.vim' " moved .vim/
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'gregsexton/gitv'
NeoBundleLazy 'open-browser.vim',
            \{'autoload' : {'mappings' :['<Plug>(open-browser-wwwsearch)','<Plug>(openbrowser-smart-search)']}}
" NeoBundle 'YankRing.vim'
NeoBundleLazy 'SingleCompile' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'taglist.vim',
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java'],
            \ 'commands' : ['TList']}}
NeoBundleLazy 'TagHighlight',
            \{'autoload' : { 'filetypes' : ['c', 'cpp','cs','java']}}
NeoBundleLazy 'thinca/vim-showtime',
            \ {'autoload' : {'commands' : ['ShowtimeStart']}}
NeoBundle 'thinca/vim-fontzoom'
NeoBundle 'MultipleSearch'
NeoBundleLazy 'csv.vim' ,
            \{ 'autoload' : {'filetypes' : 'csv'}}
NeoBundleLazy 'yuratomo/w3m.vim'  ,
            \{ 'autoload' : {'commands' : ['W3m']}}
NeoBundleLazy 'sjl/gundo.vim' ,
            \{'autoload' : {'commands' : ['GundoToggle']}}
NeoBundleLazy 'vim-scripts/RltvNmbr.vim' , 
            \ {'autoload' : { 'commands' : 'RN'}}
NeoBundleLazy 'scrooloose/syntastic',  
            \ {'autoload' : { 'filetypes' : ['c', 'cpp', 'cs', 'java' , 'ruby']}}
NeoBundle 'yuratomo/gmail.vim'
NeoBundle 'kana/vim-operator-replace.git'
NeoBundle 'kana/vim-operator-user'
NeoBundle 'vim-scripts/ViewOutput'
NeoBundle 'rhysd/clever-f.vim'
NeoBundle 'thinca/vim-submode'
NeoBundle 'thinca/vim-painter'
" }}}
" C / C++ {{{
NeoBundleLazy 'vim-scripts/SrcExpl' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'vim-scripts/Trinity' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'vim-scripts/a.vim' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'vim-scripts/c.vim.git' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'vim-scripts/CCTree' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
NeoBundleLazy 'vim-scripts/cscope-menu' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','cs','java']}}
NeoBundleLazy 'vim-scripts/gtags.vim' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','cs','java']}}
NeoBundleLazy 'vim-scripts/csharp.vim' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','cs','java']}}
NeoBundleLazy 'vim-scripts/teol.vim.git' ,
            \{'autoload' : { 'filetypes' : ['c', 'cpp','java']}}
" }}}
" Java {{{
NeoBundle 'yuratomo/java-api-complete' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
NeoBundle 'yuratomo/java-api-javax.git' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
NeoBundle 'yuratomo/java-api-org.git' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
NeoBundle 'yuratomo/java-api-sun.git' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
NeoBundle 'yuratomo/java-api-servlet2.3.git' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
NeoBundle 'yuratomo/java-api-android.git' , 
            \ { 'autoload' :  { 'filetypes' : ['java'] }}
" }}}
" Ruby {{{
NeoBundleLazy 'tpope/vim-rails' , {
            \'autoload' : {'filetypes' : ['ruby']} }
NeoBundleLazy 'alpaca-tc/alpaca_complete', {
            \ 'depends' : 'tpope/vim-rails',
            \ 'build' : {
            \    'mac':  'gem install alpaca_complete',
            \    'unix': 'gem install alpaca_complete',
            \   }
            \ }

" reference環境
NeoBundleLazy 'vim-ruby/vim-ruby', {
            \ 'autoload' : { 'filetypes': ['ruby', 'eruby', 'haml'] } }
NeoBundleLazy 'taka84u9/vim-ref-ri', {
            \ 'depends': ['Shougo/unite.vim', 'thinca/vim-ref'],
            \ 'autoload': { 'filetypes': ['ruby', 'eruby', 'haml'] } }
NeoBundleLazy 'skwp/vim-rspec', {
            \ 'autoload': { 'filetypes': ['ruby', 'eruby', 'haml'] } }
NeoBundleLazy 'ruby-matchit', {
            \ 'autoload' : { 'filetypes': ['ruby', 'eruby', 'haml'] } }
" }}}
" tex {{{
NeoBundleLazy 'jcf/vim-latex'
" }}}
" 見た目 {{{
NeoBundle 'wombat256.vim'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'Lokaltog/vim-powerline'
NeoBundle 'HybridText'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'kien/rainbow_parentheses.vim'
NeoBundle 'w0ng/vim-hybrid'
" }}}
" その他  {{{
NeoBundle 'dannyob/quickfixstatus'
NeoBundleLazy 'Takazudo/outline.vim.git'
NeoBundleLazy 'jceb/vim-hier' ,   
            \{ "autoload" : {"filetypes" : ["cpp" , "c","cs"]}}
" NeoBundle 'mattn/mkdpreview-vim'
NeoBundleLazy 'L9'
NeoBundle 'daisuzu/rainbowcyclone.vim'

"NeoBundleLazy 'git://git.wincent.com/command-t.git'

" Game {{{
NeoBundleLazy 'mattn/invader-vim'
NeoBundleLazy 'mattn/mahjong-vim'
NeoBundleLazy 'sudoku_game'
NeoBundleLazy 'mfumi/viminesweeper'
NeoBundleLazy 'mfumi/snake.vim'
NeoBundleLazy 'TeTrIs.vim'
NeoBundleLazy 'mfumi/lightsout.vim' "http://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%A4%E3%83%84%E3%82%A2%E3%82%A6%E3%83%88
" NeoBundleLazy 'vim game of life'
" NeoBundleLazy 'mastermind.vim'
" }}}
NeoBundle 'kana/vim-smartinput'
NeoBundle 'taichouchou2/vim-endwise'
NeoBundle 'tsaleh/vim-matchit'
" }}}
" Game{{{
NeoBundleLazy 'mattn/habatobi-vim'
" }}}
NeoBundleLazy "osyo-manga/vim-sugarpot", {
            \   'autoload' : {
            \       'commands' : [
            \           {
            \               "name" : "SugarpotPreview",
            \               "complete" : "file",
            \           }
            \       ]
            \   }
            \}
NeoBundle 'rhysd/tmpwin.vim'
NeoBundleLazy 'terryma/vim-multiple-cursors'
NeoBundle 'tyru/foldballoon.vim'
NeoBundle 'kannokanno/previm'

filetype plugin indent on
syntax on

" 導入されていないpluginがあったら表示
if neobundle#exists_not_installed_bundles()
    echomsg 'Not installed bundles :' .
                \ string(neobundle#get_not_installed_bundle_names())
    echomsg 'Please execute ":NeoBundleInstall" command.' 
endif

command! Nbi :NeoBundleInstall
command! Nbu :NeoBundleUpdate
command! Nbl :NeoBundleLog


" plugin導入確認
let s:plugin_name =  map(neobundle#config#get_neobundles(),'(v:val).name')
let s:plugin_orig_name =  map(neobundle#config#get_neobundles(),'(v:val).orig_name')
function! s:checkplugin(name)
    for l:ele in s:plugin_name
        if l:ele ==# a:name
            return 1
        endif
    endfor
    for l:ele in s:plugin_orig_name
        if l:ele ==# a:name
            return 1
        endif
    endfor
    return 0
endfunction
" }}}

" neocomplcache & neosnippet {{{

if has('vim_starting') 
    augroup MyInitNeocomplcache
        autocmd!
        autocmd InsertEnter * call s:LazyLoadingForNeocom() | call Init_neocomplcache() | autocmd! MyInitNeocomplcache
    augroup END
    function! s:LazyLoadingForNeocom()
        NeoBundleSource neocomplcache
        NeoBundleSource neosnippet
        NeoBundleSource neocomplcache-clang
        NeoBundleSource neocomplcache-clang_complete
        NeoBundleSource clang-complete
        NeoBundleSource neco-look
        NeoBundleSource neco-tweetvim
        NeoBundleSource jedi
    endfunction
endif

call neobundle#config('neocomplcache',{
            \'lazy' : 1,
            \ 'autoload' : {
            \ 'insert' : 1,
            \}})

" Use neocomplcache.
let g:neocomplcache_enable_at_startup             = 0 " 起動時に有効化
" Use smartcase.
let g:NeoComplCache_SmartCase                     = 1
let g:neocomplcache_enable_auto_select            = 1
" Use camel case completion.
let g:NeoComplCache_enable_camel_case_completion  = 0
" Use underbar completion.
let g:NeoComplCache_EnableUnderbarCompletion      = 1
" Set minimum syntax keyword length.
let g:NeoComplCache_MinSyntaxLength               = 3
" Set manual completion length.
" let g:NeoComplCache_ManualCompletionStartLength = 2
" Print caching percent in statusline.
" let g:NeoComplCache_CachingPercentInStatusline  = 1
let g:neocomplcache_lock_buffer_name_pattern      = '\*ku\*'

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
            \ 'default'  : '',
            \ 'vimshell' : $HOME.'/.vimshell_hist',
            \ 'scheme'   : $HOME.'/.gosh_completions',
            \ 'ruby'     : $VIMFILE_DIR.'/dict/ruby.dict',
            \ 'objc'     : $VIMFILE_DIR.'/dict/cocoa.dict',
            \ 'tex'      : $VIMFILE_DIR.'/dict/tex.dict',
            \ 'java'     : $VIMFILE_DIR.'/dict/java.dict'
            \ }

" Define keyword.
if !exists('g:neoComplCache_keyword_patterns')
    let g:neoComplCache_keyword_patterns = {}
endif
let g:neoComplCache_keyword_patterns['default'] = '\h\w*'
" ファイル名補間、オムニ補間をneocom組み込みのものに置き換え
" inoremap <expr><C-x><C-f>  neocomplcache#manual_filename_complete()
" inoremap <expr> <C-j>  &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : neocomplcache#manual_omni_complete()
"
" http://d.hatena.ne.jp/osyo-manga/20121021/1350749023
if !exists("g:neosnippet#snippets_directory")
    let g:neosnippet#snippets_directory=""
endif
" let g:NeoComplCache_SnippetsDir = $VIMFILE_DIR.'/snippets'
let g:neosnippet#snippets_directory= $VIMFILE_DIR . '/snippets'


" init neocomplcache {{{
function! Init_neocomplcache()
    NeoComplCacheEnable
    " 候補の共通箇所まで補完する
    inoremap <expr><C-l> neocomplcache#complete_common_string()
    " 決定
    inoremap <expr><C-y> neocomplcache#close_popup()
    " inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>" 

    "snippet
    imap <expr><CR> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<CR>" 
    imap <expr><C-y> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<C-y>" 
    imap <expr><C-j> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<C-j>" pneobu
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?  "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

    imap <C-q>  <Plug>(neocomplcache_start_unite_complete)

    " キャンセルしてポップアップを閉じる
    inoremap <expr><C-e>  neocomplcache#cancel_popup()
    " ネオコンによって挿入した補完を元に戻す
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    " ポップアップが出ているときの挙動を快適にする
    " バックスペースしたときポップアップを閉じる
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"

    " ネオコン設定変更操作
    " スニペットを編集する
    noremap <Leader>es :<C-u>vertical belowright NeoComplCacheEditSnippets<CR>
endfunction
" }}}
" Term neocomplcache{{{
function! Term_neocomplcache()
    NeoComplCacheDisable
    iunmap <C-g>
    iunmap <C-l>
    iunmap <C-q>
    iunmap <CR>
    iunmap <C-h>
    iunmap <BS>
    iunmap <C-y>
    iunmap <C-e>
    iunmap <TAB>
endfunction
" }}}
command! InitNeoComplCache call Init_neocomplcache()
command! TermNeoComplCache call Term_neocomplcache()

" Enable omni completion. {{{
augroup EnableOmniCompleteion
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup END
" }}}
" Enable heavy omni completion.{{{ 
if !exists('g:neocomplcache_omni_patterns')
    let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
" }}}
" autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete{{{
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'
" }}}
" }}}

" yankring{{{
if has('gui_running')
    set viminfo+=!
    let g:yankring_max_history = 50
    if has('win32') || has('win64') || has('win32unix')
        let g:yankring_history_dir = '$HOME\_vimbackup'
    else
        let g:yankring_history_dir = '$HOME/.vimbackup'
    endif
    let g:yankring_clipboard_monitor = 1
    let g:yankring_max_history=10
    let g:yankring_window_height=13
    "マッピング
    noremap <Leader>yr :<C-u>YRShow<CR>
endif
" }}}

" unite.vim{{{
" 参考:
" http://d.hatena.ne.jp/ruedap/20110110/vim_unite_plugin
" http://blog.remora.cx/2010/12/vim-ref-with-unite.html
let g:unite_split_rule="botright"
let g:unite_source_file_mru_filename_format = ''
" 入力モードで開始する
let g:unite_enable_start_insert=1
" file_mruの最大保存数
let g:unite_source_file_mru_limit=1000

" Prefix-Key
nmap <Leader>a <SID>[unite]
nnoremap <SID>[unite] <Nop>

" ESCキーを2回押すと終了する
augroup uniteKeymap
    autocmd!
    au FileType unite nmap <silent><buffer> <ESC><ESC> <Plug>(unite_exit)
    au FileType unite nmap <silent><buffer> <C-c><C-c> <Plug>(unite_exit)
    au FileType unite imap <silent><buffer> <ESC><ESC> <Plug>(unite_exit)
    au FileType unite imap <silent><buffer> <C-c><C-c> <Plug>(unite_exit)
    au FileType unite nmap <silent><buffer> a <Plug>(unite_append_end)
    au FileType unite nmap <silent><buffer> f <Plug>(unite_quick_match_default_action)
    au FileType unite nmap <silent><buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    au FileType unite imap <silent><buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    au FileType unite imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
    au FileType unite nmap <buffer> -     <Plug>(unite_delete_backward_path)

    " ウィンドウを縦に分割して開く
    au FileType unite nnoremap <silent> <buffer> <expr> <C-Enter> unite#do_action('vsplit')
    au FileType unite inoremap <silent> <buffer> <expr> <C-Enter> unite#do_action('vsplit')

    au FileType unite nnoremap <silent> <buffer>  <C-k> :<C-u>call unite#mappings#do_action('right')<CR>
    au FileType unite setlocal tw=0
augroup END

nnoremap <silent> <SID>[unite]b :<C-u>Unite -buffer-name=buffer buffer<CR>
" ファイル 最近使用したファイル一覧
nnoremap <silent> <SID>[unite]f :<C-u>Unite  -buffer-name=files file file/new<CR>
nnoremap <silent> <SID>[unite]m :<C-u>Unite -buffer-name=file_mru file_mru<CR>
" 全部乗せ
nnoremap <silent> <SID>[unite]a :<C-u>UniteWithBufferDir -winheight=100 -input= -buffer-name=files buffer file_mru bookmark file tab history/command directory directory_mru register variable window<CR>
" command
nnoremap <silent> <SID>[unite]h :<C-u>Unite -default-action=edit history/command command<CR>
" command
nnoremap <silent> <SID>[unite]t :<C-u>Unite tab<CR>
" jump
nnoremap <silent> <SID>[unite]j :<C-u>Unite jump<CR>
" 検索
nnoremap <silent> <SID>[unite]/ :<C-u>Unite line<CR>
nnoremap <silent> <SID>[unite]l :<C-u>Unite line<CR>
nnoremap <silent> <SID>[unite]; :<C-u>Unite command<CR>

" 曖昧検索
call unite#custom#substitute('file,file_mru,history/command,directory_mru', '[[:alnum:]]', '*\0', 100)

" 様々なショートカット
" http://d.hatena.ne.jp/thinca/20101027/1288190498
call unite#custom#substitute('file,file_mru', '\$\w\+', '\=eval(submatch(0))', 200)
call unite#custom#substitute('file,file_mru', '[^~.]\zs/', '*/*', 20)
call unite#custom#substitute('file,file_mru', '/\ze[^*]', '/*', 10)
call unite#custom#substitute('file,file_mru', '^@@', '\=fnamemodify(expand("#"), ":p:h")."/*"', 2)
call unite#custom#substitute('file,file_mru', '^@', '\=getcwd()."/*"', 1)
call unite#custom#substitute('file,file_mru', '^;r', '\=$VIMRUNTIME."/"')
call unite#custom#substitute('file,file_mru', '^\~', escape($HOME, '\'), -2)
call unite#custom#substitute('file,file_mru', '^\\', escape($HOME, '\'), -2)
call unite#custom#substitute('file,file_mru', '\\\@<! ', '\\ ', -20)
call unite#custom#substitute('file,file_mru', '\\ \@!', '/', -30)
if has('win32') || has('win64') || has('win32unix')
    call unite#custom#substitute('file,file_mru', '^;p', 'C:\Program File,file_mrus\')
    call unite#custom#substitute('file,file_mru', '^;v', '~/vimfile,file_mru/')
else
    call unite#custom#substitute('file,file_mru', '^;v', '~/.vim/')
endif

" よくコマンドを登録してuniteで選択して起動 {{{ 
let s:unite_source_myCommand ={
            \ "name" : "myCommand"
            \}

function! s:unite_source_myCommand.gather_candidates(args,conext)
    let cmds = {
                \"Unite Beatiful Attack" : "Unite -auto-preview colorscheme",
                \"Search vim tweet in Japanese" : "TweetVimSearch vim lang:ja",
                \"Search vim tweet" : "TweetVimSearch vim",
                \"Open tweetvim" : "TweetVimHomeTimeline",
                \"Search emacs tweet in Japanese" : "TweetVimSearch emacs lang:ja",
                \"Neobundle  Update" : "Unite neobundle/update",
                \ "NeoBundleSource"  : "Unite neobundle/lazy",
                \ "Display relative line numbers " : "RN",
                \"Neobundle Log" : "NeoBundleLog",
                \"Undo Tree " : "GundoToggle",
                \"Show relative number" : "RN",
                \ "TODO list" : "Unite line -input=TODO", 
                \ 'MultipleSearch' : "Search <C-r><C-w>",
                \}
    return values(map(cmds,"{
                \ 'word' : v:key,
                \ 'source' : 'myCommand',
                \ 'kind' : 'command',
                \ 'action__command' : v:val
                \}"))
endfunction
call unite#define_source(s:unite_source_myCommand)
nnoremap <SID>[unite]c :Unite myCommand<CR>
" }}}
" help イースターエッグ{{{
let s:unite_source_myCommand ={
            \ "name" : "easter_egg"
            \}

function! s:unite_source_myCommand.gather_candidates(args,conext)
    let cmds = {
                \ "help 42" : "help 42",
                \ "help holy-grail" : "help holy-grail",
                \ "help map-modes" : "help map-modes" ,
                \ "help UserGettingBored" : "help UserGettingBored" ,
                \ "help spoon" : "help spoon" ,
                \ "help showmatch" : "help showmatch" ,
                \ "help bar" : "help bar" ,
                \ "Ni!" : "Ni!" ,
                \}
    return values(map(cmds,"{
                \ 'word' : v:key,
                \ 'source' : 'myCommand',
                \ 'kind' : 'command',
                \ 'action__command' : v:val
                \}"))
endfunction
call unite#define_source(s:unite_source_myCommand)
nnoremap <SID>[unite]c :Unite myCommand<CR>
" }}}
" unite-neco {{{
" https://github.com/ujihisaより
let s:unite_source = {'name': 'neco'}

function! s:unite_source.gather_candidates(args, context)
    let necos = [
                \ "~(-'_'-) goes right",
                \ "~(-'_'-) goes right and left",
                \ "~(-'_'-) goes right quickly",
                \ "~(-'_'-) goes right then smile",
                \ "~(-'_'-)  -8(*'_'*) go right and left",
                \ "(=' .' ) ~w",
                \ ]
    return map(necos, '{
                \ "word": v:val,
                \ "source": "neco",
                \ "kind": "command",
                \ "action__command": "Neco " . v:key,
                \ }')
endfunction

"function! unite#sources#locate#define()
"  return executable('locate') ? s:unite_source : []
"endfunction
call unite#define_source(s:unite_source)
unlet s:unite_source

if has('win32') || has('win64')
    NeoBundleSource 'unite-everything'
endif
" }}}

" }}}

" smartchr.vim{{{
" コマンドモード時のエスケープ入力補助

if s:checkplugin("vim-smartchr" )
    cnoremap <expr> /
                \ getcmdtype()=='/' ? '\/' : '/'
    cnoremap <Leader>/ /
    " cnoremap <expr> / search('.*/\%#', 'bcn')? '/' : smartchr#one_of('/', '\/')
    " if filereadable(expand($VIMFILES_DIR . '/bundle/vim-smartchr/autoload/smartchr.vim'))
    cnoremap <expr> <  smartchr#one_of('<', '\<', '<<')
    cnoremap <expr> >  smartchr#one_of('>', '\>', '>>')
    cnoremap <expr> \  smartchr#one_of('\', '\' , '\\')
    cnoremap <expr> (  smartchr#one_of('(' , '\(', '((')
    cnoremap <expr> )  smartchr#one_of(')' , '\)', '))')
    cnoremap <expr> %  smartchr#one_of('%' , '\%', '%%')
    " cnoremap <expr> |  smartchr#one_of('|', '\|', '||')

    " 参考:http://d.hatena.ne.jp/ampmmn/20080925/1222338972
    " 演算子記号の前後に空白を入れるなど
    " (多分)C/C++コーディング用
    function! SmartCharForC()
        "四則演算
        inoremap <buffer><expr> + smartchr#loop(' + ', '++')
        inoremap <buffer><expr> - smartchr#loop(' - ', '--')
        " inoremap <buffer><expr> * smartchr#loop(' * ', '**')

        " =の場合、単純な代入や比較演算子として入力する場合は前後にスペースをいれる。
        " 複合演算代入としての入力の場合は、直前のスペースを削除して=を入力
        inoremap <buffer><expr> = search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\<bar>*\<bar>\) \%#', 'bcn')? '<bs>= '
                    \ : smartchr#loop(' = ', ' == ', '=')
        inoremap <buffer><expr> < search('^#include\%#', 'bcn')? ' <><Left>': smartchr#loop('<', ' < ', ' << ' , '')
        inoremap <buffer><expr> > search('^#include <.*\%#', 'bcn')? '>': smartchr#loop('>', ' > ', ' >> ')

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>': smartchr#loop('"', ' " ')
        inoremap <buffer><expr> " search('^#include ".*\%#', 'bcn')? '"': smartchr#loop('"', ' " ',)

        inoremap <buffer><expr> , smartchr#loop(', ', ',')
        "inoremap <buffer><expr> / smartchr#loop('/', ' / ', '//')
        inoremap <buffer><expr> & smartchr#loop('&', ' & ', ' && ')
        inoremap <buffer><expr> % smartchr#loop('%', ' % ')
        inoremap <buffer><expr> <Bar> smartchr#loop(' <Bar> ', ' <Bar><Bar> ', '<Bar>')
        " 3項演算子の場合は、後ろのみ空白を入れる
        inoremap <buffer><expr> ? smartchr#loop('?', '? ')
        inoremap <buffer><expr> : smartchr#loop(':', '::', ': ')

        " 下記の文字は連続して現れることがまれなので、二回続けて入力したら改行する
        "inoremap <buffer><expr> } smartchr#one_of('}', '}<CR>')
        "inoremap <buffer><expr> ; smartchr#one_of(';', ';<CR>')
        " 「->」は入力しづらいので、..で置換え
        inoremap <buffer><expr> . smartchr#loop('.', '->', '...')
        " 行先頭での@入力で、プリプロセス命令文を入力
        inoremap <buffer><expr> @ search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '@'): '@'
        inoremap <buffer><expr> # search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '#'): '#'

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>"': '""<Left>'
        " 制御構文直後の(は自動で間に空白を入れる
        inoremap <buffer><expr> ( search('\<\if\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\for\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\while\%#', 'bcn')? ' ()<Left>': '()<Left>'
    endfunction

    " Objective-C用(未完)
    function! SmartCharForObjc()
        inoremap <buffer><expr> @ search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of( '@interface','@implementation', '@synthesize', '@property', '@class' , '@'): '@'
        inoremap <buffer><expr> # search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '#import' , '#'): '#'
        inoremap <buffer><expr> - search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('- ()<Left>' ,  '-') :smartchr#loop(' - ', '--')
        inoremap <buffer><expr> + search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('+ ()<Left>' ,  '+') :smartchr#loop(' + ', '++')
    endfunction

    " 記号入力メンドクセ イマイチ{{{
    function! MySmarcchr()
        inoremap <buffer><expr> 1 smartchr#one_of('1', '!' ,'11')
        inoremap <buffer><expr> 2 smartchr#one_of('2', '"','22')
        inoremap <buffer><expr> 3 smartchr#one_of('3', '#','33')
        inoremap <buffer><expr> 4 smartchr#one_of('4', '$','44')
        inoremap <buffer><expr> 5 smartchr#one_of('5', '%','55')
        inoremap <buffer><expr> 6 smartchr#one_of('6', '&','66')
        inoremap <buffer><expr> 7 smartchr#one_of('7', '\'','77')
        inoremap <buffer><expr> 8 smartchr#one_of('8', '(','88')
        inoremap <buffer><expr> 9 smartchr#one_of('9', ')','99')
    endfunction

    autocmd MyAutoCmd FileType c,cpp call SmartCharForC()
    " endif
    " }}}
endif
" }}}

" NERD Commenter{{{
" http://d.hatena.ne.jp/nishikawasasaki/20101226/1293374432
let g:NERDCreateDefaultMappings = 0
let NERDSpaceDelims = 1
nmap <Leader><Leader> <Plug>NERDCommenterToggle
vmap <Leader><Leader> <Plug>NERDCommenterToggle
" }}}

" nerdtree{{{
nnoremap <F11> :NERDTreeToggle<CR>
" }}}

" QuickRun.vim{{{
try 
    if !exists("g:quickrun_config")
        let g:quickrun_config={}
        let g:quickrun_config = {
                    \   '*': {'runmode': 'async:remote:vimproc'},
                    \ }
    endif
    " nnoremap <silent><unique> <F5> <Plug>(quickrun)
    nnoremap <silent> <F5> :QuickRun<CR>
    nnoremap          <F6> :QuickRun -outputter error:buffer:quickfix -args ''<Left>
    nnoremap <silent> <F7> :QuickRun -outputter quickfix<CR>
    " 静的C++のシンタックスチェック {{{
    " 参考:http://d.hatena.ne.jp/osyo-manga/20110921/1316605254
    " quickfixのエラー箇所を破線でハイライト
    execute "highlight qf_error_ucurl gui=undercurl guisp=Red"
    let g:hier_highlight_group_qf = "qf_error_ucurl"
    " quickfixに出力して、ポップアップはしない outputter/quickfix
    " すでにquickfixウィンドウが開いている場合は閉じるので注意
    let s:silent_quickfix = quickrun#outputter#quickfix#new()

    function! s:silent_quickfix.finish(session)
        call call(quickrun#outputter#quickfix#new().finish, [a:session], self)
        :cclose
        " vim-hierの更新
        :HierUpdate
        " quickfixへの出力後にquickfixsatusを有効に
        :QuickfixStatusEnable
    endfunction
    " quickrunに登録
    call quickrun#register_outputter("silent_quickfix", s:silent_quickfix)
    " シンタックスチェック用のquickrun.vimのコンフィグ
    " ファイルの保存後に Quickrun.vimが実行するように設定する
    autocmd MyAutoCmd BufWritePost *.cpp,*.h,*.hpp :QuickRun CppSyntaxCheck_gcc
    " }}}
    " Programごとの設定{{{
    " Markdown{{{
    let g:quickrun_config['markdown']={
                \ 'outputter' : 'null',
                \ 'command'   : 'open',
                \ 'cmdopt'    : '-a',
                \ 'args'      : 'Marked',
                \ 'exec'      : '%c %o %a %s',
                \}
    " \'type': 'markdown/pandoc',
    " \'cmdopt' : '-s',
    " " \'command': 'bluecloth',
    " " \'exec': '%c -f %s', 
    "}}}
    " gcc版{{{
    let g:quickrun_config['CppSyntaxCheck_gcc'] = {
                \ "type" : "cpp",
                \ "exec" : "%c %o $s:p",
                \ "command" : "g++",
                \ "cmdopt" : "-fsytax-only -std=gnu++0x",
                \ "outputter" : "silent_quickfix",
                \ "hook/output_encode/enable" : 1,
                \ "hook/output_encode/encoding" : "utf-8",
                \ "runner" : "vimproc"
                \}
    " }}}
    " msvc版{{{
    " .h ファイルの場合はうまく動かない
    let g:quickrun_config["Cppsyntaxcheck_msvc"] = {
                \ "type" : "cpp",
                \ "exec" : "%c %o $s:p",
                \ "command" : "cl.exe",
                \ "cmdopt" : "/Zs",
                \ "outputter" : "silent_quickfix",
                \ "runner" : "vimproc",
                \ "output_encode" : "sjis"
                \ }
    " }}}
    " TeX{{{
    let g:quickrun_config['tex']={
                \ 'type' : 'tex',
                \ 'command' : '/usr/bin/platex2pdf-euc',
                \ "outputter" : "error:buffer:quickfix",
                \ 'runmode': 'async:remote:vimproc',
                \ 'exec' : ['%c %s' , 'open %s:r.pdf']
                \}
    " \ 'outputer' : '',
    " \ 'exec' : ['%c -output-directory %s:h %s' , 'open %s:r.pdf']
    " }}}
    " bib{{{
    let g:quickrun_config['bib']={
                \ 'type' : 'tex',
                \ 'command' : 'jbibtex',
                \ 'runmode': 'async:remote:vimproc',
                \ 'exec' : ['%c -kanji=euc %s:t:r']
                \}
    " }}}
    " HTML{{{
    let g:quickrun_config['html'] = {
                \ "type" : "html",
                \ "exec" : "open %s",
                \ "outputter" : "browser",
                \}

    " }}}
    " Ruby
    let g:quickrun_config['Ruby'] = {
                \ "type" : "ruby",
                \ "outputter" : "error:buffer:quickfix",
                \}


catch /E117/
endtry
" }}}
" unite.vimでquickrun_configの列挙 {{{
" http://d.hatena.ne.jp/osyo-manga/20111012/1318377040 
" filetypeごとにquickrunのconfig名を設定する
let g:quickrun_compile_command={}
" unite.vimの設定
let s:action={
            \ 'description' : 'quickrun compile command', 
            \ 'is_selectable' : 1 , 
            \}

function! s:action.func(candidates)
    for val in a:candidates
        let g:quickrun_compile_command[&filetype] = val.word
    endfor
endfunction
call unite#custom_action('common',  'quickrun_compile_command',  s:action)
unlet s:action
let s:unite_source_quickrun = {
            \ "name" : "quickrun-select", 
            \ "default_action" : "quickrun_compile_command"
            \}

function! s:unite_source_quickrun.gather_candidates(args, context)
    let cmds = filter(deepcopy(g:quickrun_config), "exists('v:val.type') ? v:val.type == &filetype : 0")
    return sort(values(map(cmds,"{
                \ 'word' : v:key, 
                \ 'source' : 'quickrun-select', 
                \ 'kind' : 'common' , 
                \ }")))
endfunction
call unite#define_source(s:unite_source_quickrun)
" unite.vimを呼び出すキーマップ
nno <silent> <Leader>qr :Unite quickrun-select<CR>

" 実行(コンパイル)を行うキーマップ
nno <silent> <C-F7> :execute "QuickRun ".g:quickrun_compile_command[&filetype"]<CR>
" }}}
" }}}

" vimshell.vim{{{
nmap <Leader>vs <SID>[vimshell]
nnoremap <SID>[vimshell] :<C-u>VimShell<CR>
let s:bundle = neobundle#get("vimshell")
" hooksの初期化
let s:bundle.hooks = get(s:bundle,"hooks", {})

function! s:bundle.hooks.on_source(bundle)
    " nnoremap <SID>[vimshell]c :VimShellCreate<CR>
    " let g:vimshell_prompt = 'vimshell#vcs#info("(%s)-[%b]", "(%s)-[%b|%a]")'
    let g:vimshell_split_height = 10
    let g:vimshell_disable_escape_highlight = 1
endfunction
unlet s:bundle
" }}}

" taglist.vim{{{
set tags=./tags
" set tags+=../../**/tags
augroup TList
    autocmd!
    au BufEnter * nnoremap <F12> :Tlist<CR>z<CR>
    autocmd  BufEnter *.memo nnoremap <buffer> <F12> :<C-u>ToC<CR>
augroup END
" }}}

" open-browser{{{
" disable netrw's gx mapping.
let g:netrw_nogx = 1
nmap go <Plug>(openbrowser-smart-search)
vmap go <Plug>(openbrowser-smart-search)
" }}}

" vimfiler{{{
nnoremap <leader>vf :<c-u>VimFilerCurrentDir -auto-cd -split  -winwidth=35 -no-quit<cr>
nnoremap <leader>vd :<c-u>VimFilerDouble -auto-cd -double -explorer -no-quit<cr>

let s:bundle = neobundle#get("vimfiler")
" hooksの初期化
let s:bundle.hooks = get(s:bundle,"hooks", {})

function! s:bundle.hooks.on_source(bundle)
    let g:vimfiler_as_default_explorer=1
    let g:vimfiler_safe_mode_by_default=0
    call vimfiler#set_execute_file('vim', 'vim')
    call vimfiler#set_execute_file('txt', 'notepad')
    call vimfiler#set_execute_file('c', ['vim', 'notepad'])

    " Edit file by tabedit.
    "let g:vimfiler_edit_action = 'tabopen'

    " Enable file operation commands.
    "let g:vimfiler_safe_mode_by_default = 0

    " Like Textmate icons.
    let g:vimfiler_tree_leaf_icon = ' '
    let g:vimfiler_tree_opened_icon = '▾'
    let g:vimfiler_tree_closed_icon = '▸'
    let g:vimfiler_file_icon = '-'
    let g:vimfiler_marked_file_icon = '*'

    " Use trashbox.
    " Windows only and require latest vimproc.
    "let g:unite_kind_file_use_trashbox = 1
    "デフォルトのキーマッピングを変更
    augroup VimFiler 
        autocmd!
        autocmd FileType vimfiler call s:vimfiler_my_settings()
    augroup END
    function! s:vimfiler_my_settings()
        nmap <buffer> q <Plug>(vimfiler_exit)
        nmap <buffer> Q <Plug>(vimfiler_hide)
        nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_another_vimfiler)
        nmap <buffer> <C-a> <Plug>(vimfiler_toggle_mark_all_lines)
        " nnoremap <buffer><silent> / :<C-u>UniteWithBufferDir file -default-action=vimfiler -buffer-name=files<CR>
    endfunction
endfunction
unlet s:bundle
" }}}

" indent-Guides{{{
if exists(":IndentGuidesEnable")
    let g:indent_guides_enable_on_vim_startup=0
    let g:indent_guides_color_change_percent=30
    let g:indent_guides_guide_size=1
    let g:fileIndentGuide=[
                \ "c", 
                \"cpp", 
                \"cs", 
                \"java", 
                \"perl", 
                \"ruby", 
                \"vim"
                \]
    for ft in g:fileIndentGuide
        execute "augroup " . "MyIndentGuideEnable_" . ft
        execute "autocmd!"
        execute "autocmd FileType " . ft . " :IndentGuidesEnable"
        execute "autocmd BufLeave *." . ft . " :IndentGuidesDisable"
        execute "augroup END"
    endfor
    " augroup IndentGuide
    " autocmd!
    " au BufRead,BufEnter *.c,*,cpp,*.java IndentGuidesEnable
    " au BufLeave *.c,*,cpp,*.java IndentGuidesDisable
    " au FileType help IndentGuidesDisable
    " augroup END
    au MyAutoCmd FileType help IndentGuidesDisable
endif
" }}}

" ttoc{{{
" メモツールとして使うhttp://nanasi.jp/articles/vim/ttoc_vim.html#id15
" configuration for filetype memo
augroup Memo
    autocmd!
    autocmd BufEnter *.memo :set filetype=markdown
augroup END
:let g:ttoc_rx_memo = '^\k\+\>'
" }}}

" calender.vim{{{
let g:calendar_diary = $DROPBOX_DIR. "/documents/diary"
" }}}

" vim-latex{{{
filetype plugin on
set shellslash
set grepprg=grep\ -nH\ $*
let g:Tex_DefaultTargetFormat = 'pdf'
let g:Tex_ViewRule_pdf = 'open -a Preview.app'
let g:Tex_CompileRule_dvi = 'platex-euc $*.tex'
let g:Tex_BibtexFlavor = 'jbibtex'
let g:Tex_FormatDependency_pfd = 'dvi,pdf'
let g:Tex_CompileRule_pdf = 'dvipdfmx $*.dvi'
" }}}

" tweetvim{{{
nnoremap <silent> ,ts :TweetVimSay<CR>

let s:bundle = neobundle#get("tweetvim")
" hooks の初期化
let s:bundle.hooks = get(s:bundle, "hooks", {})

" source 後に呼び出される処理を記述する
function! s:bundle.hooks.on_source(bundle)

    if !exists('g:neocomplcache_dictionary_filetype_lists')
        let g:neocomplcache_dictionary_filetype_lists={}
    endif
    let neco_dic = g:neocomplcache_dictionary_filetype_lists
    let neco_dic.tweetvim_say = $HOME . '/.tweetvim/screen_name'
    let g:tweetvim_include_rts = 1 "タイムラインにリツイートを含める
    let g:tweetvim_tweet_per_page = 40
    let g:tweetvim_display_source=1
    let g:tweetvim_display_time=1
    " キーマップ 参考:http://qiita.com/items/a28eb714151886358b1a
    augroup TweetVim
        autocmd!
        autocmd FileType tweetvim call s:mytweetvim()
    augroup END
    function! s:mytweetvim ()
        " nnoremap <buffer><silent>j :<C-u>call <SID>tweetvim_vertical_move("gj")<CR>zz
        " nnoremap <buffer><silent>k :<C-u>call <SID>tweetvim_vertical_move("gk")<CR>zz
        nnoremap <expr><buffer><silent>j <Plug>(tweetvim_action_cursor_up)
        nnoremap <expr><buffer><silent>k <Plug>(tweetvim_action_cursor_down)
        nmap <buffer><silent> <CR> <Plug>(tweetvim_action_open_links)
        nmap <buffer><silent> o <Plug>(tweetvim_action_enter)
        nmap <buffer><silent> R <Plug>(tweetvim_action_retweet)
        " バッファに移動した時に自動リロード
        " autocmd BufEnter * call <SID>tweetvim_reload()
    endfunction

    " セパレータを飛ばして移動する
    " ページの銭湯や末尾でそれ以上 上下に移動しようとしたらページ移動する
    function! s:tweetvim_vertical_move(cmd)
        set cursorline
        let end = line('$')
        while getline('.') !~# '^[-~]\+$' && line('.') != end && line('.') != 1
            execute "normal! ".a:cmd
        endwhile
        execute "normal! ".a:cmd
        " 一番下まで来たら次のページに進む
        let line = line('.')
        if line == end
            call feedkeys("\<Plug>(tweetvim_action_page_next)")
        elseif line == 1
            call feedkeys("\<Plug>(tweetvim_action_page_previous)")
        endif
    endfunction
endfunction
unlet s:bundle

" }}}

" memolist.vim{{{
let g:memolist_path=$DROPBOX_DIR."/documents/memo"
let g:memolist_memo_suffix = "txt"
let g:memolist_memo_date = "%Y-%m-%d %H:%M"
let g:memolist_memo_date = "epoch"
let g:memolist_memo_date = "%D %T"
" let g:memolist_prompt_tags = "true"
" let g:memolist_prompt_categories = "true"
" }}}

" vim-ref{{{
" lazy loading for vim-ref
nmap <silent> K :<C-u>silent! <Plug>(ref-keyword)
vmap <silent> K :<C-u>silent! <Plug>(ref-keyword)
command! -nargs=+ Ref
            \ execute 'silent! NeoBundleSource vim-ref'
            \ | call ref#ref(<q-args>)
" }}}

" sequence {{{
let g:loaded_sequence=1
" }}}

" powerline {{{
let g:Powerline_symbols='fancy'
" }}}

" CCTree.vim:"{{{
"
if 1 && filereadable($DOTVIM . '/Bundle/CCTree/ftplugin/cctree.vim')
    source $DOTVIM/bundle/CCTree/ftplugin/cctree.vim
endif
"}}}

" cscope_maps{{{
" This tests to see if vim was configured with the '--enable-cscope' option
" when it was compiled.  If it wasn't, time to recompile vim... 
if has("cscope")
    " use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
    set cscopetag

    " check cscope for definition of a symbol before checking ctags: set to 1
    " if you want the reverse search order.
    set csto=0

    " add any cscope database in current directory
    if filereadable("cscope.out")
        cs add cscope.out
        " else add the database pointed to by environment variable 
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif

    " show msg when any other cscope db added
    set cscopeverbose

    " cscope key mappings
    "   's'   symbol: find all references to the token under cursor
    "   'g'   global: find global definition(s) of the token under cursor
    "   'c'   calls:  find all calls to the function name under cursor
    "   't'   text:   find all instances of the text under cursor
    "   'e'   egrep:  egrep search for the word under cursor
    "   'f'   file:   open the filename under cursor
    "   'i'   includes: find files that include the filename under cursor
    "   'd'   called: find functions that function under cursor calls

    nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>

    nmap <C-@>s :scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>g :scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>c :scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>t :scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>e :scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>f :scs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-@>i :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@>d :scs find d <C-R>=expand("<cword>")<CR><CR>

    nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-@><C-@>i :vert scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@><C-@>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>
endif
"}}}

" Source-Explorer-srcexpl.vim:"{{{
"
" // The switch of the Source Explorer                                         "
" nmap <F8> :SrcExplToggle<CR>
"                                                                              "
" // Set the height of Source Explorer window                                  "
let g:SrcExpl_winHeight = 8
"                                                                              "
" // Set 100 ms for refreshing the Source Explorer                             "
let g:SrcExpl_refreshTime = 100
"                                                                              "
" // Set "Enter" key to jump into the exact definition context                 "
let g:SrcExpl_jumpKey = "<ENTER>"
"                                                                              "
" // Set "Space" key for back from the definition context                      "
let g:SrcExpl_gobackKey = "<SPACE>"
"                                                                              "
" // In order to Avoid conflicts, the Source Explorer should know what plugins "
" // are using buffers. And you need add their bufname into the list below     "
" // according to the command ":buffers!"                                      "
let g:SrcExpl_pluginList = [
            \ "__Tag_List__",
            \ "_NERD_tree_",
            \ "Source_Explorer"
            \ ]
"                                                                              "
" // Enable/Disable the local definition searching, and note that this is not  "
" // guaranteed to work, the Source Explorer doesn't check the syntax for now. "
" // It only searches for a match with the keyword according to command 'gd'   "
let g:SrcExpl_searchLocalDef = 1
"                                                                              "
" // Do not let the Source Explorer update the tags file when opening          "
let g:SrcExpl_isUpdateTags = 0
"                                                                              "
" // Use 'Exuberant Ctags' with '--sort=foldcase -R .' or '-L cscope.files' to "
" //  create/update a tags file                                                "
let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ."
"                                                                              "
" // Set "<F12>" key for updating the tags file artificially                   "
" let g:SrcExpl_updateTagsKey = "<F12>"
"}}}

" gtags.vim:"{{{
nmap <Leader>gs :<C-u>Gtags -s <C-R>=expand("<cword>")<CR><CR>
nmap <Leader>gg :<C-u>Gtags -g <C-R>=expand("<cword>")<CR><CR>
nmap <Leader>gf :<C-u>Gtags -f <C-R>=expand("<cfile>")<CR><CR>
nmap <Leader>gr :<C-u>Gtags -r <C-R>=expand("<cword>")<CR><CR>
nmap <Leader>gd :<C-u>Gtags -d <C-R>=expand("<cword>")<CR><CR>
"}}}

" ref.vim {{{
" webdict
let g:ref_source_webdict_sites ={
            \ 'wikipedia:ja' : 'http://ja.wikipedia.org/wiki/%s',
            \}
" let g:ref_source_webdict_sites = {
" \ 'wiktionary' : {
" \ 'url' : 'http://ja.wiktionary.org/wiki/%s',
" \ 'keyword_encoding' : 'utf-8',
" \ 'cache' : 1,
" \}
" \}

" 出力に対するフィルタ、最初の数行を削除
" function! g:ref_source_webdict_sites.wiktionary.filter(output)
" return join(split(a:output,"\n")[18 :], "\n")
" endfunction


" }}}

" vimwiki {{{
autocmd MyAutoCmd FileType vimwiki nnoremap <buffer> <leader>tt <Plug>VimwikiToggleListItem
" }}}

" exVim {{{
let $EX_DEV = '~/exdev'
" }}}

" fontzoom.vim {{{
function! MyPresenSetting()
    map <buffer> + <Plug>(fontzoom-larger)
    map <buffer> - <Plug>(fontzoom-smaller)
    set wrap
    set showbreak=
endfunction
" }}}

" surround.vim{{{
nmap <Leader>) csw)
nmap <Leader>( csw(
nmap <Leader>} csw}
nmap <Leader>{ csw{
nmap <Leader>[ csw[
nmap <Leader>] csw]
nmap <Leader>' csw'
nmap <Leader>" csw"
" }}}

" qfixhowm {{{
let QFixHowm_Key='g' 

let howm_dir = $HOME."/howm"
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.txt'
let g:qfixmemo_ext = 'howm'
let QFixHowm_FileType = 'qfix_memo'
" }}}

" w3m.vim {{{
let g:w3m#homepage = 'http://www.google.co.jp/'
" }}}

" rainbow_parentheses.vim{{{
augroup Rainbow_parentheses
    autocmd!
    au VimEnter * RainbowParenthesesToggle
    au Syntax * RainbowParenthesesLoadRound
    au Syntax * RainbowParenthesesLoadSquare
    au Syntax * RainbowParenthesesLoadBraces
augroup END
" }}}

" alignta.vim{{{
let g:Align_xstrlen=3
vnoremap <Leader>a :Alignta 
xnoremap <silent> A  :Alignta =>\=<CR>
xnoremap <silent> a: :Alignta  01 :<CR>
xmap <silent><expr> as mode() !=# 'v' ? ':Alignta \S\+'."\<CR>" : 'as'
xnoremap al :Alignta<Space>
" }}}

" syntastic{{{
let g:syntastic_enable_signs=1
let g:syntastic_auto_loc_list=2
" }}}

" Tweetvim-powerline-theme{{{
" let g:Powerline_theme='default_with_tweetvim'
" let g:Powerline_colorscheme='default_with_tweetvim'
" }}}

" Ruby {{{
let s:bundle_rails = 'unite-rails unite-rails_best_practices unite-rake alpaca_complete'

function! s:bundleLoadDepends(bundle_names) 
    " bundleの読み込み
    execute 'NeoBundleSource '.a:bundle_names
    au! RailsLazyPlugins
endfunction
aug RailsLazyPlugins
    au User Rails call <SID>bundleLoadDepends(s:bundle_rails)
aug END
" }}}

" operator-replace {{{
map R  <Plug>(operator-replace)
" }}}

" HybridText {{{
autocmd MyAutoCmd BufEnter * if &filetype =="" | setlocal ft=hybrid | endif
autocmd MyAutoCmd BufEnter * if &filetype =="text" | setlocal ft=hybrid | endif
" }}}

" neocomplcache-clang / neocomplcache-clang_complete{{{
" add neocomplcache option
let g:neocomplcache_force_overwrite_completefunc=1

" add clang_complete option
let g:clang_complete_auto=1
" }}}

" gmail.vim{{{
let g:gmail_user_name="kse.201@gmail.com"
" }}}

" java-api-complete {{{
" https://github.com/yuratomo/java-api-complete
au MyAutoCmd BufNewFile,BufRead *.java    setl omnifunc=javaapi#complete
" au MyAutoCmd CompleteDone *.java          call javaapi#showRef()
inoremap <expr> <c-down> javaapi#nextRef()
inoremap <expr> <c-up>   javaapi#prevRef()
if has("balloon_eval") && has("balloon_multiline") 
    au BufNewFile,BufRead *.java  setl bexpr=javaapi#balloon()
    au BufNewFile,BufRead *.java  setl ballooneval
endif
let g:javaapi#delay_dirs = [
            \ 'java-api-javax',
            \ 'java-api-org',
            \ 'java-api-sun',
            \ 'java-api-servlet2.3',
            \ 'java-api-android',
            \ ]
" }}}

" submode{{{
" http://d.hatena.ne.jp/thinca/20130131/1359567419
let g:submode_leave_with_key = 1
" window size
call submode#enter_with('winsize', 'n', '', '<C-w>>', '<C-w>>')
call submode#enter_with('winsize', 'n', '', '<C-w><', '<C-w><')
call submode#enter_with('winsize', 'n', '', '<C-w>+', '<C-w>-')
call submode#enter_with('winsize', 'n', '', '<C-w>-', '<C-w>+')
call submode#map('winsize', 'n', '', '>', '<C-w>>')
call submode#map('winsize', 'n', '', '<', '<C-w><')
call submode#map('winsize', 'n', '', '+', '<C-w>-')
call submode#map('winsize', 'n', '', '-', '<C-w>+')
" タブ移動 (端でループ移動)
function! s:SIDP()
    return '<SNR>' . matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SIDP$') . '_'
endfunction
function! s:movetab(nr)
    execute 'tabmove' g:V.modulo(tabpagenr() + a:nr - 1, tabpagenr('$'))
endfunction
let s:movetab = ':<C-u>call ' . s:SIDP() . 'movetab(%d)<CR>'
call submode#enter_with('movetab', 'n', '', 'gt', printf(s:movetab, 1))
call submode#enter_with('movetab', 'n', '', 'gT', printf(s:movetab, -1))
call submode#map('movetab', 'n', '', 't', printf(s:movetab, 1))
call submode#map('movetab', 'n', '', 'T', printf(s:movetab, -1))
unlet s:movetab
" }}}

" sugarpot{{{
" 設定例
let s:bundle = neobundle#get("vim-sugarpot")
function! s:bundle.hooks.on_source(bundle)
    " 使用するフォントとサイズが設定出来ます。
    let g:sugarpot_font = "Osaka:h1"

    " デフォルトだと立て伸びしてしまうのでこれで適当に調整してください
    let g:sugarpot_convert_resize = "50%x34%"
endfunction
unlet s:bundle
" }}}

" tmpwin.vim {{{
"http://rhysd.hatenablog.com/entry/2013/06/01/232858
" 絶対縦分割で開きたい
nnoremap <silent>_ :<C-u>call tmpwin#toggle('TweetVimHomeTimeline')<CR>
" }}}

" ccelerated-smooth-scroll.vim{{{
" http://yonchu.hatenablog.com/entry/2013/05/16/204727
" }}}

" tyru / foldballoon.vim{{{
if has("balloon_eval") && has("balloon_multiline") 
    set ballooneval
    set balloonexpr=foldballoon#balloonexpr()
endif
" }}}

" sequence{{{
vmap <m-a> <plug>SequenceV_Increment
vmap <m-x> <plug>SequenceV_Decrement
nmap <m-a> <plug>SequenceN_Increment
nmap <m-x> <plug>SequenceN_Decrement

vmap <c-a> <plug>SequenceAdd
vmap <c-x> <plug>SequenceSubtract
" }}}
" ================================================================================ 
" vim: set tw=0 tabstop=4 shiftwidth=4  fdm=marker fdl=0 :
