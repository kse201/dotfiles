"============================================================
"                  *** .vimrc.plugin ***                    |
"============================================================

augroup MyAutoCmd
    autocmd!
augroup END

" vimproc.vim{{{
if has('win64')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_win64.dll'
elseif has('win32')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_win32.dll'
elseif has('win32unix')
    set shellslash
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_cygwin.dll'
elseif has('mac')
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_mac.so'
elseif has('macunix')
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_unix.so'
else
    let g:vimproc_dll_path = $VIMFILE_DIR . '/bundle/vimproc/lib/vimproc_linux64.so'
endif
" }}}

" neobundle.vim{{{
set nocompatible
filetype plugin indent off
let g:bundle_dir = $VIMFILE_DIR."/bundle/"
if has('vim_starting')
    if !isdirectory(expand(g:bundle_dir."neobundle.vim/"))
        echo "install neobundle..."
        :call system("git clone git://github.com/Shougo/neobundle.vim ~/.vim/bundle/neobundle.vim")
    endif
    exe "set rtp+=".g:bundle_dir."neobundle.vim"
endif
call neobundle#begin(expand(g:bundle_dir))
let g:neobundle#types#git#default_protocol = 'https'
unlet g:bundle_dir

" dependents {{{
NeoBundle 'Shougo/vimproc', {'build' : {
            \ 'windows' : 'echo "Sorry, cannot update vimproc binary file in Windows."',
            \ 'cygwin' : 'make -f make_cygwin.mak',
            \ 'mac'    : 'make -f make_mac.mak',
            \ 'unix'   : 'make -f make_unix.mak',
            \ },
            \}
" }}}
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundleLazy 'vim-jp/vimdoc-ja.git'
" completation {{{
function! s:meet_neocomplete_requirements()
    return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction
if s:meet_neocomplete_requirements()
    NeoBundleLazy 'Shougo/neocomplete'
    NeoBundleFetch 'Shougo/neocomplcache'
else
    NeoBundleFetch 'Shougo/neocomplete'
    NeoBundleLazy 'Shougo/neocomplcache'
endif

call neobundle#config('neocomplcache',{
            \'lazy' : 1,
            \ 'autoload' : {
            \ 'insert' : 1,
            \}})

NeoBundleLazy "Shougo/neosnippet" ,{ 'depends' : 'Shougo/neosnippet-snippets' }
NeoBundleLazy "Shougo/neosnippet-snippets"
NeoBundle 'kana/vim-smartchr'
NeoBundleLazy 'mattn/emmet-vim', { 'autoload' : { 'filetypes' : ['html','css','js','php']}}
" }}}
" filer {{{
NeoBundleLazy 'scrooloose/nerdtree',
            \{ 'autoload' : {'commands' : ['NERDTreeToggle','NERDTree']}}
NeoBundleLazy 'Shougo/vimfiler',
            \ { 'depends' : 'Shougo/unite.vim' ,
            \ 'autoload' : {'commands' : ['VimFilerCurrentDir', 'VimFilerDouble']}}
" }}}
" unite {{{
NeoBundle 'Shougo/unite.vim'
NeoBundleLazy 'tsukkee/unite-tag'
NeoBundleLazy 'Shougo/unite-outline'
NeoBundleLazy 'tacroe/unite-mark'
NeoBundleLazy 'thinca/vim-unite-history'
NeoBundleLazy 'osyo-manga/unite-quickfix', {
            \ 'autoload' : {'filetypes':['c','cpp']
            \ }}
NeoBundleLazy 'unite-colorscheme'
NeoBundleLazy 'zhaocai/unite-scriptnames'
NeoBundle 'Shougo/neomru.vim',{  'depends' : 'Shougo/unite.vim' }
" }}}
" align {{{
NeoBundle 'h1mesuke/vim-alignta'
NeoBundle 'The-NERD-Commenter'
NeoBundleLazy "fuenor/JpFormat.vim"
" }}}
" 機能追加 {{{
NeoBundle 'itchyny/lightline.vim'
NeoBundleLazy 'thinca/vim-quickrun',
            \{ 'autoload' : {
            \'mappings' : ['<Plug>(quickrun)'],
            \ 'commands' : ['QuickRun']}}
NeoBundleLazy 'airblade/vim-gitgutter'
NeoBundleLazy 'open-browser.vim', {'autoload' : {'mappings' :['<Plug>(open-browser-wwwsearch)','<Plug>(openbrowser-smart-search)']}}
NeoBundle 'kana/vim-operator-user'
NeoBundle 'osyo-manga/vim-anzu'
NeoBundle 'fuenor/qfixhowm'
NeoBundle 't9md/vim-quickhl'
NeoBundle 'kana/vim-smartinput'
NeoBundle 'vim-scripts/scratch-utility'
NeoBundle 'scrooloose/syntastic'
NeoBundleLazy 'Takazudo/outline.vim.git'
" }}}
" markdown {{{
NeoBundleLazy 'kannokanno/previm' , { 'autoload' : { 'filetypes' : ['markdown'] }}
NeoBundleLazy 'kana/vim-submode' , { 'autoload' : { 'filetypes' : ['markdown'] }}
" }}}
" looks {{{
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'kien/rainbow_parentheses.vim'
NeoBundle 'tomasr/molokai'
NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'mrk21/yaml-vim'
" }}}
NeoBundleLazy 'fatih/vim-go' , { 'autoload' : {'filetypes' : ['go']} }
NeoBundleLazy 'davidhalter/jedi-vim' , {'autoload' : {'filetypes' : ['python']} }
NeoBundle 'tpope/vim-abolish'
NeoBundle 'Shougo/context_filetype.vim'
NeoBundle 'ujihisa/neco-look'
NeoBundle 'Shougo/neco-syntax'
NeoBundle 'fuenor/JpFormat.vim'
NeoBundle 'vim-scripts/DrawIt'
NeoBundle 'kana/vim-filetype-haskell'
NeoBundle 'eagletmt/ghcmod-vim'
NeoBundle 'ujihisa/neco-ghc'
NeoBundle 'thinca/vim-ref'
NeoBundle 'ujihisa/ref-hoogle'
NeoBundle 'majutsushi/tagbar.git'

filetype plugin indent on
syntax on

" 導入されていないpluginがあったら表示
if neobundle#exists_not_installed_bundles()
    echomsg 'Not installed bundles :' .
                \ string(neobundle#get_not_installed_bundle_names())
    echomsg 'Please execute ":NeoBundleInstall" command.' 
endif

command! Nbi :NeoBundleInstall
command! Nbu :NeoBundleUpdate
command! Nbl :NeoBundleLog


" plugin導入確認
let s:plugin_name =  map(neobundle#config#get_neobundles(),'(v:val).name')
let s:plugin_orig_name =  map(neobundle#config#get_neobundles(),'(v:val).orig_name')
function! s:checkplugin(name)
    for l:ele in s:plugin_name
        if l:ele ==# a:name
            return 1
        endif
    endfor
    for l:ele in s:plugin_orig_name
        if l:ele ==# a:name
            return 1
        endif
    endfor
    return 0
endfunction

" lazy loading when Vim loss focus.{{{
" [ref: http://d.hatena.ne.jp/osyo-manga/20140212/1392216949]
" Lazy しているプラグイン名をリストアップ
function! s:get_lazy_plugins()
    " 先に source したいプラグインをリストの先頭に追加する
    return [
\       "unite.vim",
\       "vimfiler.vim",
\       "vim-quickrun",
\   ] + map(filter(neobundle#config#get_neobundles(), "v:val.lazy"), "v:val.name")
endfunction


function! s:is_not_sourced(source)
    return neobundle#config#is_installed(a:source) && !neobundle#config#is_sourced(a:source)
endfunction

function! s:source()
    let sources =  map(filter(s:get_lazy_plugins(), "s:is_not_sourced(v:val)"), "v:val")
    if empty(sources)
        augroup auto-source
            autocmd!
        augroup END
        return
    endif
    echom "source:" . sources[0]
    call neobundle#source(sources[0])
    echom "sourced:" . sources[0]
endfunction


let s:active_auto_source = 0

" augroup auto-source
    " autocmd!
    " autocmd CursorHold * if s:active_auto_source | call s:source() | endif
    " autocmd FocusLost * let s:active_auto_source = 1
    " autocmd FocusGained * let s:active_auto_source = 0
" augroup END
" }}}

call neobundle#end()
" }}}

" neocomplete(neocomplcache) & neosnippet{{{
if s:meet_neocomplete_requirements()
" neocomplete & neosnippet {{{
if has('vim_starting') 
    augroup MyInitNeocomplete
        autocmd!
        autocmd InsertEnter * call s:LazyLoadingForNeocom() | call Init_neocomplete() | autocmd! MyInitNeocomplete
    augroup END
    function! s:LazyLoadingForNeocom()
        NeoBundleSource neocomplete
        NeoBundleSource neosnippet
    endfunction
endif

" Use neocomplete.
let g:neocomplete_enable_at_startup             = 0 " 起動時に有効化
" Use smartcase.
let g:NeoComplete_SmartCase                     = 1
let g:neocomplete_enable_auto_select            = 1
" Use camel case completion.
let g:NeoComplete_enable_camel_case_completion  = 0
" Use underbar completion.
let g:NeoComplete_EnableUnderbarCompletion      = 1
" Set minimum syntax keyword length.
let g:NeoComplete_MinSyntaxLength               = 3
" Set manual completion length.
" let g:NeoComplete_ManualCompletionStartLength = 2
" Print caching percent in statusline.
" let g:NeoComplete_CachingPercentInStatusline  = 1
let g:neocomplete_lock_buffer_name_pattern      = '\*ku\*'
let g:neocomplete#skip_auto_completion_time = '0.2'

let g:neocomplete#sources = { '_' : ['file', 'tag', 'neosnippet', 'vim', 'omni', 'member', 'syntax', 'include', 'buffer', 'file/include']}

" Define dictionary.
let g:neocomplete_dictionary_filetype_lists = {
            \ 'default'  : '',
            \ 'scheme'   : $HOME.'/.gosh_completions',
            \ 'ruby'     : $VIMFILE_DIR.'/dict/ruby.dict',
            \ 'objc'     : $VIMFILE_DIR.'/dict/cocoa.dict',
            \ 'tex'      : $VIMFILE_DIR.'/dict/tex.dict',
            \ 'java'     : $VIMFILE_DIR.'/dict/java.dict'
            \ }

" Define keyword.
if !exists('g:neoComplete_keyword_patterns')
    let g:neoComplete_keyword_patterns = {}
endif
let g:neoComplete_keyword_patterns['default'] = '\h\w*'
" ファイル名補間、オムニ補間をneocom組み込みのものに置き換え
" inoremap <expr><C-x><C-f>  neocomplete#manual_filename_complete()
" inoremap <expr> <C-j>  &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : neocomplete#manual_omni_complete()
"
" http://d.hatena.ne.jp/osyo-manga/20121021/1350749023
if !exists("g:neosnippet#snippets_directory")
    let g:neosnippet#snippets_directory=""
endif
" let g:NeoComplete_SnippetsDir = $VIMFILE_DIR.'/snippets'
let g:neosnippet#snippets_directory= $VIMFILE_DIR . '/snippets'
let g:neosnippet#enable_snipmate_compatibility = 0

" init neocomplete {{{
function! Init_neocomplete()
    NeoCompleteEnable
    " 候補の共通箇所まで補完する
    inoremap <expr><C-l> neocomplete#complete_common_string()
    " 決定
    inoremap <expr><C-y> neocomplete#close_popup()
    " inoremap <expr><CR> pumvisible() ? neocomplete#close_popup() : "\<CR>" 

    "snippet
    imap <expr><CR> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplete#close_popup() : "\<CR>" 
    imap <expr><C-y> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplete#close_popup() : "\<C-y>" 
    imap <expr><C-j> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplete#close_popup() : "\<C-j>" pneobu
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?  "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

    imap <C-q>  <Plug>(neocomplete_start_unite_complete)

    " キャンセルしてポップアップを閉じる
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    " ネオコンによって挿入した補完を元に戻す
    inoremap <expr><C-g>     neocomplete#undo_completion()
    " ポップアップが出ているときの挙動を快適にする
    " バックスペースしたときポップアップを閉じる
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

    " ネオコン設定変更操作
    " スニペットを編集する
    noremap <Leader>es :<C-u>vertical belowright NeoCompleteEditSnippets<CR>
endfunction
" }}}
" Term neocomplete{{{
function! Term_neocomplete()
    NeoCompleteDisable
    iunmap <C-g>
    iunmap <C-l>
    iunmap <C-q>
    iunmap <CR>
    iunmap <C-h>
    iunmap <BS>
    iunmap <C-y>
    iunmap <C-e>
    iunmap <TAB>
endfunction
" }}}
command! InitNeoComplete call Init_neocomplete()
command! TermNeoComplete call Term_neocomplete()

" Enable omni completion. {{{
augroup EnableOmniCompleteion
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup END
" }}}
" Enable heavy omni completion.{{{ 
if !exists('g:neocomplete_omni_patterns')
    let g:neocomplete_omni_patterns = {}
endif
let g:neocomplete_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
" }}}
" autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete{{{
let g:neocomplete_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplete_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplete_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'
" }}}
" }}}
else
" neocomplcache & neosnippet {{{
if has('vim_starting') 
    augroup MyInitNeocomplcache
        autocmd!
        autocmd InsertEnter * call s:LazyLoadingForNeocom() | call Init_neocomplcache() | autocmd! MyInitNeocomplcache
    augroup END
    function! s:LazyLoadingForNeocom()
        NeoBundleSource neosnippet
        NeoBundleSource neocomplcache
    endfunction
endif

" Use neocomplcache.
let g:neocomplcache_enable_at_startup             = 0 " 起動時に有効化
" Use smartcase.
let g:neocomplcache_enable_smart_case             = 1
let g:neocomplcache_enable_auto_select            = 1
" Use camel case completion.
let g:neocomplcache_enable_camel_case_completion  = 0
" Use underbar completion.
let g:neocomplcache_enable_underbar_completion    = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length             = 3
" Set manual completion length.
" let g:NeoComplCache_ManualCompletionStartLength = 2
" Print caching percent in statusline.
" let g:NeoComplCache_CachingPercentInStatusline  = 1
let g:neocomplcache_lock_buffer_name_pattern      = '\*ku\*'
let g:neocomplcache_skip_auto_completion_time     = '0.2'

" Examples:
if !exists('g:neocomplcache_sources_list')
    let g:neocomplcache_sources_list = {}
endif
let g:neocomplcache_sources_list._ = ['filename_include', 'member_complete', 'buffer_complete', 'include_complete', 'neosnippet', 'vim_complete', 'omni_complete', 'tags_complete']


" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
            \ 'default'  : '',
            \ 'scheme'   : $HOME.'/.gosh_completions',
            \ 'ruby'     : $VIMFILE_DIR.'/dict/ruby.dict',
            \ 'objc'     : $VIMFILE_DIR.'/dict/cocoa.dict',
            \ 'tex'      : $VIMFILE_DIR.'/dict/tex.dict',
            \ 'java'     : $VIMFILE_DIR.'/dict/java.dict'
            \ }

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
" ファイル名補間、オムニ補間をneocom組み込みのものに置き換え
" inoremap <expr><C-x><C-f>  neocomplcache#manual_filename_complete()
" inoremap <expr> <C-j>  &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : neocomplcache#manual_omni_complete()
"
" http://d.hatena.ne.jp/osyo-manga/20121021/1350749023
if !exists("g:neosnippet#snippets_directory")
    let g:neosnippet#snippets_directory=""
endif
" let g:NeoComplCache_SnippetsDir = $VIMFILE_DIR.'/snippets'
let g:neosnippet#snippets_directory= $VIMFILE_DIR . '/snippets'
let g:neosnippet#enable_snipmate_compatibility = 0

" init neocomplcache {{{
function! Init_neocomplcache()
    NeoComplCacheEnable
    " 候補の共通箇所まで補完する
    inoremap <expr><C-l> neocomplcache#complete_common_string()
    " 決定
    inoremap <expr><C-y> neocomplcache#close_popup()
    " inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>" 

    "snippet
    imap <expr><CR> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<CR>" 
    imap <expr><C-y> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<C-y>" 
    imap <expr><C-j> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? neocomplcache#close_popup() : "\<C-j>" pneobu
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?   "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?  "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

    imap <C-q>  <Plug>(neocomplcache_start_unite_complete)

    " キャンセルしてポップアップを閉じる
    inoremap <expr><C-e>  neocomplcache#cancel_popup()
    " ネオコンによって挿入した補完を元に戻す
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    " ポップアップが出ているときの挙動を快適にする
    " バックスペースしたときポップアップを閉じる
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"

endfunction
" }}}
" Term neocomplcache{{{
function! Term_neocomplcache()
    NeoComplCacheDisable
    iunmap <C-g>
    iunmap <C-l>
    iunmap <C-q>
    iunmap <CR>
    iunmap <C-h>
    iunmap <BS>
    iunmap <C-y>
    iunmap <C-e>
    iunmap <TAB>
endfunction
" }}}
command! InitNeoComplCache call Init_neocomplcache()
command! TermNeoComplCache call Term_neocomplcache()

" Enable omni completion. {{{
augroup EnableOmniCompleteion
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
augroup END
" }}}
" Enable heavy omni completion.{{{ 
if !exists('g:neocomplcache_omni_patterns')
    let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
" }}}
" autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete{{{
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'
" }}}
" }}}
endif
" }}}

" unite.vim{{{
" 参考:
" http://d.hatena.ne.jp/ruedap/20110110/vim_unite_plugin
" http://blog.remora.cx/2010/12/vim-ref-with-unite.html
let g:unite_split_rule="botright"
let g:unite_source_file_mru_filename_format = ''
" 入力モードで開始する
let g:unite_enable_start_insert=1
" file_mruの最大保存数
let g:unite_source_file_mru_limit=100
" 大文字小文字を区別しない
let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1

" Prefix-Key
nmap <Leader>a <SID>[unite]
nnoremap <SID>[unite] <Nop>

" ESCキーを2回押すと終了する
augroup uniteKeymap
    autocmd!
    au FileType unite nmap <silent><buffer> <ESC><ESC> <Plug>(unite_exit)
    au FileType unite nmap <silent><buffer> <C-c><C-c> <Plug>(unite_exit)
    au FileType unite imap <silent><buffer> <ESC><ESC> <Plug>(unite_exit)
    au FileType unite imap <silent><buffer> <C-c><C-c> <Plug>(unite_exit)
    au FileType unite nmap <silent><buffer> a <Plug>(unite_append_end)
    au FileType unite nmap <silent><buffer> f <Plug>(unite_quick_match_default_action)
    au FileType unite nmap <silent><buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    au FileType unite imap <silent><buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    au FileType unite imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
    au FileType unite nmap <buffer> -     <Plug>(unite_delete_backward_path)

    " ウィンドウを縦に分割して開く
    au FileType unite nnoremap <silent> <buffer> <expr> <C-Enter> unite#do_action('vsplit')
    au FileType unite inoremap <silent> <buffer> <expr> <C-Enter> unite#do_action('vsplit')

    au FileType unite nnoremap <silent> <buffer>  <C-k> :<C-u>call unite#mappings#do_action('right')<CR>
    au FileType unite setlocal tw=0
augroup END

" buffer
nnoremap <silent> <SID>[unite]b :<C-u>Unite -buffer-name=buffer buffer<CR>
" file
nnoremap <silent> <SID>[unite]f :<C-u>Unite -buffer-name=files file<CR>
" file
nnoremap <silent> <SID>[unite]m :<C-u>Unite -buffer-name=file_mru file_mru<CR>
" my favorite contents
nnoremap <silent> <SID>[unite]a :<C-u>UniteWithBufferDir -winheight=100 -hide-source-names -input= -buffer-name=files -no-split 
            \ output:echo\ "\ ===\ BUFFER\ ===\ " buffer 
            \ output:echo\ "\ ===\ TAB\ ===\ " tab 
            \ output:echo\ "\ ===\ FILE\ ===\ " file 
            \ output:echo\ "\ ===\ BOOKMARK\ ===\ "  bookmark 
            \ output:echo\ "\ ===\ FILE_MRU\ ===\ "  file_mru  
            \ output:echo\ "\ ===\ FILE/NEW\ ===\ "  file/new <CR>
" mru directory 
nnoremap <silent> <SID>[unite]d :<C-u>Unite directory_mru<CR>
" register
nnoremap <silent> <SID>[unite]r :<C-u>Unite register<CR>
" command history
nnoremap <silent> <SID>[unite]h :<C-u>Unite -default-action=edit history/command command<CR>
" jump
nnoremap <silent> <SID>[unite]j :<C-u>Unite jump<CR>
" search
nnoremap <silent> <SID>[unite]/ :<C-u>Unite -buffer-name=search line<CR>
nnoremap <silent> <SID>[unite]l :<C-u>Unite line<CR>
nnoremap <silent> <SID>[unite]l  :<C-u>UniteResume search<CR>
nnoremap <silent> <SID>[unite]: :<C-u>Unite command<CR>
" grep 
nnoremap <silent> <SID>[unite]g  :<C-u>Unite grep -buffer-name=search-buffer<CR>

" grep検索結果の再呼出
nnoremap <silent> <SID>[unite]r  :<C-u>UniteResume search-buffer<CR>
" unite-git-conflict
noremap <silent><Leader>ug : <C-u>Unite git-conflict<CR>

" 曖昧検索
call unite#custom#substitute('file,file_mru,history/command,directory_mru', '[[:alnum:]]', '*\0', 10)

" 様々なショートカット
" http://d.hatena.ne.jp/thinca/20101027/1288190498
call unite#custom#substitute('file,file_mru', '\$\w\+', '\=eval(submatch(0))', 20)
call unite#custom#substitute('file,file_mru', '[^~.]\zs/', '*/*', 20)
call unite#custom#substitute('file,file_mru', '/\ze[^*]', '/*', 10)
call unite#custom#substitute('file,file_mru', '^@@', '\=fnamemodify(expand("#"), ":p:h")."/*"', 2)
call unite#custom#substitute('file,file_mru', '^@', '\=getcwd()."/*"', 1)
call unite#custom#substitute('file,file_mru', '^;r', '\=$VIMRUNTIME."/"')
call unite#custom#substitute('file,file_mru', '^\~', escape($HOME, '\'), -2)
call unite#custom#substitute('file,file_mru', '^\\', escape($HOME, '\'), -2)
call unite#custom#substitute('file,file_mru', '\\\@<! ', '\\ ', -20)
call unite#custom#substitute('file,file_mru', '\\ \@!', '/', -30)
if has('win32') || has('win64') || has('win32unix')
    call unite#custom#substitute('file,file_mru', '^;p', 'C:\Program File,file_mrus\')
    call unite#custom#substitute('file,file_mru', '^;v', '~/vimfile,file_mru/')
else
    call unite#custom#substitute('file,file_mru', '^;v', '~/.vim/')
endif

" よくコマンドを登録してuniteで選択して起動 {{{ 
let s:unite_source_myCommand ={
            \ "name" : "myCommand"
            \}

function! s:unite_source_myCommand.gather_candidates(args,conext)
    let cmds = {
                \"Unite LazyLoading" : "Unite neobundle/lazy",
                \"Neobundle  Update" : "Unite neobundle/update",
                \ "NeoBundleSource"  : "Unite neobundle/lazy",
                \"Neobundle Log" : "NeoBundleLog",
                \"Show relative number" : "RN",
                \ "TODO list" : "Unite line -input=TODO", 
                \ 'vertical diff' : "vertical diffsplit ",
                \ 'Bookmark' : "Unite bookmark",
                \}
    return values(map(cmds,"{
                \ 'word' : v:key,
                \ 'source' : 'myCommand',
                \ 'kind' : 'command',
                \ 'action__command' : v:val
                \}"))
endfunction
call unite#define_source(s:unite_source_myCommand)
nnoremap <SID>[unite]c :Unite myCommand<CR>
" }}}
" help イースターエッグ{{{
let s:unite_source_myCommand ={
            \ "name" : "easter_egg"
            \}

function! s:unite_source_myCommand.gather_candidates(args,conext)
    let cmds = {
                \ "help 42" : "help 42",
                \ "help holy-grail" : "help holy-grail",
                \ "help map-modes" : "help map-modes" ,
                \ "help UserGettingBored" : "help UserGettingBored" ,
                \ "help spoon" : "help spoon" ,
                \ "help showmatch" : "help showmatch" ,
                \ "help bar" : "help bar" ,
                \ "Ni!" : "Ni!" ,
                \}
    return values(map(cmds,"{
                \ 'word' : v:key,
                \ 'source' : 'myCommand',
                \ 'kind' : 'command',
                \ 'action__command' : v:val
                \}"))
endfunction
call unite#define_source(s:unite_source_myCommand)
nnoremap <SID>[unite]c :Unite myCommand<CR>
" }}}
" }}}

" smartchr.vim{{{
" コマンドモード時のエスケープ入力補助

if s:checkplugin("vim-smartchr" )
    cnoremap <expr> /
                \ getcmdtype()=='/' ? '\/' : '/'
    cnoremap <Leader>/ /
    " cnoremap <expr> / search('.*/\%#', 'bcn')? '/' : smartchr#one_of('/', '\/')
    " if filereadable(expand($VIMFILES_DIR . '/bundle/vim-smartchr/autoload/smartchr.vim'))
    cnoremap <expr> <  smartchr#one_of('<', '\<', '<<')
    cnoremap <expr> >  smartchr#one_of('>', '\>', '>>')
    cnoremap <expr> \  smartchr#one_of('\', '\' , '\\')
    cnoremap <expr> (  smartchr#one_of('(' , '\(', '((')
    cnoremap <expr> )  smartchr#one_of(')' , '\)', '))')
    cnoremap <expr> %  smartchr#one_of('%' , '\%', '%%')
    " cnoremap <expr> |  smartchr#one_of('|', '\|', '||')

    " 参考:http://d.hatena.ne.jp/ampmmn/20080925/1222338972
    " 演算子記号の前後に空白を入れるなど
    " (多分)C/C++コーディング用
    function! SmartCharSetting() " {{{
        "四則演算
        inoremap <buffer><expr> + smartchr#loop(' + ', '++')
        inoremap <buffer><expr> - smartchr#loop(' - ', '--')
        " inoremap <buffer><expr> * smartchr#loop(' * ', '**')

        " =の場合、単純な代入や比較演算子として入力する場合は前後にスペースをいれる。
        " 複合演算代入としての入力の場合は、直前のスペースを削除して=を入力
        inoremap <buffer><expr> = search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\<bar>*\<bar>\) \%#', 'bcn')? '<bs>= '
                    \ : smartchr#loop(' = ', ' == ', '=')
        inoremap <buffer><expr> < search('^#include\%#', 'bcn')? ' <><Left>': smartchr#loop('<', ' < ', ' << ' , '')
        inoremap <buffer><expr> > search('^#include <.*\%#', 'bcn')? '>': smartchr#loop('>', ' > ', ' >> ')

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>': smartchr#loop('"', ' " ')
        inoremap <buffer><expr> " search('^#include ".*\%#', 'bcn')? '"': smartchr#loop('"', ' " ',)

        inoremap <buffer><expr> , smartchr#loop(', ', ',')
        "inoremap <buffer><expr> / smartchr#loop('/', ' / ', '//')
        inoremap <buffer><expr> & smartchr#loop('&', ' & ', ' && ')
        inoremap <buffer><expr> % smartchr#loop('%', ' % ')
        inoremap <buffer><expr> <Bar> smartchr#loop(' <Bar> ', ' <Bar><Bar> ', '<Bar>')
        " 3項演算子の場合は、後ろのみ空白を入れる
        inoremap <buffer><expr> ? smartchr#loop('?', '? ')
        inoremap <buffer><expr> : smartchr#loop(':', '::', ': ')

        " 下記の文字は連続して現れることがまれなので、二回続けて入力したら改行する
        "inoremap <buffer><expr> } smartchr#one_of('}', '}<CR>')
        "inoremap <buffer><expr> ; smartchr#one_of(';', ';<CR>')
        " 「->」は入力しづらいので、..で置換え
        inoremap <buffer><expr> . smartchr#loop('.', '->', '...')
        " 行先頭での@入力で、プリプロセス命令文を入力
        inoremap <buffer><expr> @ search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '@'): '@'
        inoremap <buffer><expr> # search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '#'): '#'

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>"': '""<Left>'
        " 制御構文直後の(は自動で間に空白を入れる
        inoremap <buffer><expr> ( search('\<\if\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\for\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\while\%#', 'bcn')? ' ()<Left>': '()<Left>'
    endfunction " }}}

    " Objective-C用(未完)
    function! SmartCharForObjc() "{{{
        inoremap <buffer><expr> @ search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of( '@interface','@implementation', '@synthesize', '@property', '@class' , '@'): '@'
        inoremap <buffer><expr> # search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '#import' , '#'): '#'
        inoremap <buffer><expr> - search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('- ()<Left>' ,  '-') :smartchr#loop(' - ', '--')
        inoremap <buffer><expr> + search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('+ ()<Left>' ,  '+') :smartchr#loop(' + ', '++')
    endfunction " }}}

    function! SmartCharForruby() " {{{
        "四則演算
        inoremap <buffer><expr> + smartchr#loop(' + ', '++')
        inoremap <buffer><expr> - smartchr#loop(' - ', '--')
        " inoremap <buffer><expr> * smartchr#loop(' * ', '**')

        " =の場合、単純な代入や比較演算子として入力する場合は前後にスペースをいれる。
        " 複合演算代入としての入力の場合は、直前のスペースを削除して=を入力
        inoremap <buffer><expr> = search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\<bar>*\<bar>\) \%#', 'bcn')? '<bs>= '
                    \ : smartchr#loop(' = ', ' == ', ' => ', '=')
        inoremap <buffer><expr> < search('^#include\%#', 'bcn')? ' <><Left>': smartchr#loop('<', ' < ', ' << ' , '')
        inoremap <buffer><expr> > search('^#include <.*\%#', 'bcn')? '>': smartchr#loop('>', ' > ', ' >> ')

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>': smartchr#loop('"', ' " ')
        inoremap <buffer><expr> " search('^#include ".*\%#', 'bcn')? '"': smartchr#loop('"', ' " ',)

        inoremap <buffer><expr> , smartchr#loop(', ', ',')
        "inoremap <buffer><expr> / smartchr#loop('/', ' / ', '//')
        inoremap <buffer><expr> & smartchr#loop('&', ' & ', ' && ')
        inoremap <buffer><expr> % smartchr#loop('%', ' % ')
        inoremap <buffer><expr> <Bar> smartchr#loop(' <Bar> ', ' <Bar><Bar> ', '<Bar>')
        " 3項演算子の場合は、後ろのみ空白を入れる
        inoremap <buffer><expr> ? smartchr#loop('?', '? ')
        inoremap <buffer><expr> : smartchr#loop(':', '::', ': ')

        " 下記の文字は連続して現れることがまれなので、二回続けて入力したら改行する
        "inoremap <buffer><expr> } smartchr#one_of('}', '}<CR>')
        "inoremap <buffer><expr> ; smartchr#one_of(';', ';<CR>')
        " 「->」は入力しづらいので、..で置換え
        inoremap <buffer><expr> . smartchr#loop('.', '->', '...')
        " 行先頭での@入力で、プリプロセス命令文を入力
        inoremap <buffer><expr> @ search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '@'): '@'
        inoremap <buffer><expr> # search('^\(#.\+\)\?\%#','bcn')? smartchr#one_of('#define', '#include', '#ifdef', '#endif', '#'): '#'

        inoremap <buffer><expr> " search('^#include\%#', 'bcn')? ' ""<Left>"': '""<Left>'
        " 制御構文直後の(は自動で間に空白を入れる
        inoremap <buffer><expr> ( search('\<\if\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\for\%#', 'bcn')? ' ()<Left>': '()<Left>'
        inoremap <buffer><expr> ( search('\<\while\%#', 'bcn')? ' ()<Left>': '()<Left>'
    endfunction " }}}
endif
" }}}

" NERD Commenter{{{
" http://d.hatena.ne.jp/nishikawasasaki/20101226/1293374432
let g:NERDCreateDefaultMappings = 0
let NERDSpaceDelims = 1
nmap <Leader><Leader> <Plug>NERDCommenterToggle
vmap <Leader><Leader> <Plug>NERDCommenterToggle
" }}}

" nerdtree{{{
nnoremap <F11> :NERDTreeToggle<CR>
" }}}

" QuickRun.vim{{{
try 
    if !exists("g:quickrun_config")
        let g:quickrun_config={}
        let g:quickrun_config = {
                    \   '*': {'runmode': 'async:remote:vimproc'},
                    \ }
    endif
    " nnoremap <silent><unique> <F5> <Plug>(quickrun)
    nnoremap <silent> <F5> :QuickRun<CR>
    nnoremap          <F6> :QuickRun -outputter error:buffer:quickfix -args ''<Left>
    nnoremap <silent> <F7> :QuickRun -outputter quickfix<CR>
    " Programごとの設定{{{
    " Markdown{{{
    let g:quickrun_config['markdown']={
                \ 'outputter' : 'null',
                \ 'command'   : 'open',
                \ 'cmdopt'    : '-a',
                \ 'args'      : 'Marked',
                \ 'exec'      : '%c %o %a %s',
                \}
    " \'type': 'markdown/pandoc',
    " \'cmdopt' : '-s',
    " " \'command': 'bluecloth',
    " " \'exec': '%c -f %s', 
    "}}}
    " Ruby{{{
    let g:quickrun_config['Ruby'] = {
                \ "type" : "ruby",
                \ "outputter" : "error:buffer:quickfix",
                \}
    " }}}
catch /E117/
endtry
" }}}
" }}}

" open-browser{{{
" disable netrw's gx mapping.
let g:netrw_nogx = 1
nmap go <Plug>(openbrowser-smart-search)
vmap go <Plug>(openbrowser-smart-search)
" }}}

" vimfiler{{{
nnoremap <leader>vf :<c-u>VimFilerCurrentDir -auto-cd -split  -no-quit -direction=topleft<cr>
nnoremap <leader>vd :<c-u>VimFilerDouble -auto-cd -double -explorer -no-quit -direction=topleft<cr>

let s:bundle = neobundle#get("vimfiler")
" hooksの初期化
let s:bundle.hooks = get(s:bundle,"hooks", {})

function! s:bundle.hooks.on_source(bundle)
    let g:vimfiler_as_default_explorer=1
    let g:vimfiler_safe_mode_by_default=0
    call vimfiler#set_execute_file('vim', 'vim')
    call vimfiler#set_execute_file('txt', 'notepad')
    call vimfiler#set_execute_file('c', ['vim', 'notepad'])

    " Edit file by tabedit.
    "let g:vimfiler_edit_action = 'tabopen'

    " Enable file operation commands.
    "let g:vimfiler_safe_mode_by_default = 0

    " Like Textmate icons.
    let g:vimfiler_tree_leaf_icon = ' '
    let g:vimfiler_tree_opened_icon = '▾'
    let g:vimfiler_tree_closed_icon = '▸'
    let g:vimfiler_file_icon = '-'
    let g:vimfiler_marked_file_icon = '*'

    " Use trashbox.
    " Windows only and require latest vimproc.
    "let g:unite_kind_file_use_trashbox = 1
    "デフォルトのキーマッピングを変更
    augroup VimFiler 
        autocmd!
        autocmd FileType vimfiler call s:vimfiler_my_settings()
    augroup END
    function! s:vimfiler_my_settings()
        nmap <buffer> q <Plug>(vimfiler_exit)
        nmap <buffer> Q <Plug>(vimfiler_hide)
        nmap <buffer> <TAB> <Plug>(vimfiler_switch_to_another_vimfiler)
        nmap <buffer> <C-a> <Plug>(vimfiler_toggle_mark_all_lines)
        " nnoremap <buffer><silent> / :<C-u>UniteWithBufferDir file -default-action=vimfiler -buffer-name=files<CR>
    endfunction
endfunction
unlet s:bundle
" }}}

" indent-Guides{{{
if exists(":IndentGuidesEnable")
    let g:indent_guides_enable_on_vim_startup=0
    let g:indent_guides_color_change_percent=30
    let g:indent_guides_guide_size=1
    let g:fileIndentGuide=[
                \"c", 
                \"ruby", 
                \"python", 
                \"vim"
                \]
    for ft in g:fileIndentGuide
        execute "augroup " . "MyIndentGuideEnable_" . ft
        execute "autocmd!"
        execute "autocmd FileType " . ft . " :IndentGuidesEnable"
        execute "autocmd BufLeave *." . ft . " :IndentGuidesDisable"
        execute "augroup END"
    endfor
    " augroup IndentGuide
    " autocmd!
    " au BufRead,BufEnter *.c,*,cpp,*.java IndentGuidesEnable
    " au BufLeave *.c,*,cpp,*.java IndentGuidesDisable
    " au FileType help IndentGuidesDisable
    " augroup END
    au MyAutoCmd FileType help IndentGuidesDisable
endif
" }}}

" surround.vim{{{
nmap <Leader>) csw)
nmap <Leader>( csw(
nmap <Leader>} csw}
nmap <Leader>{ csw{
nmap <Leader>[ csw[
nmap <Leader>] csw]
nmap <Leader>' csw'
nmap <Leader>" csw"
nmap <Leader>" csw"

vmap <Leader>) S)
vmap <Leader>( S(
vmap <Leader>} S}
vmap <Leader>{ S{
vmap <Leader>[ S[
vmap <Leader>] S]
vmap <Leader>' S'
vmap <Leader>" S"
vmap <Leader>" S"
" }}}

" qfixhowm {{{
let QFixHowm_Key='g' 

let howm_dir = $HOME."/howm"
let howm_filename = '%Y/%m/%Y-%m-%d-%H%M%S.txt'
let g:qfixmemo_ext = 'howm'
let QFixHowm_FileType = 'markdown'
let QFixHowm_Title = '#'
let QFix_PreviewEnable = 0
let QFixHowm_MenuPreview = 0
" タイトル行検索正規表現の辞書を初期化
let QFixMRU_Title = {}
" MRUでタイトル行とみなす正規表現(Vimの正規表現で指定)
let QFixMRU_Title['txt']       = '^###[^#]'
" grepでタイトル行とみなす正規表現(使用するgrepによっては変更する必要があります)
let QFixMRU_Title['txt_regxp'] = '^###[^#]'

let QFix_Height = 3
let QFix_Width = 0
" QuickFixウィンドウの開き方
let QFix_CopenCmd = ''
" QuickFixウィンドウでカーソルラインを表示
let QFix_CursorLine = 1
" カレントウィンドウの最低幅(Vim設定値)
set winwidth=20
" QuickFixウィンドウのプレビューでfiletype別のハイライトを有効
let QFix_PreviewFtypeHighlight = 1

" QuickFixウィンドウから開いた後ウィンドウを閉じる
let QFix_CloseOnJump = 0
" QuickFixウィンドウの <S-CR> は分割ではなくタブで開くには 'tab
let QFix_Edit = ''
" QuickFixウィンドウではなくロケーションリストを使用する
let QFix_UseLocationList = 0
" }}}

" rainbow_parentheses.vim{{{
augroup Rainbow_parentheses
    autocmd!
    au VimEnter * RainbowParenthesesToggle
    au Syntax * RainbowParenthesesLoadRound
    au Syntax * RainbowParenthesesLoadSquare
    au Syntax * RainbowParenthesesLoadBraces
augroup END
" }}}

" alignta.vim{{{
let g:Align_xstrlen=3
vnoremap <Leader>a :Alignta 
xnoremap <silent> A  :Alignta =>\=<CR>
xnoremap <silent> a: :Alignta  01 :<CR>
xmap <silent><expr> as mode() !=# 'v' ? ':Alignta \S\+'."\<CR>" : 'as'
xnoremap al :Alignta<Space>
" }}}

" HybridText {{{
autocmd MyAutoCmd BufEnter * if &filetype =="" | setlocal ft=hybrid | endif
autocmd MyAutoCmd BufEnter * if &filetype =="text" | setlocal ft=hybrid | endif
" }}}

" vim-gitgutter{{{
" let g:gitgutter_sign_added = '✚'
" let g:gitgutter_sign_modified = '➜'
" let g:gitgutter_sign_removed = '✘'
let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '*'
let g:gitgutter_sign_removed = '-'
" }}}

" lightline.vim{{{
let g:lightline = {
        \ 'colorscheme': 'landscape',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [
        \     ['mode', 'paste'],
        \     ['gitgutter', 'filename','modified','anzu'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'syntastic'],
        \     ['percent'],
        \     ['charcode', 'fileformat', 'fileencoding', 'filetype'],
        \   ]
        \ },
        \ 'component_function': {
        \   'modified': 'MyModified',
        \   'readonly': 'MyReadonly',
        \   'filename': 'MyFilename',
        \   'fileformat': 'MyFileformat',
        \   'filetype': 'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'mode': 'MyMode',
        \   'syntastic': 'SyntasticStatuslineFlag',
        \   'charcode': 'MyCharCode',
        \   'gitgutter': 'MyGitGutter',
        \   'anzu': 'anzu#search_status',
        \ }
        \ }
        " \ 'separator': {'left': '⮀', 'right': '⮂'},
        " \ 'subseparator': {'left': '⮁', 'right': '⮃'}

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &ro ? '⭤' : ''
endfunction

function! MyFilename()
  return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'unite' ? unite#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFileformat()
  return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  return winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
        \ || ! get(g:, 'gitgutter_enabled', 0)
        \ || winwidth('.') <= 90
    return ''
  endif
  let symbols = [
        \ g:gitgutter_sign_added . ' ',
        \ g:gitgutter_sign_modified . ' ',
        \ g:gitgutter_sign_removed . ' '
        \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return join(ret, ' ')
endfunction

" https://github.com/Lokaltog/vim-powerline/blob/develop/autoload/Powerline/Functions.vim
function! MyCharCode()
  if winwidth('.') <= 70
    return ''
  endif

  " Get the output of :ascii
  redir => ascii
  silent! ascii
  redir END

  if match(ascii, 'NUL') != -1
    return 'NUL'
  endif

  " Zero pad hex values
  let nrformat = '0x%02x'

  let encoding = (&fenc == '' ? &enc : &fenc)

  if encoding == 'utf-8'
    " Zero pad with 4 zeroes in unicode files
    let nrformat = '0x%04x'
  endif

  " Get the character and the numeric value from the return value of :ascii
  " This matches the two first pieces of the return value, e.g.
  " "<F>  70" => char: 'F', nr: '70'
  let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

  " Format the numeric value
  let nr = printf(nrformat, nr)

  return "'". char ."' ". nr
endfunction
" }}}

"" vim-anzu関連 {{{
nmap n <Plug>(anzu-n)zz
nmap N <Plug>(anzu-N)zz
nmap * <Plug>(anzu-star)zz
nmap # <Plug>(anzu-sharp)zz
augroup vim-anzu
" 一定時間キー入力がないとき、ウインドウを移動したとき、タブを移動したときに
" 検索ヒット数の表示を消去する
    autocmd!
    autocmd CursorHold,CursorHoldI,WinLeave,TabLeave * call anzu#clear_search_status()
augroup END
"}}}
"
" previm{{{

if has('mac')
    let g:previm_open_cmd = 'open'
else
    let g:previm_open_cmd = ''
endif
nnoremap <silent> <F7> :PrevimOpen<CR>
"nnoremap <silent> <F7> :PrevimOpen \|:Silent open -a it2_f &<CR>
nmap <silent> <Leader>j <Plug>(ChromeScrollDown)
nmap <silent> <Leader>k <Plug>(ChromeScrollUp)
nmap <silent> <Leader>q <Plug>(ChromeTabClose)
nmap <buffer> <Leader>f <Plug>(ChromeKey)
" }}}

" quickhl {{{
nmap <Space>m <Plug>(quickhl-manual-this)
xmap <Space>m <Plug>(quickhl-manual-this)
nmap <Space>M <Plug>(quickhl-manual-reset)
xmap <Space>M <Plug>(quickhl-manual-reset)
" }}}

" syntastic {{{
let g:syntastic_python_checkers = ['pyflakes', 'pep8']
" }}}

let g:gocomplete#system_function = 'vimproc#system'
"" ================================================================================ 
" vim: set tw=0 tabstop=4 shiftwidth=4  fdm=marker fdl=0 :
