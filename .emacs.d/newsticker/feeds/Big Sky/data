;; -*- coding: utf-8 -*-
(("Big Sky" "システム開発屋がひっそり語るぼやき" "http://mattn.kaoriya.net/" (20693 49617 123338) feed 0 nil nil ((title nil "Big Sky") (link nil "http://mattn.kaoriya.net/") (description nil "システム開発屋がひっそり語るぼやき") (language nil "ja") (generator nil "blosxom/2.1.2+dev") (atom:link ((rel . "self") (href . "http://mattn.kaoriya.net/index.rss") (type . "application/rss+xml"))) (atom:link ((rel . "hub") (href . "http://pubsubhubbub.appspot.com/"))) (item nil (title nil "最近の mruby 業界まとめ") (pubDate nil "Fri, 21 Dec 2012 13:53:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/ruby/20121221135228.htm") (category nil "mruby") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/ruby/20121221135228.htm") (description nil "
トピックス

<ul>
	<li>mrbgems が入った</li>
	<li>お前はどこのワカメじゃ</li>
	<li>ビルド方法が変わった</li>
	<li>mruby-uv mruby-http mruby-sinatic</li>
	<li>mruby-json</li>
	<li>mruby-sqlite3</li>
	<li>mruby-curl</li>
	<li>そして mruby-v8</li>
</ul>

<h4>mrbgems が入った</h4>

mruby に GEM っぽい物が入った。<br />
とは言ってもスタティックリンクなのでダイナミックローディングしてくれる訳じゃない。<br />
しかしながらパッケージを導入する上での取り決めが決まりつつあると言った感じ。<br />
使うには <code>MRUBY_ROOT</code> という環境変数を mruby のリポジトリトップに設定しておき、<code>MAKEFILE_4_GEM</code> を <code>$MRUBY/mrbgems/Makefiel4gem</code>
にしておくと良い。後者は要らなくなったかもしれない。<br />
具体的には

<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/GEMS.active
</blockquote>

というファイルに使う mrbgems のフォルダを一覧しておくとビルドの際に一緒にビルドおよびリンクしてくれるという物。<br />

<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/g
</blockquote>

の下に置く場合は絶対パスではなくフォルダ名だけで良い。<br />

mrbgems には大きく2つあって、C言語で書く拡張と、ruby 形式で書く物がある。後者はビルド時にバイナリ化されてリンクされる。<br />
C言語で書く際のお手本としては <a href=\"https://github.com/mattn/mruby-md5\">mruby-md5</a> が良いと思う。<br />
<br />

<h4>お前はどこのワカメじゃ</h4>

mrbgems は bovi という人がパッチ書いて取り込まれたのだけど、既存の拡張をどうやって mrbgems 化するか聞いてたら「やってあげる」という神キタコレな運びとなって mruby-md5 を mrbgems 化して貰えた。その時の出来事が彼のブログに載っているのだが

<blockquote class=\"quote\">
	<a href=\"http://mruby.sh/201212101231.html\">mrbgems in HEAD - mruby.sh</a>
	<br />
	<cite>http://mruby.sh/201212101231.html</cite>
</blockquote>

<blockquote class=\"code\">
assert(<span class=\"Special\">'</span><span class=\"Constant\">MD5 Hash for old example</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span><br />
&nbsp;&nbsp;<span class=\"Type\">MD5</span>::md5_hex(<span class=\"Special\">'</span><span class=\"Constant\">お前はどこのワカメじゃ</span><span class=\"Special\">'</span>) ==&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">43820f48a8506c8e2fae6f8558971920</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
</blockquote>

まさか誰も僕のソースなんか見ないだろうと思って書いてたコードを使ってテストにしてくれました。恥ずかしい...<br />
<br />

<h4>ビルド方法が変わった</h4>

ここ最近の大きな変更。<br />
これまでは Makefile もしくは cmake でビルドしていたけど、CRuby と minirake というスクリプトを使ってビルドする仕組みが入りました。現在のルートにある Makefile はこれを呼び出しているだけです。<br />
<br />

<h4>mruby-uv mruby-http mruby-sinatic</h4>

以前から作ってましたが、Matz さんにアドバイスを貰って安定動作する様になりました。<br />
<br />

<a href=\"https://github.com/mattn/mruby-uv\">https://github.com/mattn/mruby-uv</a><br />
<a href=\"https://github.com/mattn/mruby-http\">https://github.com/mattn/mruby-http</a><br />
<a href=\"https://github.com/mattn/mruby-sinatic\">https://github.com/mattn/mruby-sinatic</a><br />
<br />

Windows のしょぼいマシンでもちょっとしたHTTPサーバ(example/server.rb)で 4000 req/sec は出ます。<br />
mruby-sinatic は<a href=\"http://mattn.kaoriya.net/software/lang/ruby/20120509211817.htm\">コレ</a>を mrbgems 化した物です。<br />
<br />

<h4>mruby-json</h4>

以前から JSON パーサが欲しかったので自分で書きました。<br />
<br />

<a href=\"https://github.com/mattn/mruby-json\">https://github.com/mattn/mruby-json</a><br />
<br />
内部では <a href=\"http://mattn.kaoriya.net/software/lang/c/20121102175736.htm\">parson</a> を使ってます。<br />
2時間程度で作った物で<a href=\"http://togetter.com/li/424919\">メモリ開放漏れてました</a>が...<br />
<br />

<h4>mruby-sqlite3</h4>

こちらも自分で...<br />
<br />

<a href=\"https://github.com/mattn/mruby-sqlite3\">https://github.com/mattn/mruby-sqlite3</a><br />
<br />

<blockquote class=\"code\">
db =&nbsp;<span class=\"Type\">SQLite3</span>::<span class=\"Type\">Database</span>.new(<span class=\"Special\">'</span><span class=\"Constant\">foo.db</span><span class=\"Special\">'</span>)<br />
db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from foo</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">row</span>,&nbsp;<span class=\"Identifier\">fields</span>|<br />
&nbsp;&nbsp;puts row<br />
<span class=\"Statement\">end</span><br />
<br />
row = db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from bar</span><span class=\"Special\">'</span>)<br />
puts row.fields()<br />
<span class=\"Statement\">while</span>&nbsp;!row.eof?<br />
&nbsp;&nbsp;puts row.next()<br />
<span class=\"Statement\">end</span><br />
row.close()<br />
</blockquote>

こんな風に使います。<br />
<br />

<h4>mruby-curl</h4>

proxy 超えられて SSL も使える HTTP クライアントが欲しかったので書いた。<br />
<br />

<a href=\"https://github.com/mattn/mruby-curl\">https://github.com/mattn/mruby-curl</a><br />
<br />
個人的にはかなり便利になった思う。<br />
HTTP::Response を返すので mruby-http が必要。<br />
mruby-json と mruby-curl を使って Gist をポストしてみました。

<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">ARGV</span>.size !=&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;<span class=\"Statement\">raise</span>&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">gist.rb [GIST_TOKEN]</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
<br />
req =&nbsp;<span class=\"Type\">HTTP</span>::<span class=\"Type\">Request</span>.new<br />
req.method =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">POST</span><span class=\"Special\">&quot;</span><br />
req.body =&nbsp;<span class=\"Type\">JSON</span>::stringify({<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">description</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">We love mruby!</span><span class=\"Special\">&quot;</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">public</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Constant\">true</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">files</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">file1.txt</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">content</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">mruby is awesome!</span><span class=\"Special\">&quot;</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
})<br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Authorization</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">token&nbsp;</span><span class=\"Special\">#{</span><span class=\"Identifier\">ARGV</span>[<span class=\"Constant\">0</span>]<span class=\"Special\">}</span><span class=\"Special\">&quot;</span><br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Content-Type</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">application/json</span><span class=\"Special\">&quot;</span><br />
<span class=\"Type\">Curl</span>::<span class=\"Type\">SSL_VERIFYPEER</span>&nbsp;=&nbsp;<span class=\"Constant\">0</span><br />
res =&nbsp;<span class=\"Type\">Curl</span>::send(<span class=\"Special\">&quot;</span><span class=\"Constant\"><a href=\"https://api.github.com/gists\">https://api.github.com/gists</a></span><span class=\"Special\">&quot;</span>, req)<br />
puts&nbsp;<span class=\"Type\">JSON</span>::parse(res.body)[<span class=\"Special\">'</span><span class=\"Constant\">html_url</span><span class=\"Special\">'</span>]<br />
</blockquote>

ポストされた物がこちら。<br />

<blockquote class=\"quote\">
	<a href=\"https://gist.github.com/4342903\">We love mruby!</a>
	<br />
	<p>#!mruby if ARGV . size != 1 raise \"gist.rb [GIST_TOKEN]\" end req = HTTP : :Request . new req . metho...</p>
	<cite>https://gist.github.com/4342903</cite>
</blockquote>
<br />

<h4>そして mruby-v8</h4>

そしてそろそろ誰も得しない物が作りたくなってくる悪い病気が。<br />
<br />

<a href=\"https://github.com/mattn/mruby-v8\">https://github.com/mattn/mruby-v8</a><br />
<br />
mruby から javascript が呼べ、そしてその javascript から mruby が呼べる！<br />

<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
v8 =&nbsp;<span class=\"Type\">V8</span>.new<br />
puts v8.eval(<span class=\"Special\">'</span><span class=\"Constant\">1+2</span><span class=\"Special\">'</span>)<br />
<br />
v8.add_func(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus</span><span class=\"Special\">&quot;</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">lhs</span>,<span class=\"Identifier\">rhs</span>|<br />
&nbsp;&nbsp;lhs + rhs<br />
<span class=\"Statement\">end</span><br />
<br />
puts v8.eval(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus(2,3)</span><span class=\"Special\">&quot;</span>)<br />
</blockquote>

すばらしいですね！<del>便利って言え</del><br />
<br />
<h4>まとめ</h4>

mruby 面白いよ！みんなも mrbgems 作って遊びましょう！<br />
<br />
<b>追記</b><br />

@matsumotory さんがちゃくちゃくと mruby 内臓ウォシュレット計画をすすめている。<br />

<blockquote class=\"quote\">
	<a href=\"http://blog.matsumoto-r.jp/?p=3168\">人間とウェブの未来 - mruby-zabbixとmruby-growthforecastでデバイスやアプリケーションの監視並びに情報の可視化を実現</a>
	<br />
	<cite>http://blog.matsumoto-r.jp/?p=3168</cite>
</blockquote>
<br />
<div class=\"awsxom\">
<a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/B00AIL6H9O/ref=nosim/?tag=bigsky-22\">
<img src=\"http://ecx.images-amazon.com/images/I/51nV2V1oTjL._SL160_.jpg\" alt=\"今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby\" class=\"awsxom-image\" />
<strong>今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby</strong></a><br />
<br />
(株)アイ・エル・シー / ￥ 17,640 ()<br />
&nbsp;<br />
発送可能時間：通常1～2営業日以内に発送<br />
<br class=\"clearall\" />
</div>

") (author nil "mattn.jp@gmail.com (mattn)")) (item nil (title nil "Go言語をWeb上で楽しめる Go Playground で SL 動かしてみた。") (pubDate nil "Thu, 13 Dec 2012 17:54:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/go/20121213175242.htm") (category nil "go") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/go/20121213175242.htm") (description nil "
Go Playground で time パッケージが有効になった。

<blockquote class=\"quote\">
	<a href=\"https://play.golang.org\">Go Playground</a>
	<br />
	<p>The Go Playground is a web service that runs on golang.org 's servers. The serv...</p>
	<cite>https://play.golang.org</cite>
</blockquote>

公式発表

<blockquote class=\"quote\">
	<a href=\"https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion\">Time - Google Groups</a>
	<br />
	<cite>https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion</cite>
</blockquote>

<code>\\x0c</code> というコードを <code>fmt.Print()</code> で出力するとクリアされ、<code>fmt.Print()</code> や <code>fmt.Println()</code> を使って文字列を出力、<code>time.Sleep</code> を使ってアニメーション表示が出来る様になります。<br />
こういうの出来たら、これを試さない訳にはいかない！！！<br />

<blockquote class=\"quote\">
	<a href=\"http://play.golang.org/p/NOycgN2i6b\">Go Playground</a>
	<br />
	<cite>http://play.golang.org/p/NOycgN2i6b</cite>
</blockquote>

<blockquote>
<img src=\"http://go-gyazo.appspot.com/3ecca50f609b9094.png\" alt=\"goplayground\" />
</blockquote>

皆さんも面白いの作ってみて下さい。
") (author nil "mattn.jp@gmail.com (mattn)")) (item nil (title nil "vim script でヒアドキュメント") (pubDate nil "Thu, 13 Dec 2012 12:00:00 +0900") (link nil "http://mattn.kaoriya.net/software/vim/20121213115657.htm") (category nil "vim") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/vim/20121213115657.htm") (description nil "
vim script には perl 等で見るヒアドキュメント

<blockquote class=\"code\">
<span class=\"Statement\">print</span>&nbsp;<span class=\"Constant\">&lt;&lt;&quot;EOF&quot;</span><span class=\"Constant\">;</span><br />
<span class=\"Constant\">hello</span><br />
<span class=\"Constant\">world</span><br />
<span class=\"Constant\">EOF</span><br />
</blockquote>

これを言語レベルではサポートしていない。しかしこのヒアドキュメントも一種の言語的な縛りであって、縛りの許容範囲次第では vim script でもヒアドキュメントっぽい事は出来る。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>here_doc<span class=\"Special\">(</span>sfile, slnum<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">lines</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">readfile</span><span class=\"Special\">(</span><span class=\"Identifier\">a:sfile</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span>lines[<span class=\"Identifier\">a:slnum</span><span class=\"Statement\">+</span><span class=\"Constant\">1</span>&nbsp;:<span class=\"Normal\">index</span><span class=\"Special\">(</span>lines,&nbsp;<span class=\"Constant\">'endif'</span><span class=\"Special\">)</span><span class=\"Statement\">-</span><span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span><br />
<span class=\"Statement\">endfunction</span><br />
<span class=\"Statement\">command</span>!&nbsp;<span class=\"Statement\">-</span><span class=\"PreProc\">nargs</span><span class=\"Statement\">=</span><span class=\"Type\">1</span>&nbsp;HereIf0&nbsp;execute&nbsp;<span class=\"Identifier\">printf</span>(<span class=\"Constant\">'let %s = s:here_doc(expand(&quot;&lt;sfile&gt;&quot;), expand(&quot;&lt;slnum&gt;&quot;))'</span>,&nbsp;<span class=\"Special\">&lt;</span><span class=\"Special\">q-args</span><span class=\"Special\">&gt;</span>)<br />
</blockquote>

<code>HereIf0</code> というコマンドを定義し

<blockquote class=\"code\">
<span class=\"Statement\">scriptencoding</span>&nbsp;utf<span class=\"Statement\">-</span><span class=\"Constant\">8</span><br />
<br />
HereIf0&nbsp;foo<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Constant\">0</span><br />
はろー<br />
わーるど<br />
<span class=\"Statement\">endif</span><br />
<br />
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">foo</span><br />
</blockquote>

この様に実行すると foo という変数に <code>if 0</code> から <code>endif</code> までが入る。<code>HereIf0</code> から <code>if 0</code> までに行を入れてはならないし、<code>endif</code> を省略して書いたり後続コメントを書いてはいけない。あとファイルのエンコーディングが utf-8 決めうちになる。<br />
まぁこれも縛りと思えば納得出来る。(縛りすぎ)<br />
<br />
ちなみに perl の __DATA__ セクションっぽいのは、随分昔にやってた。<br />

<a href=\"http://mattn.kaoriya.net/software/vim/20080317150503.htm\">http://mattn.kaoriya.net/software/vim/20080317150503.htm</a><br />
<a href=\"http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579\">http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579</a><br />
") (author nil "mattn.jp@gmail.com (mattn)")) (item nil (title nil "Go言語で出来た grep、jvgrep の高速化") (pubDate nil "Tue, 04 Dec 2012 18:18:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/go/20121204180747.htm") (category nil "jvgrep") (category nil "go") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/go/20121204180747.htm") (description nil "
以前、こんな記事を書いた。

<blockquote class=\"quote\">
	<a href=\"http://mattn.kaoriya.net/software/lang/go/20110819203649.htm\">Big Sky :: 日本語grepが出来るjvgrepというのを作った。</a>
	<br />
	<cite>http://mattn.kaoriya.net/software/lang/go/20110819203649.htm</cite>
</blockquote>

実は jvgrep を作った当初、処理がかなり遅かった。まぁ複数のエンコーディングを試すからしょうがないよね程度に思ってたけど、どうにか速くならないかと思い、処理の並行化を行ってパフォーマンスを向上させた。この記事はその時にやった改善策。<br />
<br />
jvgrep は <code>-R</code> オプションや <code>**/*</code> で再帰検索する機能が付いているんだけど、これを行う場合

<ul>
	<li>find</li>
	<li>grep</li>
</ul>

という処理が走る事になる。
しかしながら結果の順番を守ろうと考えた場合、find と grep を安直に同時に走らせる訳にはいかなくなる。走らせると結果が交錯してしまうからだ。<br />
こういうのを行う場合、C言語だとFIFOキューとスレッドを作り、find 側が push、grep 側が pop を行う仕組みを作る。<br />
しかしながらメモリの増加を管理したり、grep 側が空きになった時に待機する処理ってのを考えると、C言語だと結構めんどくさかったりする。<br />
<br />
Go言語はこのあたりが非常に簡単に実装出来る様になっている。<br />
<br />
まず find 部と grep 部の処理を分割し、grep 部を FIFO キューに対して連続で呼び出せる様にする。

<blockquote class=\"code\">
<span class=\"Statement\">func</span>&nbsp;GoGrep(ch&nbsp;<span class=\"Type\">chan</span>&nbsp;*GrepArg, done&nbsp;<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg := &lt;-ch<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;arg ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">break</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grep(arg)<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;done &lt;-&nbsp;<span class=\"Constant\">1</span><br />
}<br />
</blockquote>

Grep が本体だが今回の話の本質ではないので省略。引数の ch に Grep が使う引数が飛び込んで来る。全ての grep 対象が完了するか途中終了する場合には find 側から nil を渡すというお約束にした。<br />
メインコントローラ側で、この FIFO となるチャネルを作る。

<blockquote class=\"code\">
ch :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;*GrepArg)<br />
done :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>)<br />
</blockquote>

なぜ二つチャネルを作っているかというと、find 側が先に終了してしまった場合にプログラムが終了しない様、待機する為で、上記の GoGrep の最後に 1 を渡している。
チャネルを作ったら GoGrep をバックグラウンドで起動する。

<blockquote class=\"code\">
<span class=\"Statement\">go</span>&nbsp;GoGrep(ch, done)<br />
</blockquote>

Go言語は関数呼び出しに <code>go</code> を付けるだけで非同期に実行してくれる。<br />
次に find 部。Go言語の filepath パッケージにはファイルが見つかる度にコールバック関数を呼び出してくれる Walk がある。<br />

<blockquote class=\"code\">
filepath.Walk(root,&nbsp;<span class=\"Type\">func</span>(path&nbsp;<span class=\"Type\">string</span>, info os.FileInfo, err&nbsp;<span class=\"Type\">error</span>)&nbsp;<span class=\"Type\">error</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;err<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 以下 path に対する処理を行う。</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;path = filepath.ToSlash(path)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象外のパスにマッチする場合</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;ere !=&nbsp;<span class=\"Statement\">nil</span>&nbsp;&amp;&amp; ere.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ディレクトリならば SkipDir を返して他のフォルダに移る</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info.IsDir() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;filepath.SkipDir<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ファイルならば以下の処理は行わない</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Statement\">nil</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ... 省略 ...</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象のファイルならば</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fre.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// GoGrep が待っているチャネルにパラメータを渡す</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch &lt;- &amp;GrepArg{pattern, path,&nbsp;<span class=\"Comment\">/* ... 省略 ... */</span>}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
})<br />
</blockquote>

検索対象のファイルが見つかった場合、先ほど作成した ch に Grep 引数を渡している。<br />
find 側は全てのファイルを検索し終えたら grep 側に処理の終了を伝える。

<blockquote class=\"code\">
ch &lt;-&nbsp;<span class=\"Statement\">nil</span><br />
</blockquote>

そして grep の終了(done)を待つ。

<blockquote class=\"code\">
&lt;-done<br />
</blockquote>

図解すると

<blockquote>
<img src=\"http://go-gyazo.appspot.com/e8352b2edd3896f8.png\" alt=\"jvgrep\" />
</blockquote>

こんなイメージになる。find もフォルダを再帰的に検索すると結構重くなるので各処理を並行実行させる事でかなりのパフォーマンス向上が得られた。<br />
<br />
最初から find 部と grep 部が関数分けされていれば、もっと簡単に並行処理の実装が出来た事になる。
") (author nil "mattn.jp@gmail.com (mattn)")) (item nil (title nil "モテる Vim 使いに読み書き出来ないファイルなどなかったんだよ！") (pubDate nil "Tue, 04 Dec 2012 09:10:00 +0900") (link nil "http://mattn.kaoriya.net/software/vim/20121204090702.htm") (category nil "vim") (category nil "metarw") (category nil "gdrive") (category nil "googledrive") (category nil "webapi-vim") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/vim/20121204090702.htm") (description nil "
Vim Advent Calendar 2012 の 4 日目の記事です。<br />
<br />
<img src=\"http://go-gyazo.appspot.com/808546f74c2dffd9.png\" alt=\"!!!\" class=\"thumbnail-right\" />
<ul>
<li>「<em>やった！コンプガチャで Vim 出た！</em>」</li>
<li>「<em>だって前の彼氏、Vim 使いじゃなかったんだもん</em>」<li>「<em>マクドナルド店員「ご一緒に Vim など如何ですか？」</em>」</li>
</ul>
こんな言葉が聞かれる様になって随分と経ちました(要出典)。<br />
<br />
昨今、Vim はテキストエディタの枠を超え、アプリケーションプラットフォームへと変わりつつあります。<br />
<br />
vital.vim 等を使う事で簡単にアプリケーションを作る事も出来る様になりました。手前味噌ではありますが webapi-vim の一部も vital.vim に取り込まれています。<br />
このブログでも結構取り上げていますが webapi-vim とは一体何か。名前の通り、Web Application Programming Intreface を扱えるライブラリです。<br class=\"clearall\" />

<h2>webapi-vim とは</h2>

webapi-vim を使えば例えばこんな事が出来ます。<br />
<br />
<h4>HTTP で GET</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://example.com\">http://example.com</a>&quot;</span><span class=\"Special\">)</span><br />
</blockquote>

res には以下の様な構造が返ります。

<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;header&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Type: text/html&quot;,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Length: 310&quot;<br />
&nbsp;&nbsp;],<br />
&nbsp;&nbsp;&quot;content&quot;:&nbsp;<span class=\"String\">&quot;&lt;html&gt; .....&quot;</span><br />
}<br />
</blockquote>

header にはヘッダの配列、content には受信したデータが戻ります。<br />
引数にはパラメータを渡せます。<br />

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>

<h4>HTTP で POST</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#post<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>

GET とほぼ同じインタフェースです。GET も同様ですが、第三引数 header を指定出来ます。<br />

<h4>XML のパース</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#xml#parse<span class=\"Special\">(</span><span class=\"String\">'&lt;vim&gt;&lt;vimer id=&quot;1&quot;&gt;bram&lt;/vimmer&gt;&lt;/vim&gt;'</span><span class=\"Special\">)</span><br />
</blockquote>

DOM オブジェクトが返ります。以下の様な構造になっています。<br />

<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vim&quot;</span>,<br />
&nbsp;&nbsp;&quot;attr&quot;: {},<br />
&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vimmer&quot;</span>,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attr&quot;: {&nbsp;<span class=\"String\">&quot;id&quot;</span>: 1 },<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;bram&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;]<br />
}<br />
</blockquote>

dom からは以下の様に探索出来ます。<br />

<blockquote class=\"code\">
dom.childNode(\"vimmer\")
</blockquote>

これで子ノードのうち vimmer ノードが1つだけ返ります。

<blockquote class=\"code\">
dom.childNode(\"vimmer\", {\"id\": 1})
</blockquote>

vimmer ノードのうち id 属性が 1 の物が1つだけ返ります。

<blockquote class=\"code\">
dom.childNodes(\"vimmer\", {\"id\": 1})
</blockquote>

vimmer ノードで id 属性が 1 の物が全て返ります。childNode/childNodes は子ノードだけですが、再帰的に検索する場合 find/findAll を使います。

<blockquote class=\"code\">
node.value()
</blockquote>

ノードをテキスト化します。上記で得た bram が入った vimmer ノードで value() を実行すると \"bram\" という文字列が得られます。<br />

<blockquote class=\"code\">
node.toString()
</blockquote>

ノードをXML化します。なお、属性はノードに対して attr というフィールドからディクショナリで参照出来ます。

<blockquote class=\"code\">
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">node</span>.<span class=\"Identifier\">attr</span>[<span class=\"String\">&quot;id&quot;</span>]<br />
</blockquote>

<h4>HTML のパース</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#html#parse<span class=\"Special\">(...)</span><br />
</blockquote>

扱い方は XML と同じです。<br />

<h4>JSON のエンコード/デコード</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">obj</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#decode<span class=\"Special\">(</span>json<span class=\"Special\">)</span><br />
</blockquote>

vim の値として扱えます。逆に

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">json</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#encode<span class=\"Special\">(</span>obj<span class=\"Special\">)</span><br />
</blockquote>

でエンコード出来ます。

webapi-vim にはこれ以外にも XMLRPC/JSONRPC/SOAP といったRPC、MD5/SHA1 といったハッシュ関数、OAuth もあります。詳しくはドキュメントを見て頂くか、サンプルや webaip-vim を使ったプロダクトのソースコードを参照して下さい。<br />

<h2>metarw とは</h2>

さて、いまごろ本題<br />
昨今のモテる Vim 使いはどんな物に対しても vim から読み書きを行います(要出典)。その代表例として vim-metarw という物もあります。

<blockquote class=\"quote\">
	<a href=\"https://github.com/kana/vim-metarw\">kana/vim-metarw - GitHub</a>
	<br />
	<p>Vim plugin: A framework to read/write fake:path</p>
	<cite>https://github.com/kana/vim-metarw</cite>
</blockquote>

これは kana さんが作ったフレームワークで、metarw 自身は vim からメタ情報を読み書きする土台のみを提供します。各 metarw プラグインは metarw のルールに従って実装コードを入れる事で vim と親和性の高いファイルの読み書きが出来るという物です。例えば vim-metarw-gist という物があります。

<blockquote class=\"quote\">
	<a href=\"https://github.com/emonkak/vim-metarw-gist\">emonkak/vim-metarw-gist ﾂｷ GitHub</a>
	<br />
	<p>Vim plugin: metarw scheme for gist</p>
	<cite>https://github.com/emonkak/vim-metarw-gist</cite>
</blockquote>

これを使うと <code>:e gist:</code> で vim が持っているファイルエクスプローラと同じ見栄えで自分の gist 一覧が表示され、エンターを押すと gist のファイルが開かれ、<code>:w</code> で書き込めます。
なお Windows で metarw を使う場合には私の fork を使って下さい。

<blockquote class=\"quote\">
	<a href=\"https://github.com/mattn/vim-metarw\">mattn/vim-metarw - GitHub</a>
	<br />
	<cite>https://github.com/mattn/vim-metarw</cite>
</blockquote>

ここで metarw プラグインについて説明しましょう。<br />
vim-metarw プラグインを作る場合はまずプラグインフォルダを用意し、<code>autoload/metarw/プラグイン名.vim</code> というファイルを作ります。<br />
vim-metarw プラグインを満たす為には以下の実装を含んでいる必要があります。

<blockquote class=\"code\">
metarw#gdrive#read(fakepath)<br />
metarw#gdrive#write(fakepath, line1, line2, append_p)<br />
metarw#gdrive#complete(arglead, cmdline, cursorpos)<br />
</blockquote>

まず read を説明します。metarw プラグインは fakepath で指定されたパスがディレクトリかどうかを判断し、ディレクトリであれば

<blockquote class=\"code\">
['browse', [<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ふー&quot;, &quot;fakepath&quot;: &quot;xxx:/foo&quot;},<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ばー&quot;, &quot;fakepath&quot;: &quot;xxx:/bar&quot;}<br />
]]<br />
</blockquote>

browse という結果と共にパス情報を返します。エラーが発生した場合には

<blockquote class=\"code\">
['error', 'エラーメッセージ']<br />
</blockquote>

を返します。ファイルであった場合には、既に metarw が用意したバッファにコンテンツを貼り付け、必要であれば filetype も変更して

<blockquote class=\"code\">
['done', '']<br />
</blockquote>

という結果を返します。write も同様に、fakepath で指定されたパスに対して現在のバッファの line1 行から line2 行のコンテンツを書き込みます。append_p の場合は追記になります。<br />
最後に complete は vim の補完と同じ仕組みになります。実際には、read の際にファイル一覧を作った結果の fakepath 部分を返せば良い事になります。<br />
<br />
ここまで来れば誰でも metarw プラグインを作れる様になります。<br />
<br />
<h2>vim-metarw-gdrive でハードウェア境界を越えろ</h2>

<img src=\"http://go-gyazo.appspot.com/7ae8b32993cf4b88.png\" alt=\"!!!\" class=\"thumbnail-left\" />
上記で説明した webapi-vim と、この vim-metarw を使い、<a href=\"https://drive.google.com/\">Google Drive</a> のファイルを読み書き出来る物を作ってみましょう。<br />
<br />
<blockquote>
なっ！？なんだってーーー！
</blockquote>
<br class=\"clearall\" />
まずは read で指定されたパスから属性情報を取り出す部分を作ります。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>parse_incomplete_fakepath<span class=\"Special\">(</span>incomplete_fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Special\">{}</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">fragments</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span>,&nbsp;<span class=\"Constant\">'^\\l\\+\\zs:'</span>, !<span class=\"Constant\">0</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span>fragments<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">&lt;=</span>&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>given_fakepath&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:incomplete_fakepath</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>scheme&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">0</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'^[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'root'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span>fragments[<span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">'[\\/]'</span><span class=\"Special\">)</span>[<span class=\"Statement\">-</span><span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;_<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

<a href=\"https://developers.google.com/drive/\">Google Drive SDK</a> の API リファレンスによると、Google Drive の API では各ファイルにパスでアクセスする事は出来ません。パスから特定のコンテンツを得たり保存を行う場合には、ノードIDに対して割り当てられた名称を取得し、例えば <code>/foo/bar/baz.txt</code> というパスのコンテンツを得る場合、実は bar というフォルダのIDだけ分かれば書き込める事になります。ただしラベルは同じノード内においても重複し得ます。なのでパス <code>/foo/bar/baz.txt</code> という情報から目的の <code>baz.txt</code> のコンテンツを得るには

<ul>
	<li>\"root\" ノード直下のファイル一覧を調べ、ディレクトリかつラベルが foo の最初の物を探す</li>
	<li>foo 直下のファイル一覧を調べ、ディレクトリかつラベルが bar の最初の物を探す</li>
	<li>bar 直下のファイル一覧を調べ、ファイルかつラベルが baz.txt の最初の物を探す</li>
	<li>baz.txt のコンテンツをダウンロードする</li>
</ul>

こいうめんどくさい手順を取る必要があります。たかがファイルを読みたいだけに4回 API アクセスが必要になります。どう考えてもおかし過ぎるし使っててイライラするだろうから、このプラグインで扱うパス情報は ID で行う事とし、ファイルブラウザで実際のファイル名からアクセスしてもらう事とします。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>! metarw#gdrive#read<span class=\"Special\">(</span>fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_list</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_content</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

まずは先ほど作った parse_incomplete_fakepath に従い、ファイル一覧を読むのかファイルのコンテンツを読むのかを切り分けます。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_list<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;[]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files\">https://www.googleapis.com/drive/v2/files</a>'</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'q'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">&quot;'%s' in parents&quot;</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span><span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;item&nbsp;<span class=\"Statement\">in</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>items<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>labels<span class=\"Statement\">.</span>trashed&nbsp;<span class=\"Statement\">!=</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">continue</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>title<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>id<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>mimeType&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">'application/vnd.google-apps.folder'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'/'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">add</span><span class=\"Special\">(</span>result,&nbsp;<span class=\"Special\">{</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'label'</span>: title,<br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'fakepath'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">'%s:%s'</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>scheme, file<span class=\"Special\">)</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endfor</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'browse'</span>,&nbsp;result]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

Google Drive API を使って、ノードID に属するファイルの一覧を取得しています。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_content<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files/\">https://www.googleapis.com/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;!<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'downloadUrl'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Constant\">'This file seems impossible to edit in vim!'</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">resp</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span>res<span class=\"Statement\">.</span>downloadUrl,&nbsp;<span class=\"Constant\">''</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]&nbsp;<span class=\"Statement\">!~</span>&nbsp;<span class=\"Constant\">'200'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;resp<span class=\"Statement\">.</span>content<br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">setline</span><span class=\"Special\">(</span><span class=\"Constant\">2</span>,&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">iconv</span><span class=\"Special\">(</span>content,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">))</span><br />
<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">ext</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'.'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>fileExtension<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>s:extmap, ext<span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;&amp;<span class=\"Statement\">filetype</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;s:extmap[ext]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

ノードIDからコンテンツをダウンロードしています。ファイル名に拡張子がついていないので、拡張子からファイルタイプを決定する為にローカルにテーブルを保持しました。<br />
ここで metarw を使う際の注意点があります。metarw の read 関数実装は <code>:r! ...</code> といった外部ファイルを読み込む事を想定しており、vim のデフォルト動作と同様に先頭行に空行が入れる必要があります。この空行は metarw 本体側で削除されるので、metarw プラグイン側が空白行を入れる必要があります。<br />
<br />
write も同様に API から行います。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>write_content<span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">post</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/upload/drive/v2/files/\">https://www.googleapis.com/upload/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Identifier\">a:content</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'Content-Type'</span>:&nbsp;<span class=\"Constant\">'application/octet-stream'</span><span class=\"Special\">}</span>,&nbsp;<span class=\"Constant\">'PUT'</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
<br />
<span class=\"Statement\">function</span>! metarw#gdrive#write<span class=\"Special\">(</span>fakepath, line1, line2, append_p<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span><span class=\"Identifier\">getline</span><span class=\"Special\">(</span><span class=\"Identifier\">a:line1</span>,&nbsp;<span class=\"Identifier\">a:line2</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>, &amp;encoding,&nbsp;<span class=\"Constant\">'utf-8'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:write_content</span><span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

このプラグインは Google Drive に oauth2 で認証を行っています。初めて使う際には

<blockquote class=\"code\">
:GdriveSetup
</blockquote>

を実行し、ブラウザで表示されたコードを vim の <code>CODE:</code> 部にコピペして頂く必要があります。<br />
Google Drive の API、というか最近の Google の API は認証情報に揮発性があり、リフレッシュトークンという物を使って有効期限が切れたアクセストークンを再生成する必要があります。上記のコードには含まれませんがリポジトリでは401による再認証が行われます。<br />
それでもエラーが出る場合は、お手数ですが再度

<blockquote class=\"code\">
:GdriveSetup
</blockquote>

を実行して認証を行って下さい。<br />
ソースを github に置いてあります。興味のある方は覗いてみて下さい。<br />

<blockquote class=\"quote\">
	<a href=\"https://github.com/mattn/vim-metarw-gdrive\">mattn/vim-metarw-gdrive ﾂｷ GitHub</a>
	<br />
	<cite>https://github.com/mattn/vim-metarw-gdrive</cite>
</blockquote>

全て webapi-vim もそうですが vim スクリプトだけで組まれています。(ただしネットワーク通信部分だけは curl もしくは wget を使っています)<br />
<br />
さて実際に使ってみましょう。上記の認証を終わらせた後 <code>:e gdrive:</code> を実行します。<br />
<blockquote>
<img src=\"http://go-gyazo.appspot.com/d6b57a1bfc4d80d6.png\" alt=\"vim-metarw-gdrive1\" />
</blockquote>

ファイル一覧が表示されました。<br />
なんと都合よく「helloworld.cxx」なんてファイルがあるではありませんか！！！<br />
エンターキーを押します。<br />
<br />

<blockquote>
<img src=\"http://go-gyazo.appspot.com/2ca01104e579a845.png\" alt=\"vim-metarw-gdrive2\" />
</blockquote>

おぉぉ...<br />
<br />
もちろん <code>:w</code> で保存する事も出来ますし、quickrun から直で実行する事も出来ます。<br />
ファイルを作成する場合は、ファイルブラウザに表示されるパスを使って「:w gdrive:/XXXXXXXX/foo.txt」と実行して下さい。現在のバッファが指定のフォルダにアップロードされます。この場合、バッファは既にテンポラリに過ぎないので更新したい場合はファイルブラウザから開きなおして下さい。<br />
<br />
<h2>まとめ</h2>

まとめると...
<blockquote>
<em>モテる Vimmer に読み書き出来ないファイルなど無かったんだよ！！</em>
</blockquote>
ってことです。<br />
<br />
<b>追記</b><br />
モテる度合いには個人差がございます。<br />
") (author nil "mattn.jp@gmail.com (mattn)")))) ("最近の mruby 業界まとめ" "トピックス
<ul>
<li>mrbgems が入った</li>
<li>お前はどこのワカメじゃ</li>
<li>ビルド方法が変わった</li>
<li>mruby-uv mruby-http mruby-sinatic</li>
<li>mruby-json</li>
<li>mruby-sqlite3</li>
<li>mruby-curl</li>
<li>そして mruby-v8</li>
</ul>
<h4>mrbgems が入った</h4>
mruby に GEM っぽい物が入った。<br />
とは言ってもスタティックリンクなのでダイナミックローディングしてくれる訳じゃない。<br />
しかしながらパッケージを導入する上での取り決めが決まりつつあると言った感じ。<br />
使うには <code>MRUBY_ROOT</code> という環境変数を mruby のリポジトリトップに設定しておき、<code>MAKEFILE_4_GEM</code> を <code>$MRUBY/mrbgems/Makefiel4gem</code>
にしておくと良い。後者は要らなくなったかもしれない。<br />
具体的には
<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/GEMS.active
</blockquote>
というファイルに使う mrbgems のフォルダを一覧しておくとビルドの際に一緒にビルドおよびリンクしてくれるという物。<br />
<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/g
</blockquote>
の下に置く場合は絶対パスではなくフォルダ名だけで良い。<br />
mrbgems には大きく2つあって、C言語で書く拡張と、ruby 形式で書く物がある。後者はビルド時にバイナリ化されてリンクされる。<br />
C言語で書く際のお手本としては <a href=\"https://github.com/mattn/mruby-md5\">mruby-md5</a> が良いと思う。<br />
<br />
<h4>お前はどこのワカメじゃ</h4>
mrbgems は bovi という人がパッチ書いて取り込まれたのだけど、既存の拡張をどうやって mrbgems 化するか聞いてたら「やってあげる」という神キタコレな運びとなって mruby-md5 を mrbgems 化して貰えた。その時の出来事が彼のブログに載っているのだが
<blockquote class=\"quote\">
<a href=\"http://mruby.sh/201212101231.html\">mrbgems in HEAD - mruby.sh</a>
<br />
<cite>http://mruby.sh/201212101231.html</cite>
</blockquote>
<blockquote class=\"code\">
assert(<span class=\"Special\">'</span><span class=\"Constant\">MD5 Hash for old example</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span><br />
&nbsp;&nbsp;<span class=\"Type\">MD5</span>::md5_hex(<span class=\"Special\">'</span><span class=\"Constant\">お前はどこのワカメじゃ</span><span class=\"Special\">'</span>) ==&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">43820f48a8506c8e2fae6f8558971920</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
</blockquote>
まさか誰も僕のソースなんか見ないだろうと思って書いてたコードを使ってテストにしてくれました。恥ずかしい...<br />
<br />
<h4>ビルド方法が変わった</h4>
ここ最近の大きな変更。<br />
これまでは Makefile もしくは cmake でビルドしていたけど、CRuby と minirake というスクリプトを使ってビルドする仕組みが入りました。現在のルートにある Makefile はこれを呼び出しているだけです。<br />
<br />
<h4>mruby-uv mruby-http mruby-sinatic</h4>
以前から作ってましたが、Matz さんにアドバイスを貰って安定動作する様になりました。<br />
<br />
<a href=\"https://github.com/mattn/mruby-uv\">https://github.com/mattn/mruby-uv</a><br />
<a href=\"https://github.com/mattn/mruby-http\">https://github.com/mattn/mruby-http</a><br />
<a href=\"https://github.com/mattn/mruby-sinatic\">https://github.com/mattn/mruby-sinatic</a><br />
<br />
Windows のしょぼいマシンでもちょっとしたHTTPサーバ(example/server.rb)で 4000 req/sec は出ます。<br />
mruby-sinatic は<a href=\"http://mattn.kaoriya.net/software/lang/ruby/20120509211817.htm\">コレ</a>を mrbgems 化した物です。<br />
<br />
<h4>mruby-json</h4>
以前から JSON パーサが欲しかったので自分で書きました。<br />
<br />
<a href=\"https://github.com/mattn/mruby-json\">https://github.com/mattn/mruby-json</a><br />
<br />
内部では <a href=\"http://mattn.kaoriya.net/software/lang/c/20121102175736.htm\">parson</a> を使ってます。<br />
2時間程度で作った物で<a href=\"http://togetter.com/li/424919\">メモリ開放漏れてました</a>が...<br />
<br />
<h4>mruby-sqlite3</h4>
こちらも自分で...<br />
<br />
<a href=\"https://github.com/mattn/mruby-sqlite3\">https://github.com/mattn/mruby-sqlite3</a><br />
<br />
<blockquote class=\"code\">
db =&nbsp;<span class=\"Type\">SQLite3</span>::<span class=\"Type\">Database</span>.new(<span class=\"Special\">'</span><span class=\"Constant\">foo.db</span><span class=\"Special\">'</span>)<br />
db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from foo</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">row</span>,&nbsp;<span class=\"Identifier\">fields</span>|<br />
&nbsp;&nbsp;puts row<br />
<span class=\"Statement\">end</span><br />
<br />
row = db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from bar</span><span class=\"Special\">'</span>)<br />
puts row.fields()<br />
<span class=\"Statement\">while</span>&nbsp;!row.eof?<br />
&nbsp;&nbsp;puts row.next()<br />
<span class=\"Statement\">end</span><br />
row.close()<br />
</blockquote>
こんな風に使います。<br />
<br />
<h4>mruby-curl</h4>
proxy 超えられて SSL も使える HTTP クライアントが欲しかったので書いた。<br />
<br />
<a href=\"https://github.com/mattn/mruby-curl\">https://github.com/mattn/mruby-curl</a><br />
<br />
個人的にはかなり便利になった思う。<br />
HTTP::Response を返すので mruby-http が必要。<br />
mruby-json と mruby-curl を使って Gist をポストしてみました。
<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">ARGV</span>.size !=&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;<span class=\"Statement\">raise</span>&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">gist.rb [GIST_TOKEN]</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
<br />
req =&nbsp;<span class=\"Type\">HTTP</span>::<span class=\"Type\">Request</span>.new<br />
req.method =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">POST</span><span class=\"Special\">&quot;</span><br />
req.body =&nbsp;<span class=\"Type\">JSON</span>::stringify({<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">description</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">We love mruby!</span><span class=\"Special\">&quot;</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">public</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Constant\">true</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">files</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">file1.txt</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">content</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">mruby is awesome!</span><span class=\"Special\">&quot;</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
})<br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Authorization</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">token&nbsp;</span><span class=\"Special\">#{</span><span class=\"Identifier\">ARGV</span>[<span class=\"Constant\">0</span>]<span class=\"Special\">}</span><span class=\"Special\">&quot;</span><br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Content-Type</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">application/json</span><span class=\"Special\">&quot;</span><br />
<span class=\"Type\">Curl</span>::<span class=\"Type\">SSL_VERIFYPEER</span>&nbsp;=&nbsp;<span class=\"Constant\">0</span><br />
res =&nbsp;<span class=\"Type\">Curl</span>::send(<span class=\"Special\">&quot;</span><span class=\"Constant\"><a href=\"https://api.github.com/gists\">https://api.github.com/gists</a></span><span class=\"Special\">&quot;</span>, req)<br />
puts&nbsp;<span class=\"Type\">JSON</span>::parse(res.body)[<span class=\"Special\">'</span><span class=\"Constant\">html_url</span><span class=\"Special\">'</span>]<br />
</blockquote>
ポストされた物がこちら。<br />
<blockquote class=\"quote\">
<a href=\"https://gist.github.com/4342903\">We love mruby!</a>
<br />
<p>#!mruby if ARGV . size != 1 raise \"gist.rb [GIST_TOKEN]\" end req = HTTP : :Request . new req . metho...</p>
<cite>https://gist.github.com/4342903</cite>
</blockquote>
<br />
<h4>そして mruby-v8</h4>
そしてそろそろ誰も得しない物が作りたくなってくる悪い病気が。<br />
<br />
<a href=\"https://github.com/mattn/mruby-v8\">https://github.com/mattn/mruby-v8</a><br />
<br />
mruby から javascript が呼べ、そしてその javascript から mruby が呼べる！<br />
<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
v8 =&nbsp;<span class=\"Type\">V8</span>.new<br />
puts v8.eval(<span class=\"Special\">'</span><span class=\"Constant\">1+2</span><span class=\"Special\">'</span>)<br />
<br />
v8.add_func(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus</span><span class=\"Special\">&quot;</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">lhs</span>,<span class=\"Identifier\">rhs</span>|<br />
&nbsp;&nbsp;lhs + rhs<br />
<span class=\"Statement\">end</span><br />
<br />
puts v8.eval(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus(2,3)</span><span class=\"Special\">&quot;</span>)<br />
</blockquote>
すばらしいですね！<del>便利って言え</del><br />
<br />
<h4>まとめ</h4>
mruby 面白いよ！みんなも mrbgems 作って遊びましょう！<br />
<br />
<b>追記</b><br />
@matsumotory さんがちゃくちゃくと mruby 内臓ウォシュレット計画をすすめている。<br />
<blockquote class=\"quote\">
<a href=\"http://blog.matsumoto-r.jp/?p=3168\">人間とウェブの未来 - mruby-zabbixとmruby-growthforecastでデバイスやアプリケーションの監視並びに情報の可視化を実現</a>
<br />
<cite>http://blog.matsumoto-r.jp/?p=3168</cite>
</blockquote>
<br />
<div class=\"awsxom\">
<a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/B00AIL6H9O/ref=nosim/?tag=bigsky-22\">
<img src=\"http://ecx.images-amazon.com/images/I/51nV2V1oTjL._SL160_.jpg\" alt=\"今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby\" class=\"awsxom-image\" />
<strong>今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby</strong></a><br />
<br />
(株)アイ・エル・シー / ￥ 17,640 ()<br />
&nbsp;<br />
発送可能時間：通常1～2営業日以内に発送<br />
<br class=\"clearall\" />
</div>" "http://mattn.kaoriya.net/software/lang/ruby/20121221135228.htm" (20691 60204) new 1 nil nil ((title nil "最近の mruby 業界まとめ") (pubDate nil "Fri, 21 Dec 2012 13:53:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/ruby/20121221135228.htm") (category nil "mruby") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/ruby/20121221135228.htm") (description nil "
トピックス

<ul>
	<li>mrbgems が入った</li>
	<li>お前はどこのワカメじゃ</li>
	<li>ビルド方法が変わった</li>
	<li>mruby-uv mruby-http mruby-sinatic</li>
	<li>mruby-json</li>
	<li>mruby-sqlite3</li>
	<li>mruby-curl</li>
	<li>そして mruby-v8</li>
</ul>

<h4>mrbgems が入った</h4>

mruby に GEM っぽい物が入った。<br />
とは言ってもスタティックリンクなのでダイナミックローディングしてくれる訳じゃない。<br />
しかしながらパッケージを導入する上での取り決めが決まりつつあると言った感じ。<br />
使うには <code>MRUBY_ROOT</code> という環境変数を mruby のリポジトリトップに設定しておき、<code>MAKEFILE_4_GEM</code> を <code>$MRUBY/mrbgems/Makefiel4gem</code>
にしておくと良い。後者は要らなくなったかもしれない。<br />
具体的には

<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/GEMS.active
</blockquote>

というファイルに使う mrbgems のフォルダを一覧しておくとビルドの際に一緒にビルドおよびリンクしてくれるという物。<br />

<blockquote class=\"code\">
$MRUBY_ROOT/mrbgems/g
</blockquote>

の下に置く場合は絶対パスではなくフォルダ名だけで良い。<br />

mrbgems には大きく2つあって、C言語で書く拡張と、ruby 形式で書く物がある。後者はビルド時にバイナリ化されてリンクされる。<br />
C言語で書く際のお手本としては <a href=\"https://github.com/mattn/mruby-md5\">mruby-md5</a> が良いと思う。<br />
<br />

<h4>お前はどこのワカメじゃ</h4>

mrbgems は bovi という人がパッチ書いて取り込まれたのだけど、既存の拡張をどうやって mrbgems 化するか聞いてたら「やってあげる」という神キタコレな運びとなって mruby-md5 を mrbgems 化して貰えた。その時の出来事が彼のブログに載っているのだが

<blockquote class=\"quote\">
	<a href=\"http://mruby.sh/201212101231.html\">mrbgems in HEAD - mruby.sh</a>
	<br />
	<cite>http://mruby.sh/201212101231.html</cite>
</blockquote>

<blockquote class=\"code\">
assert(<span class=\"Special\">'</span><span class=\"Constant\">MD5 Hash for old example</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span><br />
&nbsp;&nbsp;<span class=\"Type\">MD5</span>::md5_hex(<span class=\"Special\">'</span><span class=\"Constant\">お前はどこのワカメじゃ</span><span class=\"Special\">'</span>) ==&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">43820f48a8506c8e2fae6f8558971920</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
</blockquote>

まさか誰も僕のソースなんか見ないだろうと思って書いてたコードを使ってテストにしてくれました。恥ずかしい...<br />
<br />

<h4>ビルド方法が変わった</h4>

ここ最近の大きな変更。<br />
これまでは Makefile もしくは cmake でビルドしていたけど、CRuby と minirake というスクリプトを使ってビルドする仕組みが入りました。現在のルートにある Makefile はこれを呼び出しているだけです。<br />
<br />

<h4>mruby-uv mruby-http mruby-sinatic</h4>

以前から作ってましたが、Matz さんにアドバイスを貰って安定動作する様になりました。<br />
<br />

<a href=\"https://github.com/mattn/mruby-uv\">https://github.com/mattn/mruby-uv</a><br />
<a href=\"https://github.com/mattn/mruby-http\">https://github.com/mattn/mruby-http</a><br />
<a href=\"https://github.com/mattn/mruby-sinatic\">https://github.com/mattn/mruby-sinatic</a><br />
<br />

Windows のしょぼいマシンでもちょっとしたHTTPサーバ(example/server.rb)で 4000 req/sec は出ます。<br />
mruby-sinatic は<a href=\"http://mattn.kaoriya.net/software/lang/ruby/20120509211817.htm\">コレ</a>を mrbgems 化した物です。<br />
<br />

<h4>mruby-json</h4>

以前から JSON パーサが欲しかったので自分で書きました。<br />
<br />

<a href=\"https://github.com/mattn/mruby-json\">https://github.com/mattn/mruby-json</a><br />
<br />
内部では <a href=\"http://mattn.kaoriya.net/software/lang/c/20121102175736.htm\">parson</a> を使ってます。<br />
2時間程度で作った物で<a href=\"http://togetter.com/li/424919\">メモリ開放漏れてました</a>が...<br />
<br />

<h4>mruby-sqlite3</h4>

こちらも自分で...<br />
<br />

<a href=\"https://github.com/mattn/mruby-sqlite3\">https://github.com/mattn/mruby-sqlite3</a><br />
<br />

<blockquote class=\"code\">
db =&nbsp;<span class=\"Type\">SQLite3</span>::<span class=\"Type\">Database</span>.new(<span class=\"Special\">'</span><span class=\"Constant\">foo.db</span><span class=\"Special\">'</span>)<br />
db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from foo</span><span class=\"Special\">'</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">row</span>,&nbsp;<span class=\"Identifier\">fields</span>|<br />
&nbsp;&nbsp;puts row<br />
<span class=\"Statement\">end</span><br />
<br />
row = db.execute(<span class=\"Special\">'</span><span class=\"Constant\">select * from bar</span><span class=\"Special\">'</span>)<br />
puts row.fields()<br />
<span class=\"Statement\">while</span>&nbsp;!row.eof?<br />
&nbsp;&nbsp;puts row.next()<br />
<span class=\"Statement\">end</span><br />
row.close()<br />
</blockquote>

こんな風に使います。<br />
<br />

<h4>mruby-curl</h4>

proxy 超えられて SSL も使える HTTP クライアントが欲しかったので書いた。<br />
<br />

<a href=\"https://github.com/mattn/mruby-curl\">https://github.com/mattn/mruby-curl</a><br />
<br />
個人的にはかなり便利になった思う。<br />
HTTP::Response を返すので mruby-http が必要。<br />
mruby-json と mruby-curl を使って Gist をポストしてみました。

<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">ARGV</span>.size !=&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;<span class=\"Statement\">raise</span>&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">gist.rb [GIST_TOKEN]</span><span class=\"Special\">&quot;</span><br />
<span class=\"Statement\">end</span><br />
<br />
req =&nbsp;<span class=\"Type\">HTTP</span>::<span class=\"Type\">Request</span>.new<br />
req.method =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">POST</span><span class=\"Special\">&quot;</span><br />
req.body =&nbsp;<span class=\"Type\">JSON</span>::stringify({<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">description</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">We love mruby!</span><span class=\"Special\">&quot;</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">public</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Constant\">true</span>,<br />
&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">files</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">file1.txt</span><span class=\"Special\">&quot;</span>=&gt; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">content</span><span class=\"Special\">&quot;</span>=&gt;&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">mruby is awesome!</span><span class=\"Special\">&quot;</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
})<br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Authorization</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">token&nbsp;</span><span class=\"Special\">#{</span><span class=\"Identifier\">ARGV</span>[<span class=\"Constant\">0</span>]<span class=\"Special\">}</span><span class=\"Special\">&quot;</span><br />
req.headers[<span class=\"Special\">'</span><span class=\"Constant\">Content-Type</span><span class=\"Special\">'</span>] =&nbsp;<span class=\"Special\">&quot;</span><span class=\"Constant\">application/json</span><span class=\"Special\">&quot;</span><br />
<span class=\"Type\">Curl</span>::<span class=\"Type\">SSL_VERIFYPEER</span>&nbsp;=&nbsp;<span class=\"Constant\">0</span><br />
res =&nbsp;<span class=\"Type\">Curl</span>::send(<span class=\"Special\">&quot;</span><span class=\"Constant\"><a href=\"https://api.github.com/gists\">https://api.github.com/gists</a></span><span class=\"Special\">&quot;</span>, req)<br />
puts&nbsp;<span class=\"Type\">JSON</span>::parse(res.body)[<span class=\"Special\">'</span><span class=\"Constant\">html_url</span><span class=\"Special\">'</span>]<br />
</blockquote>

ポストされた物がこちら。<br />

<blockquote class=\"quote\">
	<a href=\"https://gist.github.com/4342903\">We love mruby!</a>
	<br />
	<p>#!mruby if ARGV . size != 1 raise \"gist.rb [GIST_TOKEN]\" end req = HTTP : :Request . new req . metho...</p>
	<cite>https://gist.github.com/4342903</cite>
</blockquote>
<br />

<h4>そして mruby-v8</h4>

そしてそろそろ誰も得しない物が作りたくなってくる悪い病気が。<br />
<br />

<a href=\"https://github.com/mattn/mruby-v8\">https://github.com/mattn/mruby-v8</a><br />
<br />
mruby から javascript が呼べ、そしてその javascript から mruby が呼べる！<br />

<blockquote class=\"code\">
<span class=\"PreProc\">#!mruby</span><br />
<br />
v8 =&nbsp;<span class=\"Type\">V8</span>.new<br />
puts v8.eval(<span class=\"Special\">'</span><span class=\"Constant\">1+2</span><span class=\"Special\">'</span>)<br />
<br />
v8.add_func(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus</span><span class=\"Special\">&quot;</span>)&nbsp;<span class=\"Statement\">do</span>&nbsp;|<span class=\"Identifier\">lhs</span>,<span class=\"Identifier\">rhs</span>|<br />
&nbsp;&nbsp;lhs + rhs<br />
<span class=\"Statement\">end</span><br />
<br />
puts v8.eval(<span class=\"Special\">&quot;</span><span class=\"Constant\">plus(2,3)</span><span class=\"Special\">&quot;</span>)<br />
</blockquote>

すばらしいですね！<del>便利って言え</del><br />
<br />
<h4>まとめ</h4>

mruby 面白いよ！みんなも mrbgems 作って遊びましょう！<br />
<br />
<b>追記</b><br />

@matsumotory さんがちゃくちゃくと mruby 内臓ウォシュレット計画をすすめている。<br />

<blockquote class=\"quote\">
	<a href=\"http://blog.matsumoto-r.jp/?p=3168\">人間とウェブの未来 - mruby-zabbixとmruby-growthforecastでデバイスやアプリケーションの監視並びに情報の可視化を実現</a>
	<br />
	<cite>http://blog.matsumoto-r.jp/?p=3168</cite>
</blockquote>
<br />
<div class=\"awsxom\">
<a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/B00AIL6H9O/ref=nosim/?tag=bigsky-22\">
<img src=\"http://ecx.images-amazon.com/images/I/51nV2V1oTjL._SL160_.jpg\" alt=\"今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby\" class=\"awsxom-image\" />
<strong>今日から使える！ 液晶マイコンボード付きmruby学習キット EAPL-Trainer mruby</strong></a><br />
<br />
(株)アイ・エル・シー / ￥ 17,640 ()<br />
&nbsp;<br />
発送可能時間：通常1～2営業日以内に発送<br />
<br class=\"clearall\" />
</div>

") (author nil "mattn.jp@gmail.com (mattn)"))) ("Go言語をWeb上で楽しめる Go Playground で SL 動かしてみた。" "Go Playground で time パッケージが有効になった。
<blockquote class=\"quote\">
<a href=\"https://play.golang.org\">Go Playground</a>
<br />
<p>The Go Playground is a web service that runs on golang.org 's servers. The serv...</p>
<cite>https://play.golang.org</cite>
</blockquote>
公式発表
<blockquote class=\"quote\">
<a href=\"https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion\">Time - Google Groups</a>
<br />
<cite>https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion</cite>
</blockquote>
<code>\\x0c</code> というコードを <code>fmt.Print()</code> で出力するとクリアされ、<code>fmt.Print()</code> や <code>fmt.Println()</code> を使って文字列を出力、<code>time.Sleep</code> を使ってアニメーション表示が出来る様になります。<br />
こういうの出来たら、これを試さない訳にはいかない！！！<br />
<blockquote class=\"quote\">
<a href=\"http://play.golang.org/p/NOycgN2i6b\">Go Playground</a>
<br />
<cite>http://play.golang.org/p/NOycgN2i6b</cite>
</blockquote>
<blockquote>
<img src=\"http://go-gyazo.appspot.com/3ecca50f609b9094.png\" alt=\"goplayground\" />
</blockquote>
皆さんも面白いの作ってみて下さい。" "http://mattn.kaoriya.net/software/lang/go/20121213175242.htm" (20681 38824) new 2 nil nil ((title nil "Go言語をWeb上で楽しめる Go Playground で SL 動かしてみた。") (pubDate nil "Thu, 13 Dec 2012 17:54:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/go/20121213175242.htm") (category nil "go") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/go/20121213175242.htm") (description nil "
Go Playground で time パッケージが有効になった。

<blockquote class=\"quote\">
	<a href=\"https://play.golang.org\">Go Playground</a>
	<br />
	<p>The Go Playground is a web service that runs on golang.org 's servers. The serv...</p>
	<cite>https://play.golang.org</cite>
</blockquote>

公式発表

<blockquote class=\"quote\">
	<a href=\"https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion\">Time - Google Groups</a>
	<br />
	<cite>https://groups.google.com/d/topic/golang-nuts/JBsCrDEVyVE/discussion</cite>
</blockquote>

<code>\\x0c</code> というコードを <code>fmt.Print()</code> で出力するとクリアされ、<code>fmt.Print()</code> や <code>fmt.Println()</code> を使って文字列を出力、<code>time.Sleep</code> を使ってアニメーション表示が出来る様になります。<br />
こういうの出来たら、これを試さない訳にはいかない！！！<br />

<blockquote class=\"quote\">
	<a href=\"http://play.golang.org/p/NOycgN2i6b\">Go Playground</a>
	<br />
	<cite>http://play.golang.org/p/NOycgN2i6b</cite>
</blockquote>

<blockquote>
<img src=\"http://go-gyazo.appspot.com/3ecca50f609b9094.png\" alt=\"goplayground\" />
</blockquote>

皆さんも面白いの作ってみて下さい。
") (author nil "mattn.jp@gmail.com (mattn)"))) ("vim script でヒアドキュメント" "vim script には perl 等で見るヒアドキュメント
<blockquote class=\"code\">
<span class=\"Statement\">print</span>&nbsp;<span class=\"Constant\">&lt;&lt;&quot;EOF&quot;</span><span class=\"Constant\">;</span><br />
<span class=\"Constant\">hello</span><br />
<span class=\"Constant\">world</span><br />
<span class=\"Constant\">EOF</span><br />
</blockquote>
これを言語レベルではサポートしていない。しかしこのヒアドキュメントも一種の言語的な縛りであって、縛りの許容範囲次第では vim script でもヒアドキュメントっぽい事は出来る。
<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>here_doc<span class=\"Special\">(</span>sfile, slnum<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">lines</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">readfile</span><span class=\"Special\">(</span><span class=\"Identifier\">a:sfile</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span>lines[<span class=\"Identifier\">a:slnum</span><span class=\"Statement\">+</span><span class=\"Constant\">1</span>&nbsp;:<span class=\"Normal\">index</span><span class=\"Special\">(</span>lines,&nbsp;<span class=\"Constant\">'endif'</span><span class=\"Special\">)</span><span class=\"Statement\">-</span><span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span><br />
<span class=\"Statement\">endfunction</span><br />
<span class=\"Statement\">command</span>!&nbsp;<span class=\"Statement\">-</span><span class=\"PreProc\">nargs</span><span class=\"Statement\">=</span><span class=\"Type\">1</span>&nbsp;HereIf0&nbsp;execute&nbsp;<span class=\"Identifier\">printf</span>(<span class=\"Constant\">'let %s = s:here_doc(expand(&quot;&lt;sfile&gt;&quot;), expand(&quot;&lt;slnum&gt;&quot;))'</span>,&nbsp;<span class=\"Special\">&lt;</span><span class=\"Special\">q-args</span><span class=\"Special\">&gt;</span>)<br />
</blockquote>
<code>HereIf0</code> というコマンドを定義し
<blockquote class=\"code\">
<span class=\"Statement\">scriptencoding</span>&nbsp;utf<span class=\"Statement\">-</span><span class=\"Constant\">8</span><br />
<br />
HereIf0&nbsp;foo<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Constant\">0</span><br />
はろー<br />
わーるど<br />
<span class=\"Statement\">endif</span><br />
<br />
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">foo</span><br />
</blockquote>
この様に実行すると foo という変数に <code>if 0</code> から <code>endif</code> までが入る。<code>HereIf0</code> から <code>if 0</code> までに行を入れてはならないし、<code>endif</code> を省略して書いたり後続コメントを書いてはいけない。あとファイルのエンコーディングが utf-8 決めうちになる。<br />
まぁこれも縛りと思えば納得出来る。(縛りすぎ)<br />
<br />
ちなみに perl の __DATA__ セクションっぽいのは、随分昔にやってた。<br />
<a href=\"http://mattn.kaoriya.net/software/vim/20080317150503.htm\">http://mattn.kaoriya.net/software/vim/20080317150503.htm</a><br />
<a href=\"http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579\">http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579</a><br />" "http://mattn.kaoriya.net/software/vim/20121213115657.htm" (20681 17584) new 3 nil nil ((title nil "vim script でヒアドキュメント") (pubDate nil "Thu, 13 Dec 2012 12:00:00 +0900") (link nil "http://mattn.kaoriya.net/software/vim/20121213115657.htm") (category nil "vim") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/vim/20121213115657.htm") (description nil "
vim script には perl 等で見るヒアドキュメント

<blockquote class=\"code\">
<span class=\"Statement\">print</span>&nbsp;<span class=\"Constant\">&lt;&lt;&quot;EOF&quot;</span><span class=\"Constant\">;</span><br />
<span class=\"Constant\">hello</span><br />
<span class=\"Constant\">world</span><br />
<span class=\"Constant\">EOF</span><br />
</blockquote>

これを言語レベルではサポートしていない。しかしこのヒアドキュメントも一種の言語的な縛りであって、縛りの許容範囲次第では vim script でもヒアドキュメントっぽい事は出来る。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>here_doc<span class=\"Special\">(</span>sfile, slnum<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">lines</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">readfile</span><span class=\"Special\">(</span><span class=\"Identifier\">a:sfile</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span>lines[<span class=\"Identifier\">a:slnum</span><span class=\"Statement\">+</span><span class=\"Constant\">1</span>&nbsp;:<span class=\"Normal\">index</span><span class=\"Special\">(</span>lines,&nbsp;<span class=\"Constant\">'endif'</span><span class=\"Special\">)</span><span class=\"Statement\">-</span><span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span><br />
<span class=\"Statement\">endfunction</span><br />
<span class=\"Statement\">command</span>!&nbsp;<span class=\"Statement\">-</span><span class=\"PreProc\">nargs</span><span class=\"Statement\">=</span><span class=\"Type\">1</span>&nbsp;HereIf0&nbsp;execute&nbsp;<span class=\"Identifier\">printf</span>(<span class=\"Constant\">'let %s = s:here_doc(expand(&quot;&lt;sfile&gt;&quot;), expand(&quot;&lt;slnum&gt;&quot;))'</span>,&nbsp;<span class=\"Special\">&lt;</span><span class=\"Special\">q-args</span><span class=\"Special\">&gt;</span>)<br />
</blockquote>

<code>HereIf0</code> というコマンドを定義し

<blockquote class=\"code\">
<span class=\"Statement\">scriptencoding</span>&nbsp;utf<span class=\"Statement\">-</span><span class=\"Constant\">8</span><br />
<br />
HereIf0&nbsp;foo<br />
<span class=\"Statement\">if</span>&nbsp;<span class=\"Constant\">0</span><br />
はろー<br />
わーるど<br />
<span class=\"Statement\">endif</span><br />
<br />
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">foo</span><br />
</blockquote>

この様に実行すると foo という変数に <code>if 0</code> から <code>endif</code> までが入る。<code>HereIf0</code> から <code>if 0</code> までに行を入れてはならないし、<code>endif</code> を省略して書いたり後続コメントを書いてはいけない。あとファイルのエンコーディングが utf-8 決めうちになる。<br />
まぁこれも縛りと思えば納得出来る。(縛りすぎ)<br />
<br />
ちなみに perl の __DATA__ セクションっぽいのは、随分昔にやってた。<br />

<a href=\"http://mattn.kaoriya.net/software/vim/20080317150503.htm\">http://mattn.kaoriya.net/software/vim/20080317150503.htm</a><br />
<a href=\"http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579\">http://subtech.g.hatena.ne.jp/motemen/20080324/1206337579</a><br />
") (author nil "mattn.jp@gmail.com (mattn)"))) ("Go言語で出来た grep、jvgrep の高速化" "以前、こんな記事を書いた。
<blockquote class=\"quote\">
<a href=\"http://mattn.kaoriya.net/software/lang/go/20110819203649.htm\">Big Sky :: 日本語grepが出来るjvgrepというのを作った。</a>
<br />
<cite>http://mattn.kaoriya.net/software/lang/go/20110819203649.htm</cite>
</blockquote>
実は jvgrep を作った当初、処理がかなり遅かった。まぁ複数のエンコーディングを試すからしょうがないよね程度に思ってたけど、どうにか速くならないかと思い、処理の並行化を行ってパフォーマンスを向上させた。この記事はその時にやった改善策。<br />
<br />
jvgrep は <code>-R</code> オプションや <code>**/*</code> で再帰検索する機能が付いているんだけど、これを行う場合
<ul>
<li>find</li>
<li>grep</li>
</ul>
という処理が走る事になる。
しかしながら結果の順番を守ろうと考えた場合、find と grep を安直に同時に走らせる訳にはいかなくなる。走らせると結果が交錯してしまうからだ。<br />
こういうのを行う場合、C言語だとFIFOキューとスレッドを作り、find 側が push、grep 側が pop を行う仕組みを作る。<br />
しかしながらメモリの増加を管理したり、grep 側が空きになった時に待機する処理ってのを考えると、C言語だと結構めんどくさかったりする。<br />
<br />
Go言語はこのあたりが非常に簡単に実装出来る様になっている。<br />
<br />
まず find 部と grep 部の処理を分割し、grep 部を FIFO キューに対して連続で呼び出せる様にする。
<blockquote class=\"code\">
<span class=\"Statement\">func</span>&nbsp;GoGrep(ch&nbsp;<span class=\"Type\">chan</span>&nbsp;*GrepArg, done&nbsp;<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg := &lt;-ch<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;arg ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">break</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grep(arg)<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;done &lt;-&nbsp;<span class=\"Constant\">1</span><br />
}<br />
</blockquote>
Grep が本体だが今回の話の本質ではないので省略。引数の ch に Grep が使う引数が飛び込んで来る。全ての grep 対象が完了するか途中終了する場合には find 側から nil を渡すというお約束にした。<br />
メインコントローラ側で、この FIFO となるチャネルを作る。
<blockquote class=\"code\">
ch :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;*GrepArg)<br />
done :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>)<br />
</blockquote>
なぜ二つチャネルを作っているかというと、find 側が先に終了してしまった場合にプログラムが終了しない様、待機する為で、上記の GoGrep の最後に 1 を渡している。
チャネルを作ったら GoGrep をバックグラウンドで起動する。
<blockquote class=\"code\">
<span class=\"Statement\">go</span>&nbsp;GoGrep(ch, done)<br />
</blockquote>
Go言語は関数呼び出しに <code>go</code> を付けるだけで非同期に実行してくれる。<br />
次に find 部。Go言語の filepath パッケージにはファイルが見つかる度にコールバック関数を呼び出してくれる Walk がある。<br />
<blockquote class=\"code\">
filepath.Walk(root,&nbsp;<span class=\"Type\">func</span>(path&nbsp;<span class=\"Type\">string</span>, info os.FileInfo, err&nbsp;<span class=\"Type\">error</span>)&nbsp;<span class=\"Type\">error</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;err<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 以下 path に対する処理を行う。</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;path = filepath.ToSlash(path)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象外のパスにマッチする場合</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;ere !=&nbsp;<span class=\"Statement\">nil</span>&nbsp;&amp;&amp; ere.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ディレクトリならば SkipDir を返して他のフォルダに移る</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info.IsDir() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;filepath.SkipDir<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ファイルならば以下の処理は行わない</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Statement\">nil</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ... 省略 ...</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象のファイルならば</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fre.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// GoGrep が待っているチャネルにパラメータを渡す</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch &lt;- &amp;GrepArg{pattern, path,&nbsp;<span class=\"Comment\">/* ... 省略 ... */</span>}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
})<br />
</blockquote>
検索対象のファイルが見つかった場合、先ほど作成した ch に Grep 引数を渡している。<br />
find 側は全てのファイルを検索し終えたら grep 側に処理の終了を伝える。
<blockquote class=\"code\">
ch &lt;-&nbsp;<span class=\"Statement\">nil</span><br />
</blockquote>
そして grep の終了(done)を待つ。
<blockquote class=\"code\">
&lt;-done<br />
</blockquote>
図解すると
<blockquote>
<img src=\"http://go-gyazo.appspot.com/e8352b2edd3896f8.png\" alt=\"jvgrep\" />
</blockquote>
こんなイメージになる。find もフォルダを再帰的に検索すると結構重くなるので各処理を並行実行させる事でかなりのパフォーマンス向上が得られた。<br />
<br />
最初から find 部と grep 部が関数分けされていれば、もっと簡単に並行処理の実装が出来た事になる。" "http://mattn.kaoriya.net/software/lang/go/20121204180747.htm" (20669 49096) new 4 nil nil ((title nil "Go言語で出来た grep、jvgrep の高速化") (pubDate nil "Tue, 04 Dec 2012 18:18:00 +0900") (link nil "http://mattn.kaoriya.net/software/lang/go/20121204180747.htm") (category nil "jvgrep") (category nil "go") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/lang/go/20121204180747.htm") (description nil "
以前、こんな記事を書いた。

<blockquote class=\"quote\">
	<a href=\"http://mattn.kaoriya.net/software/lang/go/20110819203649.htm\">Big Sky :: 日本語grepが出来るjvgrepというのを作った。</a>
	<br />
	<cite>http://mattn.kaoriya.net/software/lang/go/20110819203649.htm</cite>
</blockquote>

実は jvgrep を作った当初、処理がかなり遅かった。まぁ複数のエンコーディングを試すからしょうがないよね程度に思ってたけど、どうにか速くならないかと思い、処理の並行化を行ってパフォーマンスを向上させた。この記事はその時にやった改善策。<br />
<br />
jvgrep は <code>-R</code> オプションや <code>**/*</code> で再帰検索する機能が付いているんだけど、これを行う場合

<ul>
	<li>find</li>
	<li>grep</li>
</ul>

という処理が走る事になる。
しかしながら結果の順番を守ろうと考えた場合、find と grep を安直に同時に走らせる訳にはいかなくなる。走らせると結果が交錯してしまうからだ。<br />
こういうのを行う場合、C言語だとFIFOキューとスレッドを作り、find 側が push、grep 側が pop を行う仕組みを作る。<br />
しかしながらメモリの増加を管理したり、grep 側が空きになった時に待機する処理ってのを考えると、C言語だと結構めんどくさかったりする。<br />
<br />
Go言語はこのあたりが非常に簡単に実装出来る様になっている。<br />
<br />
まず find 部と grep 部の処理を分割し、grep 部を FIFO キューに対して連続で呼び出せる様にする。

<blockquote class=\"code\">
<span class=\"Statement\">func</span>&nbsp;GoGrep(ch&nbsp;<span class=\"Type\">chan</span>&nbsp;*GrepArg, done&nbsp;<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg := &lt;-ch<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;arg ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">break</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grep(arg)<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;done &lt;-&nbsp;<span class=\"Constant\">1</span><br />
}<br />
</blockquote>

Grep が本体だが今回の話の本質ではないので省略。引数の ch に Grep が使う引数が飛び込んで来る。全ての grep 対象が完了するか途中終了する場合には find 側から nil を渡すというお約束にした。<br />
メインコントローラ側で、この FIFO となるチャネルを作る。

<blockquote class=\"code\">
ch :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;*GrepArg)<br />
done :=&nbsp;<span class=\"Statement\">make</span>(<span class=\"Type\">chan</span>&nbsp;<span class=\"Type\">int</span>)<br />
</blockquote>

なぜ二つチャネルを作っているかというと、find 側が先に終了してしまった場合にプログラムが終了しない様、待機する為で、上記の GoGrep の最後に 1 を渡している。
チャネルを作ったら GoGrep をバックグラウンドで起動する。

<blockquote class=\"code\">
<span class=\"Statement\">go</span>&nbsp;GoGrep(ch, done)<br />
</blockquote>

Go言語は関数呼び出しに <code>go</code> を付けるだけで非同期に実行してくれる。<br />
次に find 部。Go言語の filepath パッケージにはファイルが見つかる度にコールバック関数を呼び出してくれる Walk がある。<br />

<blockquote class=\"code\">
filepath.Walk(root,&nbsp;<span class=\"Type\">func</span>(path&nbsp;<span class=\"Type\">string</span>, info os.FileInfo, err&nbsp;<span class=\"Type\">error</span>)&nbsp;<span class=\"Type\">error</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info ==&nbsp;<span class=\"Statement\">nil</span>&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;err<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 以下 path に対する処理を行う。</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;path = filepath.ToSlash(path)<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象外のパスにマッチする場合</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;ere !=&nbsp;<span class=\"Statement\">nil</span>&nbsp;&amp;&amp; ere.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ディレクトリならば SkipDir を返して他のフォルダに移る</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;info.IsDir() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;filepath.SkipDir<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ファイルならば以下の処理は行わない</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;<span class=\"Statement\">nil</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// ... 省略 ...</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// 検索対象のファイルならば</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fre.MatchString(path) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Comment\">// GoGrep が待っているチャネルにパラメータを渡す</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch &lt;- &amp;GrepArg{pattern, path,&nbsp;<span class=\"Comment\">/* ... 省略 ... */</span>}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
})<br />
</blockquote>

検索対象のファイルが見つかった場合、先ほど作成した ch に Grep 引数を渡している。<br />
find 側は全てのファイルを検索し終えたら grep 側に処理の終了を伝える。

<blockquote class=\"code\">
ch &lt;-&nbsp;<span class=\"Statement\">nil</span><br />
</blockquote>

そして grep の終了(done)を待つ。

<blockquote class=\"code\">
&lt;-done<br />
</blockquote>

図解すると

<blockquote>
<img src=\"http://go-gyazo.appspot.com/e8352b2edd3896f8.png\" alt=\"jvgrep\" />
</blockquote>

こんなイメージになる。find もフォルダを再帰的に検索すると結構重くなるので各処理を並行実行させる事でかなりのパフォーマンス向上が得られた。<br />
<br />
最初から find 部と grep 部が関数分けされていれば、もっと簡単に並行処理の実装が出来た事になる。
") (author nil "mattn.jp@gmail.com (mattn)"))) ("モテる Vim 使いに読み書き出来ないファイルなどなかったんだよ！" "Vim Advent Calendar 2012 の 4 日目の記事です。<br />
<br />
<img src=\"http://go-gyazo.appspot.com/808546f74c2dffd9.png\" alt=\"!!!\" class=\"thumbnail-right\" />
<ul>
<li>「<em>やった！コンプガチャで Vim 出た！</em>」</li>
<li>「<em>だって前の彼氏、Vim 使いじゃなかったんだもん</em>」<li>「<em>マクドナルド店員「ご一緒に Vim など如何ですか？」</em>」</li>
</ul>
こんな言葉が聞かれる様になって随分と経ちました(要出典)。<br />
<br />
昨今、Vim はテキストエディタの枠を超え、アプリケーションプラットフォームへと変わりつつあります。<br />
<br />
vital.vim 等を使う事で簡単にアプリケーションを作る事も出来る様になりました。手前味噌ではありますが webapi-vim の一部も vital.vim に取り込まれています。<br />
このブログでも結構取り上げていますが webapi-vim とは一体何か。名前の通り、Web Application Programming Intreface を扱えるライブラリです。<br class=\"clearall\" />
<h2>webapi-vim とは</h2>
webapi-vim を使えば例えばこんな事が出来ます。<br />
<br />
<h4>HTTP で GET</h4>
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://example.com\">http://example.com</a>&quot;</span><span class=\"Special\">)</span><br />
</blockquote>
res には以下の様な構造が返ります。
<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;header&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Type: text/html&quot;,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Length: 310&quot;<br />
&nbsp;&nbsp;],<br />
&nbsp;&nbsp;&quot;content&quot;:&nbsp;<span class=\"String\">&quot;&lt;html&gt; .....&quot;</span><br />
}<br />
</blockquote>
header にはヘッダの配列、content には受信したデータが戻ります。<br />
引数にはパラメータを渡せます。<br />
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>
<h4>HTTP で POST</h4>
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#post<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>
GET とほぼ同じインタフェースです。GET も同様ですが、第三引数 header を指定出来ます。<br />
<h4>XML のパース</h4>
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#xml#parse<span class=\"Special\">(</span><span class=\"String\">'&lt;vim&gt;&lt;vimer id=&quot;1&quot;&gt;bram&lt;/vimmer&gt;&lt;/vim&gt;'</span><span class=\"Special\">)</span><br />
</blockquote>
DOM オブジェクトが返ります。以下の様な構造になっています。<br />
<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vim&quot;</span>,<br />
&nbsp;&nbsp;&quot;attr&quot;: {},<br />
&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vimmer&quot;</span>,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attr&quot;: {&nbsp;<span class=\"String\">&quot;id&quot;</span>: 1 },<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;bram&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;]<br />
}<br />
</blockquote>
dom からは以下の様に探索出来ます。<br />
<blockquote class=\"code\">
dom.childNode(\"vimmer\")
</blockquote>
これで子ノードのうち vimmer ノードが1つだけ返ります。
<blockquote class=\"code\">
dom.childNode(\"vimmer\", {\"id\": 1})
</blockquote>
vimmer ノードのうち id 属性が 1 の物が1つだけ返ります。
<blockquote class=\"code\">
dom.childNodes(\"vimmer\", {\"id\": 1})
</blockquote>
vimmer ノードで id 属性が 1 の物が全て返ります。childNode/childNodes は子ノードだけですが、再帰的に検索する場合 find/findAll を使います。
<blockquote class=\"code\">
node.value()
</blockquote>
ノードをテキスト化します。上記で得た bram が入った vimmer ノードで value() を実行すると \"bram\" という文字列が得られます。<br />
<blockquote class=\"code\">
node.toString()
</blockquote>
ノードをXML化します。なお、属性はノードに対して attr というフィールドからディクショナリで参照出来ます。
<blockquote class=\"code\">
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">node</span>.<span class=\"Identifier\">attr</span>[<span class=\"String\">&quot;id&quot;</span>]<br />
</blockquote>
<h4>HTML のパース</h4>
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#html#parse<span class=\"Special\">(...)</span><br />
</blockquote>
扱い方は XML と同じです。<br />
<h4>JSON のエンコード/デコード</h4>
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">obj</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#decode<span class=\"Special\">(</span>json<span class=\"Special\">)</span><br />
</blockquote>
vim の値として扱えます。逆に
<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">json</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#encode<span class=\"Special\">(</span>obj<span class=\"Special\">)</span><br />
</blockquote>
でエンコード出来ます。
webapi-vim にはこれ以外にも XMLRPC/JSONRPC/SOAP といったRPC、MD5/SHA1 といったハッシュ関数、OAuth もあります。詳しくはドキュメントを見て頂くか、サンプルや webaip-vim を使ったプロダクトのソースコードを参照して下さい。<br />
<h2>metarw とは</h2>
さて、いまごろ本題<br />
昨今のモテる Vim 使いはどんな物に対しても vim から読み書きを行います(要出典)。その代表例として vim-metarw という物もあります。
<blockquote class=\"quote\">
<a href=\"https://github.com/kana/vim-metarw\">kana/vim-metarw - GitHub</a>
<br />
<p>Vim plugin: A framework to read/write fake:path</p>
<cite>https://github.com/kana/vim-metarw</cite>
</blockquote>
これは kana さんが作ったフレームワークで、metarw 自身は vim からメタ情報を読み書きする土台のみを提供します。各 metarw プラグインは metarw のルールに従って実装コードを入れる事で vim と親和性の高いファイルの読み書きが出来るという物です。例えば vim-metarw-gist という物があります。
<blockquote class=\"quote\">
<a href=\"https://github.com/emonkak/vim-metarw-gist\">emonkak/vim-metarw-gist ﾂｷ GitHub</a>
<br />
<p>Vim plugin: metarw scheme for gist</p>
<cite>https://github.com/emonkak/vim-metarw-gist</cite>
</blockquote>
これを使うと <code>:e gist:</code> で vim が持っているファイルエクスプローラと同じ見栄えで自分の gist 一覧が表示され、エンターを押すと gist のファイルが開かれ、<code>:w</code> で書き込めます。
なお Windows で metarw を使う場合には私の fork を使って下さい。
<blockquote class=\"quote\">
<a href=\"https://github.com/mattn/vim-metarw\">mattn/vim-metarw - GitHub</a>
<br />
<cite>https://github.com/mattn/vim-metarw</cite>
</blockquote>
ここで metarw プラグインについて説明しましょう。<br />
vim-metarw プラグインを作る場合はまずプラグインフォルダを用意し、<code>autoload/metarw/プラグイン名.vim</code> というファイルを作ります。<br />
vim-metarw プラグインを満たす為には以下の実装を含んでいる必要があります。
<blockquote class=\"code\">
metarw#gdrive#read(fakepath)<br />
metarw#gdrive#write(fakepath, line1, line2, append_p)<br />
metarw#gdrive#complete(arglead, cmdline, cursorpos)<br />
</blockquote>
まず read を説明します。metarw プラグインは fakepath で指定されたパスがディレクトリかどうかを判断し、ディレクトリであれば
<blockquote class=\"code\">
['browse', [<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ふー&quot;, &quot;fakepath&quot;: &quot;xxx:/foo&quot;},<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ばー&quot;, &quot;fakepath&quot;: &quot;xxx:/bar&quot;}<br />
]]<br />
</blockquote>
browse という結果と共にパス情報を返します。エラーが発生した場合には
<blockquote class=\"code\">
['error', 'エラーメッセージ']<br />
</blockquote>
を返します。ファイルであった場合には、既に metarw が用意したバッファにコンテンツを貼り付け、必要であれば filetype も変更して
<blockquote class=\"code\">
['done', '']<br />
</blockquote>
という結果を返します。write も同様に、fakepath で指定されたパスに対して現在のバッファの line1 行から line2 行のコンテンツを書き込みます。append_p の場合は追記になります。<br />
最後に complete は vim の補完と同じ仕組みになります。実際には、read の際にファイル一覧を作った結果の fakepath 部分を返せば良い事になります。<br />
<br />
ここまで来れば誰でも metarw プラグインを作れる様になります。<br />
<br />
<h2>vim-metarw-gdrive でハードウェア境界を越えろ</h2>
<img src=\"http://go-gyazo.appspot.com/7ae8b32993cf4b88.png\" alt=\"!!!\" class=\"thumbnail-left\" />
上記で説明した webapi-vim と、この vim-metarw を使い、<a href=\"https://drive.google.com/\">Google Drive</a> のファイルを読み書き出来る物を作ってみましょう。<br />
<br />
<blockquote>
なっ！？なんだってーーー！
</blockquote>
<br class=\"clearall\" />
まずは read で指定されたパスから属性情報を取り出す部分を作ります。
<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>parse_incomplete_fakepath<span class=\"Special\">(</span>incomplete_fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Special\">{}</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">fragments</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span>,&nbsp;<span class=\"Constant\">'^\\l\\+\\zs:'</span>, !<span class=\"Constant\">0</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span>fragments<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">&lt;=</span>&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>given_fakepath&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:incomplete_fakepath</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>scheme&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">0</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'^[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'root'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span>fragments[<span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">'[\\/]'</span><span class=\"Special\">)</span>[<span class=\"Statement\">-</span><span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;_<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>
<a href=\"https://developers.google.com/drive/\">Google Drive SDK</a> の API リファレンスによると、Google Drive の API では各ファイルにパスでアクセスする事は出来ません。パスから特定のコンテンツを得たり保存を行う場合には、ノードIDに対して割り当てられた名称を取得し、例えば <code>/foo/bar/baz.txt</code> というパスのコンテンツを得る場合、実は bar というフォルダのIDだけ分かれば書き込める事になります。ただしラベルは同じノード内においても重複し得ます。なのでパス <code>/foo/bar/baz.txt</code> という情報から目的の <code>baz.txt</code> のコンテンツを得るには
<ul>
<li>\"root\" ノード直下のファイル一覧を調べ、ディレクトリかつラベルが foo の最初の物を探す</li>
<li>foo 直下のファイル一覧を調べ、ディレクトリかつラベルが bar の最初の物を探す</li>
<li>bar 直下のファイル一覧を調べ、ファイルかつラベルが baz.txt の最初の物を探す</li>
<li>baz.txt のコンテンツをダウンロードする</li>
</ul>
こいうめんどくさい手順を取る必要があります。たかがファイルを読みたいだけに4回 API アクセスが必要になります。どう考えてもおかし過ぎるし使っててイライラするだろうから、このプラグインで扱うパス情報は ID で行う事とし、ファイルブラウザで実際のファイル名からアクセスしてもらう事とします。<br />
<blockquote class=\"code\">
<span class=\"Statement\">function</span>! metarw#gdrive#read<span class=\"Special\">(</span>fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_list</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_content</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>
まずは先ほど作った parse_incomplete_fakepath に従い、ファイル一覧を読むのかファイルのコンテンツを読むのかを切り分けます。<br />
<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_list<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;[]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files\">https://www.googleapis.com/drive/v2/files</a>'</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'q'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">&quot;'%s' in parents&quot;</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span><span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;item&nbsp;<span class=\"Statement\">in</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>items<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>labels<span class=\"Statement\">.</span>trashed&nbsp;<span class=\"Statement\">!=</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">continue</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>title<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>id<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>mimeType&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">'application/vnd.google-apps.folder'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'/'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">add</span><span class=\"Special\">(</span>result,&nbsp;<span class=\"Special\">{</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'label'</span>: title,<br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'fakepath'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">'%s:%s'</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>scheme, file<span class=\"Special\">)</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endfor</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'browse'</span>,&nbsp;result]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>
Google Drive API を使って、ノードID に属するファイルの一覧を取得しています。<br />
<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_content<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files/\">https://www.googleapis.com/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;!<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'downloadUrl'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Constant\">'This file seems impossible to edit in vim!'</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">resp</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span>res<span class=\"Statement\">.</span>downloadUrl,&nbsp;<span class=\"Constant\">''</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]&nbsp;<span class=\"Statement\">!~</span>&nbsp;<span class=\"Constant\">'200'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;resp<span class=\"Statement\">.</span>content<br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">setline</span><span class=\"Special\">(</span><span class=\"Constant\">2</span>,&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">iconv</span><span class=\"Special\">(</span>content,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">))</span><br />
<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">ext</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'.'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>fileExtension<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>s:extmap, ext<span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;&amp;<span class=\"Statement\">filetype</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;s:extmap[ext]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>
ノードIDからコンテンツをダウンロードしています。ファイル名に拡張子がついていないので、拡張子からファイルタイプを決定する為にローカルにテーブルを保持しました。<br />
ここで metarw を使う際の注意点があります。metarw の read 関数実装は <code>:r! ...</code> といった外部ファイルを読み込む事を想定しており、vim のデフォルト動作と同様に先頭行に空行が入れる必要があります。この空行は metarw 本体側で削除されるので、metarw プラグイン側が空白行を入れる必要があります。<br />
<br />
write も同様に API から行います。
<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>write_content<span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">post</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/upload/drive/v2/files/\">https://www.googleapis.com/upload/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Identifier\">a:content</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'Content-Type'</span>:&nbsp;<span class=\"Constant\">'application/octet-stream'</span><span class=\"Special\">}</span>,&nbsp;<span class=\"Constant\">'PUT'</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
<br />
<span class=\"Statement\">function</span>! metarw#gdrive#write<span class=\"Special\">(</span>fakepath, line1, line2, append_p<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span><span class=\"Identifier\">getline</span><span class=\"Special\">(</span><span class=\"Identifier\">a:line1</span>,&nbsp;<span class=\"Identifier\">a:line2</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>, &amp;encoding,&nbsp;<span class=\"Constant\">'utf-8'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:write_content</span><span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>
このプラグインは Google Drive に oauth2 で認証を行っています。初めて使う際には
<blockquote class=\"code\">
:GdriveSetup
</blockquote>
を実行し、ブラウザで表示されたコードを vim の <code>CODE:</code> 部にコピペして頂く必要があります。<br />
Google Drive の API、というか最近の Google の API は認証情報に揮発性があり、リフレッシュトークンという物を使って有効期限が切れたアクセストークンを再生成する必要があります。上記のコードには含まれませんがリポジトリでは401による再認証が行われます。<br />
それでもエラーが出る場合は、お手数ですが再度
<blockquote class=\"code\">
:GdriveSetup
</blockquote>
を実行して認証を行って下さい。<br />
ソースを github に置いてあります。興味のある方は覗いてみて下さい。<br />
<blockquote class=\"quote\">
<a href=\"https://github.com/mattn/vim-metarw-gdrive\">mattn/vim-metarw-gdrive ﾂｷ GitHub</a>
<br />
<cite>https://github.com/mattn/vim-metarw-gdrive</cite>
</blockquote>
全て webapi-vim もそうですが vim スクリプトだけで組まれています。(ただしネットワーク通信部分だけは curl もしくは wget を使っています)<br />
<br />
さて実際に使ってみましょう。上記の認証を終わらせた後 <code>:e gdrive:</code> を実行します。<br />
<blockquote>
<img src=\"http://go-gyazo.appspot.com/d6b57a1bfc4d80d6.png\" alt=\"vim-metarw-gdrive1\" />
</blockquote>
ファイル一覧が表示されました。<br />
なんと都合よく「helloworld.cxx」なんてファイルがあるではありませんか！！！<br />
エンターキーを押します。<br />
<br />
<blockquote>
<img src=\"http://go-gyazo.appspot.com/2ca01104e579a845.png\" alt=\"vim-metarw-gdrive2\" />
</blockquote>
おぉぉ...<br />
<br />
もちろん <code>:w</code> で保存する事も出来ますし、quickrun から直で実行する事も出来ます。<br />
ファイルを作成する場合は、ファイルブラウザに表示されるパスを使って「:w gdrive:/XXXXXXXX/foo.txt」と実行して下さい。現在のバッファが指定のフォルダにアップロードされます。この場合、バッファは既にテンポラリに過ぎないので更新したい場合はファイルブラウザから開きなおして下さい。<br />
<br />
<h2>まとめ</h2>
まとめると...
<blockquote>
<em>モテる Vimmer に読み書き出来ないファイルなど無かったんだよ！！</em>
</blockquote>
ってことです。<br />
<br />
<b>追記</b><br />
モテる度合いには個人差がございます。<br />" "http://mattn.kaoriya.net/software/vim/20121204090702.htm" (20669 16216) new 5 nil nil ((title nil "モテる Vim 使いに読み書き出来ないファイルなどなかったんだよ！") (pubDate nil "Tue, 04 Dec 2012 09:10:00 +0900") (link nil "http://mattn.kaoriya.net/software/vim/20121204090702.htm") (category nil "vim") (category nil "metarw") (category nil "gdrive") (category nil "googledrive") (category nil "webapi-vim") (guid ((isPermaLink . "true")) "http://mattn.kaoriya.net/software/vim/20121204090702.htm") (description nil "
Vim Advent Calendar 2012 の 4 日目の記事です。<br />
<br />
<img src=\"http://go-gyazo.appspot.com/808546f74c2dffd9.png\" alt=\"!!!\" class=\"thumbnail-right\" />
<ul>
<li>「<em>やった！コンプガチャで Vim 出た！</em>」</li>
<li>「<em>だって前の彼氏、Vim 使いじゃなかったんだもん</em>」<li>「<em>マクドナルド店員「ご一緒に Vim など如何ですか？」</em>」</li>
</ul>
こんな言葉が聞かれる様になって随分と経ちました(要出典)。<br />
<br />
昨今、Vim はテキストエディタの枠を超え、アプリケーションプラットフォームへと変わりつつあります。<br />
<br />
vital.vim 等を使う事で簡単にアプリケーションを作る事も出来る様になりました。手前味噌ではありますが webapi-vim の一部も vital.vim に取り込まれています。<br />
このブログでも結構取り上げていますが webapi-vim とは一体何か。名前の通り、Web Application Programming Intreface を扱えるライブラリです。<br class=\"clearall\" />

<h2>webapi-vim とは</h2>

webapi-vim を使えば例えばこんな事が出来ます。<br />
<br />
<h4>HTTP で GET</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://example.com\">http://example.com</a>&quot;</span><span class=\"Special\">)</span><br />
</blockquote>

res には以下の様な構造が返ります。

<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;header&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Type: text/html&quot;,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Content-Length: 310&quot;<br />
&nbsp;&nbsp;],<br />
&nbsp;&nbsp;&quot;content&quot;:&nbsp;<span class=\"String\">&quot;&lt;html&gt; .....&quot;</span><br />
}<br />
</blockquote>

header にはヘッダの配列、content には受信したデータが戻ります。<br />
引数にはパラメータを渡せます。<br />

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#get<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>

<h4>HTTP で POST</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#http#post<span class=\"Special\">(</span><span class=\"String\">&quot;<a href=\"http://google.com\">http://google.com</a>&quot;</span>,&nbsp;<span class=\"Special\">{</span>&nbsp;<span class=\"String\">&quot;q&quot;</span>:&nbsp;<span class=\"String\">&quot;vim&quot;</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
</blockquote>

GET とほぼ同じインタフェースです。GET も同様ですが、第三引数 header を指定出来ます。<br />

<h4>XML のパース</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#xml#parse<span class=\"Special\">(</span><span class=\"String\">'&lt;vim&gt;&lt;vimer id=&quot;1&quot;&gt;bram&lt;/vimmer&gt;&lt;/vim&gt;'</span><span class=\"Special\">)</span><br />
</blockquote>

DOM オブジェクトが返ります。以下の様な構造になっています。<br />

<blockquote class=\"code\">
{<br />
&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vim&quot;</span>,<br />
&nbsp;&nbsp;&quot;attr&quot;: {},<br />
&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&nbsp;<span class=\"String\">&quot;vimmer&quot;</span>,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;attr&quot;: {&nbsp;<span class=\"String\">&quot;id&quot;</span>: 1 },<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;child&quot;: [<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;bram&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;]<br />
}<br />
</blockquote>

dom からは以下の様に探索出来ます。<br />

<blockquote class=\"code\">
dom.childNode(\"vimmer\")
</blockquote>

これで子ノードのうち vimmer ノードが1つだけ返ります。

<blockquote class=\"code\">
dom.childNode(\"vimmer\", {\"id\": 1})
</blockquote>

vimmer ノードのうち id 属性が 1 の物が1つだけ返ります。

<blockquote class=\"code\">
dom.childNodes(\"vimmer\", {\"id\": 1})
</blockquote>

vimmer ノードで id 属性が 1 の物が全て返ります。childNode/childNodes は子ノードだけですが、再帰的に検索する場合 find/findAll を使います。

<blockquote class=\"code\">
node.value()
</blockquote>

ノードをテキスト化します。上記で得た bram が入った vimmer ノードで value() を実行すると \"bram\" という文字列が得られます。<br />

<blockquote class=\"code\">
node.toString()
</blockquote>

ノードをXML化します。なお、属性はノードに対して attr というフィールドからディクショナリで参照出来ます。

<blockquote class=\"code\">
<span class=\"Statement\">echo</span>&nbsp;<span class=\"Identifier\">node</span>.<span class=\"Identifier\">attr</span>[<span class=\"String\">&quot;id&quot;</span>]<br />
</blockquote>

<h4>HTML のパース</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">dom</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#html#parse<span class=\"Special\">(...)</span><br />
</blockquote>

扱い方は XML と同じです。<br />

<h4>JSON のエンコード/デコード</h4>

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">obj</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#decode<span class=\"Special\">(</span>json<span class=\"Special\">)</span><br />
</blockquote>

vim の値として扱えます。逆に

<blockquote class=\"code\">
<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">json</span>&nbsp;<span class=\"Operator\">=</span>&nbsp;webapi#json#encode<span class=\"Special\">(</span>obj<span class=\"Special\">)</span><br />
</blockquote>

でエンコード出来ます。

webapi-vim にはこれ以外にも XMLRPC/JSONRPC/SOAP といったRPC、MD5/SHA1 といったハッシュ関数、OAuth もあります。詳しくはドキュメントを見て頂くか、サンプルや webaip-vim を使ったプロダクトのソースコードを参照して下さい。<br />

<h2>metarw とは</h2>

さて、いまごろ本題<br />
昨今のモテる Vim 使いはどんな物に対しても vim から読み書きを行います(要出典)。その代表例として vim-metarw という物もあります。

<blockquote class=\"quote\">
	<a href=\"https://github.com/kana/vim-metarw\">kana/vim-metarw - GitHub</a>
	<br />
	<p>Vim plugin: A framework to read/write fake:path</p>
	<cite>https://github.com/kana/vim-metarw</cite>
</blockquote>

これは kana さんが作ったフレームワークで、metarw 自身は vim からメタ情報を読み書きする土台のみを提供します。各 metarw プラグインは metarw のルールに従って実装コードを入れる事で vim と親和性の高いファイルの読み書きが出来るという物です。例えば vim-metarw-gist という物があります。

<blockquote class=\"quote\">
	<a href=\"https://github.com/emonkak/vim-metarw-gist\">emonkak/vim-metarw-gist ﾂｷ GitHub</a>
	<br />
	<p>Vim plugin: metarw scheme for gist</p>
	<cite>https://github.com/emonkak/vim-metarw-gist</cite>
</blockquote>

これを使うと <code>:e gist:</code> で vim が持っているファイルエクスプローラと同じ見栄えで自分の gist 一覧が表示され、エンターを押すと gist のファイルが開かれ、<code>:w</code> で書き込めます。
なお Windows で metarw を使う場合には私の fork を使って下さい。

<blockquote class=\"quote\">
	<a href=\"https://github.com/mattn/vim-metarw\">mattn/vim-metarw - GitHub</a>
	<br />
	<cite>https://github.com/mattn/vim-metarw</cite>
</blockquote>

ここで metarw プラグインについて説明しましょう。<br />
vim-metarw プラグインを作る場合はまずプラグインフォルダを用意し、<code>autoload/metarw/プラグイン名.vim</code> というファイルを作ります。<br />
vim-metarw プラグインを満たす為には以下の実装を含んでいる必要があります。

<blockquote class=\"code\">
metarw#gdrive#read(fakepath)<br />
metarw#gdrive#write(fakepath, line1, line2, append_p)<br />
metarw#gdrive#complete(arglead, cmdline, cursorpos)<br />
</blockquote>

まず read を説明します。metarw プラグインは fakepath で指定されたパスがディレクトリかどうかを判断し、ディレクトリであれば

<blockquote class=\"code\">
['browse', [<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ふー&quot;, &quot;fakepath&quot;: &quot;xxx:/foo&quot;},<br />
&nbsp;&nbsp;{&quot;label&quot;: &quot;ばー&quot;, &quot;fakepath&quot;: &quot;xxx:/bar&quot;}<br />
]]<br />
</blockquote>

browse という結果と共にパス情報を返します。エラーが発生した場合には

<blockquote class=\"code\">
['error', 'エラーメッセージ']<br />
</blockquote>

を返します。ファイルであった場合には、既に metarw が用意したバッファにコンテンツを貼り付け、必要であれば filetype も変更して

<blockquote class=\"code\">
['done', '']<br />
</blockquote>

という結果を返します。write も同様に、fakepath で指定されたパスに対して現在のバッファの line1 行から line2 行のコンテンツを書き込みます。append_p の場合は追記になります。<br />
最後に complete は vim の補完と同じ仕組みになります。実際には、read の際にファイル一覧を作った結果の fakepath 部分を返せば良い事になります。<br />
<br />
ここまで来れば誰でも metarw プラグインを作れる様になります。<br />
<br />
<h2>vim-metarw-gdrive でハードウェア境界を越えろ</h2>

<img src=\"http://go-gyazo.appspot.com/7ae8b32993cf4b88.png\" alt=\"!!!\" class=\"thumbnail-left\" />
上記で説明した webapi-vim と、この vim-metarw を使い、<a href=\"https://drive.google.com/\">Google Drive</a> のファイルを読み書き出来る物を作ってみましょう。<br />
<br />
<blockquote>
なっ！？なんだってーーー！
</blockquote>
<br class=\"clearall\" />
まずは read で指定されたパスから属性情報を取り出す部分を作ります。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>parse_incomplete_fakepath<span class=\"Special\">(</span>incomplete_fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Special\">{}</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">fragments</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span>,&nbsp;<span class=\"Constant\">'^\\l\\+\\zs:'</span>, !<span class=\"Constant\">0</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span>fragments<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">&lt;=</span>&nbsp;<span class=\"Constant\">1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>given_fakepath&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:incomplete_fakepath</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>scheme&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">0</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=</span>&nbsp;fragments[<span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;fragments[<span class=\"Constant\">1</span>]&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'^[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'root'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span><span class=\"Statement\">.</span>id&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span>fragments[<span class=\"Constant\">1</span>],&nbsp;<span class=\"Constant\">'[\\/]'</span><span class=\"Special\">)</span>[<span class=\"Statement\">-</span><span class=\"Constant\">1</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;_<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

<a href=\"https://developers.google.com/drive/\">Google Drive SDK</a> の API リファレンスによると、Google Drive の API では各ファイルにパスでアクセスする事は出来ません。パスから特定のコンテンツを得たり保存を行う場合には、ノードIDに対して割り当てられた名称を取得し、例えば <code>/foo/bar/baz.txt</code> というパスのコンテンツを得る場合、実は bar というフォルダのIDだけ分かれば書き込める事になります。ただしラベルは同じノード内においても重複し得ます。なのでパス <code>/foo/bar/baz.txt</code> という情報から目的の <code>baz.txt</code> のコンテンツを得るには

<ul>
	<li>\"root\" ノード直下のファイル一覧を調べ、ディレクトリかつラベルが foo の最初の物を探す</li>
	<li>foo 直下のファイル一覧を調べ、ディレクトリかつラベルが bar の最初の物を探す</li>
	<li>bar 直下のファイル一覧を調べ、ファイルかつラベルが baz.txt の最初の物を探す</li>
	<li>baz.txt のコンテンツをダウンロードする</li>
</ul>

こいうめんどくさい手順を取る必要があります。たかがファイルを読みたいだけに4回 API アクセスが必要になります。どう考えてもおかし過ぎるし使っててイライラするだろうから、このプラグインで扱うパス情報は ID で行う事とし、ファイルブラウザで実際のファイル名からアクセスしてもらう事とします。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>! metarw#gdrive#read<span class=\"Special\">(</span>fakepath<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_list</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:read_content</span><span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

まずは先ほど作った parse_incomplete_fakepath に従い、ファイル一覧を読むのかファイルのコンテンツを読むのかを切り分けます。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_list<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;[]<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files\">https://www.googleapis.com/drive/v2/files</a>'</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'q'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">&quot;'%s' in parents&quot;</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span><span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">for</span>&nbsp;item&nbsp;<span class=\"Statement\">in</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>items<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>labels<span class=\"Statement\">.</span>trashed&nbsp;<span class=\"Statement\">!=</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">continue</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>title<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;item<span class=\"Statement\">.</span>id<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;item<span class=\"Statement\">.</span>mimeType&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">'application/vnd.google-apps.folder'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">title</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">.=</span>&nbsp;<span class=\"Constant\">'/'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">len</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path<span class=\"Special\">)</span>&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'/'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">file</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">file</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">add</span><span class=\"Special\">(</span>result,&nbsp;<span class=\"Special\">{</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'label'</span>: title,<br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Constant\">'fakepath'</span>:&nbsp;<span class=\"Identifier\">printf</span><span class=\"Special\">(</span><span class=\"Constant\">'%s:%s'</span>,&nbsp;<span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>scheme, file<span class=\"Special\">)</span><br />
<span class=\"Special\">&nbsp;&nbsp;&nbsp;&nbsp;\\</span>&nbsp;<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endfor</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'browse'</span>,&nbsp;result]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

Google Drive API を使って、ノードID に属するファイルの一覧を取得しています。<br />

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>read_content<span class=\"Special\">(</span>_<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/drive/v2/files/\">https://www.googleapis.com/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'access_token'</span>: s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;!<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'downloadUrl'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Constant\">'This file seems impossible to edit in vim!'</span>]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">resp</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#http#<span class=\"Normal\">get</span><span class=\"Special\">(</span>res<span class=\"Statement\">.</span>downloadUrl,&nbsp;<span class=\"Constant\">''</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>]<span class=\"Special\">}</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]&nbsp;<span class=\"Statement\">!~</span>&nbsp;<span class=\"Constant\">'200'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;resp<span class=\"Statement\">.</span>header[<span class=\"Constant\">0</span>]]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;resp<span class=\"Statement\">.</span>content<br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Identifier\">setline</span><span class=\"Special\">(</span><span class=\"Constant\">2</span>,&nbsp;<span class=\"Identifier\">split</span><span class=\"Special\">(</span><span class=\"Identifier\">iconv</span><span class=\"Special\">(</span>content,&nbsp;<span class=\"Constant\">'utf-8'</span>, &amp;encoding<span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">))</span><br />
<br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">ext</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Constant\">'.'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>fileExtension<br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>s:extmap, ext<span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;&amp;<span class=\"Statement\">filetype</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;s:extmap[ext]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

ノードIDからコンテンツをダウンロードしています。ファイル名に拡張子がついていないので、拡張子からファイルタイプを決定する為にローカルにテーブルを保持しました。<br />
ここで metarw を使う際の注意点があります。metarw の read 関数実装は <code>:r! ...</code> といった外部ファイルを読み込む事を想定しており、vim のデフォルト動作と同様に先頭行に空行が入れる必要があります。この空行は metarw 本体側で削除されるので、metarw プラグイン側が空白行を入れる必要があります。<br />
<br />
write も同様に API から行います。

<blockquote class=\"code\">
<span class=\"Statement\">function</span>!&nbsp;<span class=\"Special\">s:</span>write_content<span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">call</span>&nbsp;<span class=\"Normal\">s:load_settings</span><span class=\"Special\">()</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">res</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;webapi#json#<span class=\"Normal\">decode</span><span class=\"Special\">(</span>webapi#http#<span class=\"Normal\">post</span><span class=\"Special\">(</span><span class=\"Constant\">'<a href=\"https://www.googleapis.com/upload/drive/v2/files/\">https://www.googleapis.com/upload/drive/v2/files/</a>'</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;webapi#http#<span class=\"Normal\">encodeURI</span><span class=\"Special\">(</span><span class=\"Identifier\">a:_</span><span class=\"Statement\">.</span>id<span class=\"Special\">)</span>,&nbsp;<span class=\"Identifier\">a:content</span>,&nbsp;<span class=\"Special\">{</span><span class=\"Constant\">'Authorization'</span>:&nbsp;<span class=\"Constant\">'Bearer '</span>&nbsp;<span class=\"Statement\">.</span>&nbsp;s:settings[<span class=\"Constant\">'access_token'</span>],&nbsp;<span class=\"Constant\">'Content-Type'</span>:&nbsp;<span class=\"Constant\">'application/octet-stream'</span><span class=\"Special\">}</span>,&nbsp;<span class=\"Constant\">'PUT'</span><span class=\"Special\">)</span><span class=\"Statement\">.</span>content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;<span class=\"Identifier\">has_key</span><span class=\"Special\">(</span>res,&nbsp;<span class=\"Constant\">'error'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'error'</span>,&nbsp;<span class=\"Statement\">res</span><span class=\"Statement\">.</span>error<span class=\"Statement\">.</span>message]<br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;[<span class=\"Constant\">'done'</span>,&nbsp;<span class=\"Constant\">''</span>]<br />
<span class=\"Statement\">endfunction</span><br />
<br />
<span class=\"Statement\">function</span>! metarw#gdrive#write<span class=\"Special\">(</span>fakepath, line1, line2, append_p<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">_</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:parse_incomplete_fakepath</span><span class=\"Special\">(</span><span class=\"Identifier\">a:fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">if</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">==</span>&nbsp;<span class=\"Constant\">''</span>&nbsp;<span class=\"Statement\">||</span>&nbsp;_<span class=\"Statement\">.</span>path&nbsp;<span class=\"Statement\">=~</span>&nbsp;<span class=\"Constant\">'[\\/]$'</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">echoerr</span>&nbsp;<span class=\"Constant\">'Unexpected a:incomplete_fakepath:'</span>&nbsp;<span class=\"Identifier\">string</span><span class=\"Special\">(</span><span class=\"Identifier\">a:incomplete_fakepath</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">throw</span>&nbsp;<span class=\"Constant\">'metarw:gdrive#e1'</span><br />
&nbsp;&nbsp;<span class=\"Statement\">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">content</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Identifier\">iconv</span><span class=\"Special\">(</span><span class=\"Identifier\">join</span><span class=\"Special\">(</span><span class=\"Identifier\">getline</span><span class=\"Special\">(</span><span class=\"Identifier\">a:line1</span>,&nbsp;<span class=\"Identifier\">a:line2</span><span class=\"Special\">)</span>,&nbsp;<span class=\"Constant\">&quot;\\n&quot;</span><span class=\"Special\">)</span>, &amp;encoding,&nbsp;<span class=\"Constant\">'utf-8'</span><span class=\"Special\">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"Statement\">let</span>&nbsp;<span class=\"Identifier\">result</span>&nbsp;<span class=\"Statement\">=</span>&nbsp;<span class=\"Normal\">s:write_content</span><span class=\"Special\">(</span>_, content<span class=\"Special\">)</span><br />
&nbsp;&nbsp;<span class=\"Statement\">endif</span><br />
&nbsp;&nbsp;<span class=\"Statement\">return</span>&nbsp;result<br />
<span class=\"Statement\">endfunction</span><br />
</blockquote>

このプラグインは Google Drive に oauth2 で認証を行っています。初めて使う際には

<blockquote class=\"code\">
:GdriveSetup
</blockquote>

を実行し、ブラウザで表示されたコードを vim の <code>CODE:</code> 部にコピペして頂く必要があります。<br />
Google Drive の API、というか最近の Google の API は認証情報に揮発性があり、リフレッシュトークンという物を使って有効期限が切れたアクセストークンを再生成する必要があります。上記のコードには含まれませんがリポジトリでは401による再認証が行われます。<br />
それでもエラーが出る場合は、お手数ですが再度

<blockquote class=\"code\">
:GdriveSetup
</blockquote>

を実行して認証を行って下さい。<br />
ソースを github に置いてあります。興味のある方は覗いてみて下さい。<br />

<blockquote class=\"quote\">
	<a href=\"https://github.com/mattn/vim-metarw-gdrive\">mattn/vim-metarw-gdrive ﾂｷ GitHub</a>
	<br />
	<cite>https://github.com/mattn/vim-metarw-gdrive</cite>
</blockquote>

全て webapi-vim もそうですが vim スクリプトだけで組まれています。(ただしネットワーク通信部分だけは curl もしくは wget を使っています)<br />
<br />
さて実際に使ってみましょう。上記の認証を終わらせた後 <code>:e gdrive:</code> を実行します。<br />
<blockquote>
<img src=\"http://go-gyazo.appspot.com/d6b57a1bfc4d80d6.png\" alt=\"vim-metarw-gdrive1\" />
</blockquote>

ファイル一覧が表示されました。<br />
なんと都合よく「helloworld.cxx」なんてファイルがあるではありませんか！！！<br />
エンターキーを押します。<br />
<br />

<blockquote>
<img src=\"http://go-gyazo.appspot.com/2ca01104e579a845.png\" alt=\"vim-metarw-gdrive2\" />
</blockquote>

おぉぉ...<br />
<br />
もちろん <code>:w</code> で保存する事も出来ますし、quickrun から直で実行する事も出来ます。<br />
ファイルを作成する場合は、ファイルブラウザに表示されるパスを使って「:w gdrive:/XXXXXXXX/foo.txt」と実行して下さい。現在のバッファが指定のフォルダにアップロードされます。この場合、バッファは既にテンポラリに過ぎないので更新したい場合はファイルブラウザから開きなおして下さい。<br />
<br />
<h2>まとめ</h2>

まとめると...
<blockquote>
<em>モテる Vimmer に読み書き出来ないファイルなど無かったんだよ！！</em>
</blockquote>
ってことです。<br />
<br />
<b>追記</b><br />
モテる度合いには個人差がございます。<br />
") (author nil "mattn.jp@gmail.com (mattn)"))))