;; -*- coding: utf-8 -*-
(("人工知能に関する断創録" "人工知能に関連したエントリーが多いです。JavaやPythonのゲームプログラミングの記事を書いてたこともあります。" nil (20693 57331 680710) feed 0 nil nil ((title nil "人工知能に関する断創録") (subtitle nil "人工知能に関連したエントリーが多いです。JavaやPythonのゲームプログラミングの記事を書いてたこともあります。") (link ((href . "http://aidiary.hatenablog.com/"))) (updated nil "2012-12-22T14:22:50+09:00") (author nil (name nil "aidiary")) (generator ((uri . "http://blog.hatena.ne.jp/") (version . "73ab9acab2b0e6249a3796c005f52325")) "Hatena::Blog") (id nil "http://blog.hatena.ne.jp/id/12704591929884392387") (entry nil (title nil "はてなブログに移行しました") (link ((href . "http://aidiary.hatenablog.com/entry/20121222/1356153770"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096659843") (updated nil "2012-12-22T14:22:50+09:00") (summary nil "はてなダイアリーからはてなブログに移行しました。 ") (content ((type . "html")) "<p>はてなダイアリーからはてなブログに移行しました。</p>
") (author nil (name nil "aidiary"))) (entry nil (title nil " 類似楽曲検索システムを作ろう") (link ((href . "http://aidiary.hatenablog.com/entry/20121014/1350211413"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656801") (updated nil "2012-10-14T19:43:33+09:00") (summary nil "もう1年以上かけて音声信号処理の勉強をしてきました（Pythonで音声信号処理）。ここらで具体的なアプリケーションとして類似楽曲検索の実験をしてみたのでレポートをまとめておきます。言語はPythonです。前に 類似画像検索システムを作ろう（2009/10/3） Visual Wo") (content ((type . "html")) "<p>もう1年以上かけて音声信号処理の勉強をしてきました（<a href=\"http://d.hatena.ne.jp/aidiary/20110514/1305377659\">Python&#x3067;&#x97F3;&#x58F0;&#x4FE1;&#x53F7;&#x51E6;&#x7406;</a>）。ここらで具体的なアプリケーションとして類似楽曲検索の実験をしてみたのでレポートをまとめておきます。言語は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>です。</p><p>前に</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;&#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x3092;&#x4F5C;&#x308D;&#x3046;</a>（2009/10/3）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）</li>
</ul><p>という画像の類似検索に関するエントリを書きましたが、今回は画像ではなく<span class=\"deco\" style=\"color:#FF0000;\">音楽を対象に</span>類似検索をやってみたいと思います！</p><p>今回作る類似楽曲検索システムは、従来からよくあるアーティスト名や曲名などテキストで検索するシステムや購買履歴をもとにオススメする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%A8%C4%B4%A5%D5%A5%A3%A5%EB%A5%BF%A5%EA%A5%F3%A5%B0\">協調フィルタリング</a>ベースのシステムとは異なります。WAVEファイルやMP3ファイルなどの<span class=\"deco\" style=\"color:#FF0000;\">音楽波形そのものを入力とする</span>のが特徴です。たとえば、「<span class=\"deco\" style=\"color:#FF0000;\">具体的なアーティストや曲名は知らないけれど、この曲とメロディや雰囲気が似た曲がほしいな</span>」なんていうときに便利に使えるシステムです。</p><p>この研究分野は、<span class=\"deco\" style=\"color:#FF0000;\">Music Information Retrieval (MIR)</span> と呼ばれています。私自身、アーティストによって曲を買うことはほとんどないので、以前からこういうシステムがほしいなぁと思ってました。</p><p>とりあえず実験結果だけ見たい方は下のページにあります。1位がクエリの楽曲で似ている順に上位10件を出力しました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTML5\">HTML5</a>でオーディオ断片を埋め込んだので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>だと音声で確認できます。</p>

<ul>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
</ul><p>どうでしょう？似てますかね？</p>

<div class=\"section\">
    <h4>概要</h4>
    <p>今回の実験で参考にした資料は、</p>

<ul>
<li>Pampalk, E., <a href=\"http://www.ofai.at/~elias.pampalk/publications/pampalk06thesis.pdf\">Computational Models of Music Similarity and their Application in Music Information Retrieval</a> (PDF), Doctoral Thesis, Vienna University of Technology, Austria, March 2006.</li>
</ul>
<ul>
<li>Logan, B. and Salomon, A., <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.9.9328\">A Content-based Music Similarity Function</a>, Technical report, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Compaq\">Compaq</a> Cambridge Research Lab, 2001.</li>
</ul><p>という2つの論文です。上の論文は、類似楽曲検索の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B5%A1%BC%A5%D9%A5%A4\">サーベイ</a>論文としてよくまとまっています。今回はPampalkさんの論文で紹介されているLoganさんの論文の手法を実際に試してみました。</p><p>Loganさんが提案したのは音声の局所特徴量を用いたアプローチで<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）と考え方がよく似ています。類似画像検索だとSIFTやSURFといった局所特徴量を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してVisual wordsを作りました。そして、各画像をVisual wordsの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>間の距離を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>インターセクションで求めました。</p><p>今回の音楽の場合は<a href=\"http://d.hatena.ne.jp/aidiary/20120225#1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;</a>（2012/2/25）、略して<span class=\"deco\" style=\"color:#FF0000;\">MFCC</span>というスペクトル特徴量を使います。各楽曲から得られるMFCCベクトル集合を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して楽曲を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の集合で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>集合間の距離を<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）で求めます。<span class=\"deco\" style=\"color:#FF0000;\">EMDが近い楽曲が互いに類似した楽曲</span>となるわけです。</p><p>コンテンツの表現方法や使用する距離の定義が多少違いますが、アプローチはよく似ています。というわけで論文にそって早速試してみます！</p>

</div>
<div class=\"section\">
    <h4>MP3ファイルの準備</h4>
    <p>類似楽曲検索なのでまず楽曲ファイルが必要です。最初、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E9%A5%B4%A5%F3%A5%AF%A5%A8%A5%B9%A5%C8\">ドラゴンクエスト</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%A1%A5%A4%A5%CA%A5%EB%A5%D5%A5%A1%A5%F3%A5%BF%A5%B8%A1%BC\">ファイナルファンタジー</a>のサウンドトラックで試してみたのですが、どうもよい結果が得られませんでした。いろいろ試したところインストだけの曲よりボーカルが入ってた方がよい結果になるみたいです。</p><p>私自身はボーカル入りのCDはあんまり持ってなかったので、妹の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>を<del datetime=\"2012-10-14T19:45:06+09:00\">パクって</del>借りて、500曲くらいのボーカル曲のリストを作りました。そんなわけで、検索結果の曲のすべてが私の趣味というわけではないのであしからず（笑）500曲のMP3ファイルは当然ながら公開できないのでお手持ちの曲でぜひ試してみてください。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>はアルバム名やアーティスト名で階層構造になっていますが、ここでは簡単のためすべての曲をmp3というフォルダにまとめました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>で買った曲などMP3以外のフォーマットがある場合は、MP3への変換が必要です。やり方はググってください。</p>

</div>
<div class=\"section\">
    <h4>MFCCの抽出</h4>
    <p>まず、MP3ファイルからスペクトル特徴量の<span class=\"deco\" style=\"color:#FF0000;\">メル周波数ケプストラム係数（MFCC）</span>を抽出します。MFCCはスペクトルの概形を表すパラメータなので音色を表すと考えてよいと思います。MFCCに関しては、前に書いた記事を参考にしてください。</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;&#xFF08;MFCC&#xFF09;</a>（2012/2/25）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (6) MFCC&#x306E;&#x62BD;&#x51FA;</a>（2012/8/5）</li>
</ul><p>以下が、指定したMP3ディレクトリ（mp3）にあるすべてのMP3ファイルからMFCCを抽出してMFCCディレクトリ（mfcc）に保存する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトです。音声フォーマットの変換に<a href=\"http://sox.sourceforge.net\">sox</a>と<a href=\"http://lame.sourceforge.net\">lame</a>、波形の切り出し、MFCCの抽出に<a href=\"http://sp-tk.sourceforge.net\">SPTK</a>というツールを使っています。両方ともインストールしないと動きません。SPTKのインストールは</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120701/1341126474\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (1) &#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x30FB;&#x6CE2;&#x5F62;&#x63CF;&#x753B;&#x30FB;&#x97F3;&#x58F0;&#x518D;&#x751F;</a>（2012/7/1）</li>
</ul><p>という記事にまとめました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys

<span class=\"synComment\"># mp3_to_mfcc.py</span>
<span class=\"synComment\"># usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>
<span class=\"synComment\"># ディレクトリ内のMP3ファイルからMFCCを抽出する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">mp3ToRaw</span>(mp3File, rawFile):
    <span class=\"synComment\"># mp3を16kHz, 32bitでリサンプリング</span>
    os.system(&quot;<span class=\"synConstant\">lame --resample 16 -b 32 -a '%s' temp.mp3</span>&quot; % mp3File)
    <span class=\"synComment\"># mp3をwavに変換</span>
    os.system(&quot;<span class=\"synConstant\">lame --decode temp.mp3 temp.wav</span>&quot;)
    <span class=\"synComment\"># wavをrawに変換</span>
    os.system(&quot;<span class=\"synConstant\">sox temp.wav %s</span>&quot; % rawFile)
    os.remove(&quot;<span class=\"synConstant\">temp.mp3</span>&quot;)
    os.remove(&quot;<span class=\"synConstant\">temp.wav</span>&quot;)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcNumSample</span>(rawFile):
    <span class=\"synComment\"># 1サンプルはshort型（2byte）なのでファイルサイズを2で割る</span>
    filesize = os.path.getsize(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
    numsample = filesize / 2
    <span class=\"synStatement\">return</span> numsample

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">extractCenter</span>(inFile, outFile, period):
    <span class=\"synComment\"># 波形のサンプル数を求める</span>
    numsample = calcNumSample(inFile)

    fs = 16000
    center = numsample / 2
    start = center - fs * period
    end = center + fs * period
    
    <span class=\"synComment\"># period*2秒未満の場合は範囲を狭める</span>
    <span class=\"synStatement\">if</span> start &lt; 0: start = 0
    <span class=\"synStatement\">if</span> end &gt; numsample - 1: end = numsample - 1

    <span class=\"synComment\"># SPTKのbcutコマンドで切り出す</span>
    os.system(&quot;<span class=\"synConstant\">bcut +s -s %d -e %d &lt; '%s' &gt; '%s'</span>&quot; <span class=\"synSpecial\">\\</span>
              % (start, end, &quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile))

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcMFCC</span>(rawFile, mfccFile):
    <span class=\"synComment\"># サンプリング周波数: 16kHz</span>
    <span class=\"synComment\"># フレーム長: 400サンプル</span>
    <span class=\"synComment\"># シフト幅  : 160サンプル</span>
    <span class=\"synComment\"># チャンネル数: 40</span>
    <span class=\"synComment\"># MFCC: 19次元 + エネルギー</span>
    os.system(&quot;<span class=\"synConstant\">x2x +sf &lt; '%s' | frame -l 400 -p 160 | mfcc -l 400 -f 16 -n 40 -m 19 -E &gt; '%s'</span>&quot;
              % (rawFile, mfccFile))

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 4:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>&quot;
        sys.exit()

    mp3Dir = sys.argv[1]
    mfccDir = sys.argv[2]
    rawDir = sys.argv[3]

    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(mfccDir):
        os.mkdir(mfccDir)
    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(rawDir):
        os.mkdir(rawDir)

    <span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mp3Dir):
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mp3</span>&quot;): <span class=\"synStatement\">continue</span>
        mp3File = os.path.join(mp3Dir, file)
        mfccFile = os.path.join(mfccDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.mfc</span>&quot;))
        rawFile = os.path.join(rawDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.raw</span>&quot;))

        <span class=\"synStatement\">try</span>:
            <span class=\"synComment\"># MP3を変換</span>
            mp3ToRaw(mp3File, &quot;<span class=\"synConstant\">temp.raw</span>&quot;)
        
            <span class=\"synComment\"># 中央の30秒だけ抽出してrawFileへ</span>
            extractCenter(&quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile, 15)

            <span class=\"synComment\"># MFCCを計算</span>
            calcMFCC(rawFile, mfccFile)

            <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%s =&gt; %s</span>&quot; % (mp3File, mfccFile)

            <span class=\"synComment\"># 後片付け</span>
            os.remove(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
        <span class=\"synStatement\">except</span>:
            <span class=\"synStatement\">continue</span>
</pre><p>曲全体からMFCCを抽出すると処理が重すぎるので、Pampalkさんの論文に従って、曲の中心の30秒間だけを対象にしました。本当は、画像の局所特徴量SIFTのようにその曲の特徴をよく表す部分（サビ？）からとりたかったのだけどどうやればいいんだろう。</p><p>MFCCファイルは、SPTKのバイナリ形式になっています。前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">print_mfcc.py</a>というスクリプトでダンプできます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>を20次元ずつダンプしてみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py mfcc/愛は勝つ.mfc 20
-14.77  -8.78   -6.70   ...    3.45    7.37    1.44    2.80    22.29
-13.84  -9.71   -3.28   ...    -0.82   6.72    2.70    1.92    22.85
-15.45  -12.54  -7.64   ...    -5.64   3.45    2.31    6.03    22.67
-14.64  -10.72  -4.96   ...    -5.24   3.64    0.71    5.49    22.78</pre><p>各行が1フレームの20次元MFCCベクトル（19次元+パワー）です。サンプリング周波数16kHz、シフト幅160サンプル、30秒間の楽曲なので、30 x 16000 / 160 = 3000フレームあります。つまり、「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>」の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>ファイルは<span class=\"deco\" style=\"color:#FF0000;\">20次元のMFCCベクトルが3000行もあります</span>。1曲を表すベクトルとしては大きすぎですね・・・</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214857\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214857.png\" alt=\"f:id:aidiary:20121015214857p:image\" title=\"f:id:aidiary:20121015214857p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p>

</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の計算</h4>
    <p>1曲を表す特徴ベクトルが、20次元ベクトル3000個（20x3000 = 60000個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>）では大きすぎるのでもう少し情報を圧縮します。こんなときに使えるのが前に紹介した<a href=\"http://d.hatena.ne.jp/aidiary/20120813/1344853878\">&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x91CF;&#x5B50;&#x5316;</a>（2012/8/13）というアルゴリズムです。ようは3000個のベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してよく似たベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>にまとめてしまいます。そして各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>と仮定してその平均ベクトルと分散共分散行列を求め、それをあらたな特徴量とします。式で表すと楽曲Pの特徴量は、<br />
<center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013175637\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013175637.png\" alt=\"f:id:aidiary:20121013175637p:image\" title=\"f:id:aidiary:20121013175637p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
となります。mは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の数です。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>にはよく使われる<span class=\"deco\" style=\"color:#FF0000;\">k-means</span>を用いました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数は上の論文に合わせて16としました。つまり、3000個のベクトル集合をたった16個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均ベクトルは20次元ベクトル、分散共分散行列は20x20次元の行列になります。つまり、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>(20次元平均ベクトル + 20x20次元の分散共分散行列) x 16クラスタ = 6720個の浮動小数点数</pre><p>まで情報を圧縮できます。実際は、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均と分散のほかに重み（その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されたベクトルの数）の情報も加えるので正確には6736個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>になります。60000個に比べたらずいぶん減ります。下のスクリプトは、各局のMFCCファイルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルに変換するスクリプトです。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster

<span class=\"synComment\"># mfcc_to_signature.py</span>
<span class=\"synComment\"># usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>
<span class=\"synComment\"># 各曲のMFCCをシグネチャに変換する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadMFCC</span>(mfccFile, m):
    &quot;&quot;&quot;<span class=\"synConstant\">MFCCをロードする、mはMFCCの次元数</span>&quot;&quot;&quot;
    mfcc = []
    fp = open(mfccFile, &quot;<span class=\"synConstant\">rb</span>&quot;)
    <span class=\"synStatement\">while</span> True:
        b = fp.read(4)
        <span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>
        val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
        mfcc.append(val)
    fp.close()

    <span class=\"synComment\"># 各行がフレームのMFCC</span>
    <span class=\"synComment\"># numFrame行、m列の行列形式に変換</span>
    mfcc = np.array(mfcc)
    numFrame = len(mfcc) / m
    mfcc = mfcc.reshape(numFrame, m)

    <span class=\"synStatement\">return</span> mfcc

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">vq</span>(mfcc, k):
    &quot;&quot;&quot;<span class=\"synConstant\">mfccのベクトル集合をk個のクラスタにベクトル量子化</span>&quot;&quot;&quot;
    codebook, destortion = scipy.cluster.vq.kmeans(mfcc, k)
    code, dist = scipy.cluster.vq.vq(mfcc, codebook)
    <span class=\"synStatement\">return</span> code

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 3:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>&quot;
        sys.exit()

    mfccDir = sys.argv[1]
    sigDir  = sys.argv[2]

    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(sigDir):
        os.mkdir(sigDir)

    <span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mfccDir):
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mfc</span>&quot;): <span class=\"synStatement\">continue</span>
        mfccFile = os.path.join(mfccDir, file)
        sigFile = os.path.join(sigDir, file.replace(&quot;<span class=\"synConstant\">.mfc</span>&quot;, &quot;<span class=\"synConstant\">.sig</span>&quot;))

        <span class=\"synStatement\">print</span> mfccFile, &quot;<span class=\"synConstant\">=&gt;</span>&quot;, sigFile

        fout = open(sigFile, &quot;<span class=\"synConstant\">w</span>&quot;)

        <span class=\"synComment\"># MFCCをロード</span>
        <span class=\"synComment\"># 各行がフレームのMFCCベクトル</span>
        mfcc = loadMFCC(mfccFile, 20)

        <span class=\"synComment\"># MFCCをベクトル量子化してコードを求める</span>
        code = vq(mfcc, 16)

        <span class=\"synComment\"># 各クラスタのデータ数、平均ベクトル、</span>
        <span class=\"synComment\"># 共分散行列を求めてシグネチャとする</span>
        <span class=\"synStatement\">for</span> k <span class=\"synStatement\">in</span> range(16):
            <span class=\"synComment\"># クラスタkのフレームのみ抽出</span>
            frames = np.array([mfcc[i] <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)) <span class=\"synStatement\">if</span> code[i] == k])
            <span class=\"synComment\"># MFCCの各次元の平均をとって平均ベクトルを求める</span>
            m = np.apply_along_axis(np.mean, 0, frames)  <span class=\"synComment\"># 0は縦方向</span>
            <span class=\"synComment\"># MFCCの各次元間での分散・共分散行列を求める</span>
            sigma = np.cov(frames.T)
            <span class=\"synComment\"># 重み（各クラスタのデータ数）</span>
            w = len(frames)
            <span class=\"synComment\"># このクラスタの特徴量をフラット形式で出力</span>
            <span class=\"synComment\"># 1行が重み1個、平均ベクトル20個、分散・共分散行列400個の計421個の数値列</span>
            features = np.hstack((w, m, sigma.flatten()))
            features = [str(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> features]
            fout.write(&quot;<span class=\"synConstant\"> </span>&quot;.join(features) + &quot;<span class=\"synSpecial\">\\n</span>&quot;)
        fout.close()
</pre><p>出力である楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルは、1行に (重み、20次元平均ベクトル、20x20次元の分散・共分散行列) の421個の数値が並びます。それが、16<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>分あるので16行のファイルです。</p>

</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離と楽曲間の距離</h4>
    <p>次に2つの楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離を求めます。これには、前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）を使います。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214928\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214928.png\" alt=\"f:id:aidiary:20121015214928p:image\" title=\"f:id:aidiary:20121015214928p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>左側が楽曲Pの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>で右側が楽曲Qの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>です。楽曲Pと楽曲Qの距離を求めるのが課題です。EMDの詳しい解説は、<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）を参照してください。先のページのEMD具体例では、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>が単純な<span class=\"deco\" style=\"color:#FF0000;\">ベクトル</span>なので、各特徴量間の距離に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えました。ですが、今回は各特徴量がベクトルではなく、<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a></span>になっています。というわけで単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えません・・・</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離がはかれる指標として<span class=\"deco\" style=\"color:#FF0000;\">カルバック・ライブラー情報量（Kullback Leibler Divergence）</span>というのがあります。<a href=\"http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\">Kullback-Leibler divergence - Wikipedia</a>によると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>N1とN2（それぞれ平均ベクトル、分散共分散行列がある）の間のカルバック・ライブラー情報量の定義は、</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190723\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190723.png\" alt=\"f:id:aidiary:20121013190723p:image\" title=\"f:id:aidiary:20121013190723p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>です。うう、目がくらむぅ。kは平均ベクトルの次元数です。一般的にカルバック・ライブラー情報量は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が成り立ちません。つまり、<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N1%7C%7CN2%29\" alt=\"D_{KL}(N1||N2)\"/>と<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N2%7C%7CN1%29\" alt=\"D_{KL}(N2||N1)\"/>で異なる値が出てきます。そのため、上の式をそのまま使うと楽曲Pからみた楽曲Qの距離と楽曲Qからみた楽曲Pの距離が違ってきます。これでは使いにくい。そのため、論文では<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量</span>を使っています<a href=\"#f1\" name=\"fn1\" title=\"ただ、先の論文には誤りがあるようです。traceがぬけているため結果がスカラーになりません。\">*1</a>。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190948\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190948.png\" alt=\"f:id:aidiary:20121013190948p:image\" title=\"f:id:aidiary:20121013190948p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>単純にひっくり返した距離も足し合わせているだけですね。これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が保たれます。カルバック・ライブラー情報量は、<a href=\"http://rss.acs.unt.edu/Rdoc/library/monomvn/html/kl.norm.html\">R&#x306B;&#x306F;&#x95A2;&#x6570;&#x304C;&#x7528;&#x610F;&#x3055;&#x308C;&#x3066;&#x3044;&#x308B;</a>のですが、SciPy/NumPyにはないので自作します。カルバック・ライブラー情報量の定義式において定数倍や定数項は、距離の比較では必要ないので省略しました。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%D4%CE%F3%BC%B0\">行列式</a>の項は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量を使うと打ち消し合って消えるので省略しました。trは、traceの略で行列の対角成分の和です。スクリプトでは、diag()で対角成分を取り出して、sum()で合計しています。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">KLDiv</span>(mu1, S1, mu2, S2):
    &quot;&quot;&quot;<span class=\"synConstant\">正規分布間のカルバック・ライブラー情報量</span>&quot;&quot;&quot;
    <span class=\"synComment\"># 逆行列を計算</span>
    <span class=\"synStatement\">try</span>:
        invS1 = np.linalg.inv(S1)
    <span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
        <span class=\"synStatement\">raise</span>;
    <span class=\"synStatement\">try</span>:
        invS2 = np.linalg.inv(S2)
    <span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
        <span class=\"synStatement\">raise</span>;

    <span class=\"synComment\"># KL Divergenceを計算</span>
    t1 = np.sum(np.diag(np.dot(invS2, S1)))
    t2 = (mu2 - mu1).transpose()
    t3 = mu2 - mu1
    <span class=\"synStatement\">return</span> t1 + np.dot(np.dot(t2, invS2), t3)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">symKLDiv</span>(mu1, S1, mu2, S2):
    &quot;&quot;&quot;<span class=\"synConstant\">対称性のあるカルバック・ライブラー情報量</span>&quot;&quot;&quot;
    <span class=\"synStatement\">return</span> 0.5 * (KLDiv(mu1, S1, mu2, S2) + KLDiv(mu2, S2, mu1, S1))
</pre><p>これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離が定義できたのでEMDを計算する関数も作ります。<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）にも書きましたが、RにはEMDの輸送問題を解く関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使ってRの関数を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出しました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects

<span class=\"synComment\"># Rで輸送問題を解くライブラリ</span>
<span class=\"synComment\"># Rのデフォルトパッケージではないのでインストールが必要</span>
<span class=\"synComment\"># Rでinstall.packages(&quot;lpSolve&quot;)</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcEMD</span>(sigFile1, sigFile2):
    <span class=\"synComment\"># シグネチャをロード</span>
    sig1 = loadSignature(sigFile1)
    sig2 = loadSignature(sigFile2)

    <span class=\"synComment\"># 距離行列を計算</span>
    numFeatures = sig1.shape[0]                 <span class=\"synComment\"># クラスタの数</span>
    dist = np.zeros(numFeatures * numFeatures)  <span class=\"synComment\"># 距離行列（フラット形式）</span>

    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(numFeatures):
        mu1 = sig1[i, 1:21].reshape(20, 1)   <span class=\"synComment\"># 縦ベクトル</span>
        S1 = sig1[i, 21:421].reshape(20, 20)
        <span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(numFeatures):
            mu2 = sig2[j, 1:21].reshape(20, 1)
            S2 = sig2[j, 21:421].reshape(20, 20)
            <span class=\"synComment\"># 特徴量iと特徴量j間のKLダイバージェンスを計算</span>
            dist[i * numFeatures + j] = symKLDiv(mu1, S1, mu2, S2)

    <span class=\"synComment\"># シグネチャの重み（0列目）を取得</span>
    w1 = sig1[:,0]
    w2 = sig2[:,0]

    <span class=\"synComment\"># 重みと距離行列からEMDを計算</span>
    <span class=\"synComment\"># transport()の引数を用意</span>
    costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
                                 nrow=len(w1), ncol=len(w2),
                                 byrow=True)
    row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
    row_rhs = robjects.FloatVector(w1)
    col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
    col_rhs = robjects.FloatVector(w2)
    
    t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
    flow = t.rx2('<span class=\"synConstant\">solution</span>')
    
    dist = dist.reshape(len(w1), len(w2))
    flow = np.array(flow)
    work = np.sum(flow * dist)
    emd = work / np.sum(flow)
    <span class=\"synStatement\">return</span> emd
</pre><p>これでようやく二つの楽曲間の距離を測れるようになりました。次は、与えたクエリと距離が近い楽曲を検索する部分を作ります。</p>

</div>
<div class=\"section\">
    <h4>類似楽曲検索</h4>
    <p>今回は検索対象の楽曲が500曲程度なので単純な線形探索を使いました。クエリの楽曲と500曲全部の間でEMDを計算して、距離が近い順にランキングを出力します。ついでに<a href=\"http://eyed3.nicfit.net/\">eyeD3</a>というMP3ファイルからタグ情報を読み書きするライブラリを用いて、MP3ファイルからアーティスト名を読み取って出力してみました。また、検索結果をテキストで出力しただけでは検証しにくいので、オーディオタグを埋め込んだHTMLも合わせて出力しています。</p><p>先ほどの3つの関数（KLDiv、symKLDiv、calcEMD）は省略しているので下のスクリプトに追加してください。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects
<span class=\"synPreProc\">from</span> collections <span class=\"synPreProc\">import</span> defaultdict

<span class=\"synComment\"># mir.py</span>
<span class=\"synComment\"># usage: python mir.py [sig file] [sig dir] [html file]</span>
<span class=\"synComment\"># sig file  : クエリ楽曲のシグネチャファイル</span>
<span class=\"synComment\"># sig dir   : 検索対象のシグネチャファイルのディレクトリ</span>
<span class=\"synComment\"># html file : 検索結果を出力するHTMLファイル</span>

<span class=\"synComment\"># 引数で指定したシグネチャファイルに近い</span>
<span class=\"synComment\"># 上位N件の楽曲を出力する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadSignature</span>(sigFile):
    &quot;&quot;&quot;<span class=\"synConstant\">シグネチャファイルをロード</span>&quot;&quot;&quot;
    mat = []
    fp = open(sigFile, &quot;<span class=\"synConstant\">r</span>&quot;)
    <span class=\"synStatement\">for</span> line <span class=\"synStatement\">in</span> fp:
        line = line.rstrip()
        mat.append([float(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> line.split()])
    fp.close()
    <span class=\"synStatement\">return</span> np.array(mat)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">getArtist</span>(mp3Path):
    &quot;&quot;&quot;<span class=\"synConstant\">MP3ファイルからアーティストを取得</span>&quot;&quot;&quot;
    <span class=\"synPreProc\">import</span> eyeD3
    <span class=\"synStatement\">try</span>:
        tag = eyeD3.Tag()
        tag.link(mp3Path)
        artist = tag.getArtist()
    <span class=\"synStatement\">except</span>:
        artist = &quot;<span class=\"synConstant\">None</span>&quot;
    <span class=\"synComment\"># 空白のとき</span>
    <span class=\"synStatement\">if</span> artist == &quot;&quot;: artist = &quot;<span class=\"synConstant\">None</span>&quot;
    <span class=\"synStatement\">return</span> artist

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">makeHTML</span>(ranking, htmlFile, N=10):
    &quot;&quot;&quot;<span class=\"synConstant\">ランキングをHTML形式で出力</span>&quot;&quot;&quot;
    <span class=\"synPreProc\">import</span> codecs
    fout = codecs.open(htmlFile, &quot;<span class=\"synConstant\">w</span>&quot;, &quot;<span class=\"synConstant\">utf-8</span>&quot;)

    <span class=\"synComment\"># HTMLヘッダを出力</span>
    fout.write('<span class=\"synConstant\">&lt;!DOCTYPE html&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;html lang=&quot;ja&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;</span><span class=\"synSpecial\">\\n</span>' % htmlFile)
    fout.write('<span class=\"synConstant\">&lt;body&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;table border=&quot;1&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write(u'<span class=\"synConstant\">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ランク&lt;/th&gt;&lt;th&gt;EMD&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;</span>')
    fout.write(u'<span class=\"synConstant\">&lt;th&gt;アーティスト&lt;/th&gt;&lt;th&gt;音声&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write(u'<span class=\"synConstant\">&lt;tbody&gt;</span><span class=\"synSpecial\">\\n</span>')

    <span class=\"synComment\"># ランキングを出力</span>
    rank = 1
    <span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
        prefix = sigFile.replace(&quot;<span class=\"synConstant\">.sig</span>&quot;, &quot;&quot;)

        <span class=\"synComment\"># rawをwavに変換（HTMLプレーヤー用）</span>
        rawPath = os.path.join(&quot;<span class=\"synConstant\">raw</span>&quot;, prefix + &quot;<span class=\"synConstant\">.raw</span>&quot;)
        wavPath = os.path.join(&quot;<span class=\"synConstant\">wav</span>&quot;, prefix + &quot;<span class=\"synConstant\">.wav</span>&quot;)
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(&quot;<span class=\"synConstant\">wav</span>&quot;): os.mkdir(&quot;<span class=\"synConstant\">wav</span>&quot;)
        os.system('<span class=\"synConstant\">sox -r 16000 -e signed-integer -b 16 &quot;%s&quot; &quot;%s&quot;</span>' % (rawPath, wavPath))

        <span class=\"synComment\"># アーティスト名を取得</span>
        mp3Path = os.path.join(&quot;<span class=\"synConstant\">mp3</span>&quot;, prefix + &quot;<span class=\"synConstant\">.mp3</span>&quot;)
        artist = getArtist(mp3Path)

        <span class=\"synComment\"># HTML出力</span>
        <span class=\"synComment\"># HTML5のオーディオプレーヤーを埋め込む</span>
        audio = '<span class=\"synConstant\">&lt;audio src=&quot;%s&quot; controls&gt;</span>' % wavPath
        fout.write(&quot;<span class=\"synConstant\">&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;</span><span class=\"synSpecial\">\\n</span>&quot;
                   % (rank, emd, prefix, artist, audio))
        rank += 1

    fout.write(&quot;<span class=\"synConstant\">&lt;/tbody&gt;</span><span class=\"synSpecial\">\\n</span>&quot;);
    fout.write(&quot;<span class=\"synConstant\">&lt;/table&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.write(&quot;<span class=\"synConstant\">&lt;/body&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.write(&quot;<span class=\"synConstant\">&lt;/html&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.close()

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 4:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">python mir.py [sig file] [sig dir] [html file]</span>&quot;
        sys.exit()

    targetSigPath = sys.argv[1]
    sigDir = sys.argv[2]
    htmlFile = sys.argv[3]

    ranking = defaultdict(float)
    
    <span class=\"synComment\"># 全楽曲との間で距離を求める</span>
    <span class=\"synStatement\">for</span> sigFile <span class=\"synStatement\">in</span> os.listdir(sigDir):
        sigPath = os.path.join(sigDir, sigFile)
        emd = calcEMD(targetSigPath, sigPath)
        <span class=\"synStatement\">if</span> emd &lt; 0: <span class=\"synStatement\">continue</span>
        ranking[sigFile] = emd

    <span class=\"synComment\"># ランキングをEMDの降順にソートして出力</span>
    N = 10
    rank = 1
    <span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%d</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%.2f</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%s</span>&quot; % (rank, emd, sigFile)
        rank += 1

    <span class=\"synComment\"># EMDの昇順に上位10件をHTMLにして出力</span>
    makeHTML(ranking, htmlFile, N)
</pre>
</div>
<div class=\"section\">
    <h4>実験</h4>
    <p>では、いくつかの楽曲をクエリとして与えてさっそく結果をみてみましょう！</p><p>この実験は、やはり音が聞けないと大部分の人にはわからないと思うので、各楽曲の中心30秒間のWAVファイルを再生できるHTMLページも用意しました。引用の範囲なのでおそらく大丈夫だとは思いますが・・・著作権者様からの連絡があったら削除します。結果の2列目がクエリとの間のEMDです。1位がクエリの曲になります。1位にクエリと同じ曲がくるのはまあ当然ですよね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/愛は勝つ.sig sig ai_ha_katu.html
1	20.00	愛は勝つ.sig
2	51.51	WE GOTTA POWER.sig
3	51.67	時の河.sig
4	52.30	Ilusion.sig
5	52.51	君がいるだけで.sig
6	53.26	君がいるから.sig
7	53.50	心のPhotograph.sig
8	53.65	ルネッサンス情熱.sig
9	54.25	嘘.sig
10	55.17	謳う丘.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。小学校のときすごい流行りました（笑）検索結果は、男性の力強いボーカル中心ということでけっこう似ているように思うのですがいかがでしょう？ところどころ女性ボーカルが入ってますが何でだろう？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/魔法の人.sig sig maho_no_hito.html
1	20.00	魔法の人.sig
2	64.30	変わらないもの.sig
3	65.87	優しい風.sig
4	66.34	Thanks.sig
5	67.06	旅の途中.sig
6	68.11	碧いうさぎ.sig
7	68.32	窓絵.sig
8	69.03	Garnet.sig
9	72.18	奇跡の海 (オリジナル・カラオケ).sig
10	72.19	甘えんぼ.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。女性の優しいボーカルが検索結果として並んでいるように思います。「変わらないもの」と「Garnet」はクエリと同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%FC%B2%DA%BB%D2\">奥華子</a>さんの曲みたいですね。聞いてみたところ雰囲気は何となく似ていると思います。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/Prayer.sig sig prayer.html        
1	20.00	Prayer.sig
2	81.31	Windancer.sig
3	85.38	Escape.sig
4	89.42	Appassionata.sig
5	89.42	First Day Of Spring.sig
6	90.56	Celebration.sig
7	91.46	Steps.sig
8	91.84	Moving.sig
9	97.62	Passacaglia.sig
10	98.97	陽だまりの歌.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。海外アーティストの英語の曲です。9位まではすべて同じSecret Gardenのアルバムからでした。同じアルバムということで非常に雰囲気が似ています。10位も優しい曲で同じような雰囲気を感じます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/君をのせて.sig sig kimi_wo_nosete.html
1	20.00	君をのせて.sig
2	80.20	魔法のぬくもり.sig
3	82.78	青空っていいな.sig
4	83.66	風のとおり道.sig
5	84.07	カントリー・ロード.sig
6	87.44	Garnet.sig
7	88.42	やさしさに包まれたなら.sig
8	88.91	わたしが不思議.sig
9	89.48	Hello My Friend.sig
10	89.95	つないだ手.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%B7%B6%F5%A4%CE%BE%EB%A5%E9%A5%D4%A5%E5%A5%BF\">天空の城ラピュタ</a>」のエンディング曲ですね。2位の「魔法のぬくもり」は同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%E6%BE%E5%A4%A2%A4%BA%A4%DF\">井上あずみ</a>さんの曲です。「風のとおり道」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AB%A5%F3%A5%C8%A5%EA%A1%BC%A1%A6%A5%ED%A1%BC%A5%C9\">カントリー・ロード</a>」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%E4%A4%B5%A4%B7%A4%B5%A4%CB%CA%F1%A4%DE%A4%EC%A4%BF%A4%CA%A4%E9\">やさしさに包まれたなら</a>」は全部<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の曲じゃないか！？これはおどろき。やっぱり雰囲気は似ているのかな？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/蒼い鳥.sig sig aoi_tori.html
1	20.00	蒼い鳥.sig
2	66.21	蒼い鳥（アレンシ&amp;#12441;版）.sig
3	83.96	青空っていいな.sig
4	85.03	春よ来い.sig
5	87.98	わたしが不思議.sig
6	88.12	遠い音楽.sig
7	90.25	Appassionata.sig
8	92.86	Dear You -Feel-.sig
9	93.21	やさしさに包まれたなら.sig
10	94.33	葬列.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。悲しげな感じがするきれいな曲です。2位に同じ「蒼い鳥」という曲が入りましたが、微妙に違うアレンジ版のようです。6位の「遠い音楽」も同じ今井さんの曲です。その他も何か悲しげな曲が多い感じです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/さくらんぼ.sig sig sakuranbo.html
1	20.00	さくらんぼ.sig
2	49.84	WILL.sig
3	50.58	Good Day.sig
4	51.12	扉の向こうへ.sig
5	51.75	夢想歌.sig
6	51.80	ショットガン・ラヴァーズ.sig
7	52.08	深く眠れ.sig
8	52.25	Vermillion.sig
9	52.46	西のそらへ.sig
10	52.87	大爆発No.1.sig</pre><p>最後は、<a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。元気な感じの女性のボーカルです。まあ検索結果も元気な感じの女性の曲が並んでいました。6位の「ショットガン・ラヴァーズ」は今話題の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BD%E9%B2%BB%A5%DF%A5%AF\">初音ミク</a>の曲のようです。合成音声でも関係ないのかな？</p>

</div>
<div class=\"section\">
    <h4>おわりに</h4>
    <p>今回は、類似楽曲検索システムを実験してみました。今回作ったのは非常に基本的なシステムでMFCCという特徴量だけに基づいています。さらにメロディ、リズムの類似性を考慮するなど改良できる点はたくさんあると思います。また、大量の楽曲を対象に検索するには並列処理やより効率的なアルゴリズムも必要ですね。たぶん、実用化に関してはそっちの方が問題になりそうです・・・上であげたPampalkさんの論文はさらに追究するスタートポイントとしてよくまとまっていると思います。</p><p><a href=\"http://d.hatena.ne.jp/aidiary/20120101/1325465854\">&#x4ECA;&#x5E74;&#x306E;&#x76EE;&#x6A19;</a>（2012/1/1）は、類似楽曲検索システムの実験をすることだったのでとりあえず達成！達成できたのは珍しいぞ。</p>

</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">ただ、先の論文には誤りがあるようです。traceがぬけているため結果が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AB%A5%E9%A1%BC\">スカラー</a>になりません。</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary"))) (entry nil (title nil " SciPyでベクトル量子化") (link ((href . "http://aidiary.hatenablog.com/entry/20120813/1344853878"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656806") (updated nil "2012-08-13T19:31:18+09:00") (summary nil "ベクトル量子化（Vector Quantization: VQ）とは、ベクトルで表されたデータ集合を有限個の代表的なパターン（セントロイド）に置き換える処理のことです。代表パターン（セントロイド）のリストはコードブック（code book）と呼ばれます。また、クラスタの番号をコー") (content ((type . "html")) "<p><span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vector\">Vector</a> Quantization: VQ）</span>とは、<span class=\"deco\" style=\"color:#FF0000;\">ベクトルで表されたデータ集合を有限個の代表的なパターン（セントロイド）に置き換える処理のことです</span>。代表パターン（セントロイド）のリストは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">コードブック（code book）</span>と呼ばれます。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の番号をコードと呼びます。各ベクトルデータは、距離が一番近いコードに置き換えられます。大量のデータを少ない代表パターンで置き換えることができるためデータの圧縮に使えます。ただし、コードブックから元のデータは復元できないため<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F3%B2%C4%B5%D5%B0%B5%BD%CC\">非可逆圧縮</a>になります。</p><p>コードブックを学習するためのアルゴリズムの代表例が<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a></span>です。ベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して、各データをそのデータが属する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドに置き換えることでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>が実現できます。</p>

<div class=\"section\">
    <h4>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用</h4>
    <p>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用例の一つに、前に取り上げた画像の<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Bag-of-Visual Words&#x8868;&#x73FE;</a>（2010/02/27）があります。Bag-of-Visual Wordsでは、ベクトルで表される画像の局所特徴量（SIFT、SURFなど）をK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。そして、K個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドをVisual Wordとし、各画像をVisual Wordの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現します。ここでは、Visual Wordsの集合がコードブックになりますね。</p><p>今回は、類似楽曲検索にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を応用する予定です。その場合、楽曲のMFCCベクトル集合がベクトルデータになり、これをK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類し、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の多次元分布（平均ベクトルと分散・共分散行列）を楽曲の特徴量とします。こうすることで、<span class=\"deco\" style=\"color:#FF0000;\">楽曲のMFCCベクトル集合をより少ないパラメータで表現できます</span>（データ次元の圧縮）。</p><p>まあ、応用は今後いろいろ試すことにして、ここでは単純な人工データでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を試してみます。</p>

</div>
<div class=\"section\">
    <h4>SciPyでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a></h4>
    <p>k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>は、以前実装しましたが、SciPyには、<a href=\"http://docs.scipy.org/doc/scipy/reference/cluster.vq.html#module-scipy.cluster.vq\">scipy.cluster.vq</a>というベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>に関するライブラリがあるのでそれを使ってみます。使うのは、コードブックを学習する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">kmeans()</span>関数とデータをベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">vq()</span>関数です。</p><p>この例では、3つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AC%A5%A6%A5%B9%CA%AC%C9%DB\">ガウス分布</a>から二次元データを100個ずつ生成しました。このベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してコードブックを求めています。そのコードブックをもとにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>して各データをコードに置き換えています。最後にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>されたデータをコード別に色分けして図示してみました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster
frompylab <span class=\"synPreProc\">import</span> *

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    cls1 = []
    cls2 = []
    cls3 = []

    <span class=\"synComment\"># 分布1</span>
    mean1 = [-2, 2]
    cov1 = [[1.0, 0.0], [0.0, 1.0]]

    <span class=\"synComment\"># 分布2</span>
    mean2 = [0, 0]
    cov2 = [[1.0, 0.8], [0.8, 1.0]]

    <span class=\"synComment\"># 分布3</span>
    mean3 = [2, -2]
    cov3 = [[0.5, 0.3], [0.8, 0.4]]

    <span class=\"synComment\"># 分布にしたがうデータ生成</span>
    cls1.extend(np.random.multivariate_normal(mean1, cov1, 100))
    cls2.extend(np.random.multivariate_normal(mean2, cov2, 100))
    cls3.extend(np.random.multivariate_normal(mean3, cov3, 100))
    X = vstack((cls1, cls2, cls3))

    <span class=\"synComment\"># データをクラスタリング</span>
    codebook, destortion = scipy.cluster.vq.kmeans(X, 3, iter=20, thresh=1e-05)
    <span class=\"synStatement\">print</span> codebook, destortion

    <span class=\"synComment\"># ベクトル量子化</span>
    <span class=\"synComment\"># 各データをセントロイドに分類する</span>
    code, dist = scipy.cluster.vq.vq(X, codebook)

    <span class=\"synComment\"># 各データをクラスタ別に色分けして描画</span>
    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(X)):
        x1, x2 = X[i, ]

        <span class=\"synStatement\">if</span> code[i] == 0: color = '<span class=\"synConstant\">r+</span>'
        <span class=\"synStatement\">elif</span> code[i] == 1: color = '<span class=\"synConstant\">b+</span>'
        <span class=\"synStatement\">elif</span> code[i] == 2: color = '<span class=\"synConstant\">g+</span>'
        plot(x1, x2, color)

    <span class=\"synComment\"># セントロイドを描画</span>
    x1, x2 = np.transpose(codebook)
    plot(x1, x2, '<span class=\"synConstant\">yo</span>')

    xlim(-6.0, 6.0)
    ylim(-6.0, 6.0)
    show()
</pre><p>実行するとこうなります。黄色い●がコードブックのセントロイドです。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120813192552\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120813/20120813192552.png\" alt=\"f:id:aidiary:20120813192552p:image\" title=\"f:id:aidiary:20120813192552p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>ちゃんと各データが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されていることがわかります。今回は、3つの分布からデータを生成したのでコードブックサイズ（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数、セントロイド数）は3としましたが、わからないときははいくつにすればいいんでしょうね？<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数を多くすればするほどkmeans()の返すdestortion（歪み）は小さくなり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の精度も上がるようです。だけどその代償としてコードブックのサイズは大きくなります。コードブックサイズと精度の間に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%EC%A1%BC%A5%C9%A5%AA%A5%D5\">トレードオフ</a>は応用や目的によって試行錯誤で決めるのかな？</p>

</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary"))) (entry nil (title nil " ODEをMacにインストール") (link ((href . "http://aidiary.hatenablog.com/entry/20120807/1344300689"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656808") (updated nil "2012-08-07T09:51:29+09:00") (summary nil "Mac OS X Mountain Lion に物理シミュレーションエンジンの Open Dynamics Engine (ODE) を入れようとしてすごく苦労したのでまとめておきます。macportsにもodeはありますが、これだとdrawstuffというライブラリが入っていな") (content ((type . "html")) "<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Mountain Lion に物理シミュレーションエンジンの <a href=\"http://www.ode.org/\">Open Dynamics Engine</a> (ODE) を入れようとしてすごく苦労したのでまとめておきます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>にもodeはありますが、これだとdrawstuffというライブラリが入っていなかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>からコンパイルしています。</p><p>コンパイルに使ったg++は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>ではなく、Xcode4.4のものです。Xcode4.4の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>ツールのインストールは、<a href=\"http://memo.yomukaku.net/entries/UaLbzhE\">&#x3053;&#x3061;&#x3089;</a>を参考にしてください。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; which g++
/usr/bin/g++
&gt; ls -l /usr/bin/g++
lrwxr-xr-x  1 root  wheel  12  7 28 21:19 /usr/bin/g++@ -&gt; llvm-g++-4.2</pre><p><a href=\"http://www.ode.org/\">Open Dynamics Engine</a> のサイトから <span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ode-0.12.tar.bz2</span> をダウンロードし、倍精度でコンパイルしました。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>tar xvzf ode-0.12.tar.bz2
cd ode-0.12
./configure --enable-double-precision
make
sudo make install</pre><p>ここまでで、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/lib</span>と<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/include</span>にODEがインストールされますが、実はこれだけではダメでデフォルトだとなぜかdrawstuffがインストールされなかったです。なので、<span class=\"deco\" style=\"color:#FF0000;\">drawstuffのライブラリファイルとヘッダファイルを手動でコピー</span>します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>sudo cp drawstuff/src/.libs/libdrawstuff.* /usr/local/lib/
sudo mkdir /usr/local/include/drawstuff
sudo cp include/drawstuff/*.h /usr/local/include/drawstuff/</pre><p>また、デフォルトのテクスチャファイルはあとで使うので作業ディレクトリにコピーしておくとよいです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>cp -R drawstuff/textures ~/work</pre><p>最後に<a href=\"http://demura.net/tutorials\">ODE&#x30C1;&#x30E5;&#x30FC;&#x30C8;&#x30EA;&#x30A2;&#x30EB;</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>をコンパイルして動作確認。<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">fn.path_to_textures</span>のtexturesは先ほどテクスチャをコピーした場所を設定します。</p>
<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synComment\">/* sample.cpp */</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;ode/ode.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;drawstuff/drawstuff.h&gt;</span>

<span class=\"synPreProc\">#ifdef dDOUBLE</span>
<span class=\"synPreProc\">#define dsDrawSphere dsDrawSphereD</span>
<span class=\"synPreProc\">#endif</span>

<span class=\"synType\">static</span> dWorldID world;
dBodyID ball;
<span class=\"synType\">const</span> dReal radius = <span class=\"synConstant\">0.2</span>, mass = <span class=\"synConstant\">1.0</span>;

<span class=\"synType\">static</span> <span class=\"synType\">void</span> simLoop(<span class=\"synType\">int</span> pause) {
    <span class=\"synType\">const</span> dReal *pos, *R;
    dWorldStep(world, <span class=\"synConstant\">0.05</span>);
    dsSetColor(<span class=\"synConstant\">1.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>);
    pos = dBodyGetPosition(ball);
    R = dBodyGetRotation(ball);
    dsDrawSphere(pos, R, radius);
}

<span class=\"synType\">void</span> start() {
    <span class=\"synType\">static</span> <span class=\"synType\">float</span> xyz[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">0.0</span>, -<span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">1.0</span>};
    <span class=\"synType\">static</span> <span class=\"synType\">float</span> hpr[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">90.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>};
    dsSetViewpoint(xyz, hpr);
}

<span class=\"synType\">int</span> main(<span class=\"synType\">int</span> argc, <span class=\"synType\">char</span> **argv) {
    dReal x0 = <span class=\"synConstant\">0.0</span>, y0 = <span class=\"synConstant\">0.0</span>, z0 = <span class=\"synConstant\">1.0</span>;
    dMass m1;

    dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start = &amp;start;
    fn.step = &amp;simLoop;
    fn.command = <span class=\"synConstant\">NULL</span>;
    fn.stop = <span class=\"synConstant\">NULL</span>;
    fn.path_to_textures = <span class=\"synConstant\">&quot;./textures&quot;</span>;

    dInitODE();
    world = dWorldCreate();
    dWorldSetGravity(world, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, -<span class=\"synConstant\">0.01</span>);

    ball = dBodyCreate(world);
    dMassSetZero(&amp;m1);
    dMassSetSphereTotal(&amp;m1, mass, radius);
    dBodySetMass(ball, &amp;m1);
    dBodySetPosition(ball, x0, y0, z0);

    dsSimulationLoop(argc, argv, <span class=\"synConstant\">352</span>, <span class=\"synConstant\">288</span>, &amp;fn);

    dWorldDestroy(world);
    dCloseODE();

    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>で、最後にコンパイルですが、ここではまりにはまった。まず、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE</pre><p>とやってみた。libodeとlibdrawstuffは、標準の/usr/local/libにあるので-Lでパスを指定する必要はないはず。それなのに、下のようなよくわからないコンパイルエラー。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>Undefined symbols for architecture x86_64:
  &#34;_glBegin&#34;, referenced from:
      drawConvexD(double*, unsigned int, double*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
      drawCapsule(float, float)in libdrawstuff.a(drawstuff.o)
      drawCylinder(float, float, float)in libdrawstuff.a(drawstuff.o)
      drawConvex(float*, unsigned int, float*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
      drawBox(float const*)in libdrawstuff.a(drawstuff.o)
      _dsDrawTriangleD in libdrawstuff.a(drawstuff.o)
      _dsDrawLine in libdrawstuff.a(drawstuff.o)
      ...
ld: symbol(s) not found for architecture x86_64
collect2: ld returned 1 exit status</pre><p>このエラーは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Lion 以降頻発するらしくWeb上にいろいろ情報があったのですが、なかなか解決しなかった・・・</p><p>で、数時間格闘したあと、最終的に下のように<span class=\"deco\" style=\"color:#FF0000;\">-frameworkで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GLUT\">GLUT</a>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OpenGL\">OpenGL</a>を指定することでコンパイルできる</span>ことが判明。<a href=\"http://www44.atwiki.jp/kencyo/pages/14.html\">&#x3053;&#x3053;&#x306E;&#x30B5;&#x30A4;&#x30C8;</a>が決め手になりました。64bitとか関係あったの？？？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE -framework GLUT -framework OpenGL</pre><p>もしくは、ODEのコマンドode-configを使って下のようにも書けます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp `ode-config --cflags --libs` -ldrawstuff -framework GLUT -framework OpenGL</pre><p>ode-configは、ライブラリ、ヘッダファイルのパスとインストールしたときの精度を返してくれるようです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; ode-config --cflags --libs
-I/usr/local/include -DdDOUBLE
-L/usr/local/lib -lode</pre><p>よーし、これで動作確認もできたし、本格的に物理シミュで遊ぶぞ！</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120807094656\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120807/20120807094656.png\" alt=\"f:id:aidiary:20120807094656p:image\" title=\"f:id:aidiary:20120807094656p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>
") (category ((term . "ロボティクス") (label . "ロボティクス"))) (author nil (name nil "aidiary"))) (entry nil (title nil " SPTKの使い方 (6) MFCCの抽出") (link ((href . "http://aidiary.hatenablog.com/entry/20120805/1343825329"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656810") (updated nil "2012-08-05T21:48:49+09:00") (summary nil "SPTKの使い方 (5)（2012/8/1）の続き。今回は、音声認識の特徴量としてよく使われるメル周波数ケプストラム係数 MFCC（2012/2/25）をSPTKで抽出してみました。使うコマンドは、mfccです*1。 x2x +sf < data.short| frame -l ") (content ((type . "html")) "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120801/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (5)</a>（2012/8/1）の続き。</p><p>今回は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>の特徴量としてよく使われるメル周波数ケプストラム係数 <a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">MFCC</a>（2012/2/25）をSPTKで抽出してみました。使うコマンドは、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">mfcc</span>です<a href=\"#f1\" name=\"fn1\" title=\"例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・\">*1</a>。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 &gt; data.mfc</pre><p>パラメータの意味は、</p>

<table>
    <tr>
    <td>-l</td>
    <td>640</td>
    <td>フレーム長は640サンプル</td>
    </tr>
    <tr>
    <td>-f</td>
    <td>16</td>
    <td>サンプリング周波数は16kHz</td>
    </tr>
    <tr>
    <td>-m</td>
    <td>12</td>
    <td>MFCCの次元は12次元</td>
    </tr>
    <tr>
    <td>-n</td>
    <td>20</td>
    <td>メルフィルタバンクのチャンネル数は20</td>
    </tr>
    <tr>
    <td>-a</td>
    <td>0.97</td>
    <td>プリエンファシス係数は0.97</td>
    </tr>
</table><p>です。まあ、-lと-fと-m以外はデフォルトでいいかな？mfccコマンドには、-c 22（リフタリング係数）というオプションもあったのですが、これは何だろう？私が認識していたMFCCの抽出手順は、</p>

<ol>
<li>プリエンファシスフィルタで波形の高域成分を強調する（-a）</li>
<li>窓関数をかけた後に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを求める（-l, -f）</li>
<li>振幅スペクトルにメルフィルタバンクをかけて圧縮する（-n）</li>
<li>上記の圧縮した数値列を信号とみなして離散コサイン変換する</li>
<li>得られたケプストラムの低次成分がMFCC（-m）</li>
</ol><p>だったのですが、リフタリングはどこでするのだろう・・・一番最後で低次成分をとるところなのかな？私の認識だとDCTしたあとに出てくる係数を単純に上から-m個とったもの（=低次成分のみ取り出す）がmfccだと思っているのだけど、それだと-cとはどこで使うのだろう？どなたか知ってたら教えてください。</p><p>先のコマンドを実行すると各フレームのMFCCが抽出されます。data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>はバイナリファイルなので文字列で出力する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトを書きました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np

<span class=\"synComment\"># print_mfcc.py</span>

<span class=\"synStatement\">if</span> len(sys.argv) != 3:
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python print_mfcc.py [mfcc_file] [m]</span>&quot;
    sys.exit()

mfccfile = sys.argv[1]
m = int(sys.argv[2])

mfcc = []
f = open(mfccfile, &quot;<span class=\"synConstant\">rb</span>&quot;)
<span class=\"synStatement\">while</span> True:
    b = f.read(4)
    <span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>;
    val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
    mfcc.append(val)
f.close()

mfcc = np.array(mfcc)
numframe = len(mfcc) / m

<span class=\"synStatement\">if</span> numframe * m != len(mfcc):
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: #mfcc:%d #frame:%d m:%d</span>&quot; % (len(mfcc), numframe, m)
    sys.exit(1)

mfcc = mfcc.reshape(numframe, m)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)):
    <span class=\"synStatement\">print</span> &quot;<span class=\"synSpecial\">\\t</span>&quot;.join(&quot;<span class=\"synConstant\">%.2f</span>&quot; % x <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> mfcc[i,])
</pre><p>第二引数は、MFCCの次元数です。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc data.mfc 12
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77
・・・</pre><p>こんな感じに各フレームのMFCCの12次元ベクトルが表示されます。各行がフレームです。</p><p> -Eオプションをつけると、MFCCに加えてエネルギーも出力することができます。MFCCの12次元+エネルギーで13次元ベクトルにするって設定はよく見かけますね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\ 
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 -E &gt; data.mfc</pre><p>表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py data.mfc 13
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65	10.51
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40	11.07
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27	11.42
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77	11.75</pre><p>13列目がエネルギーです。MFCCに比べて少し大きい値になってます。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>では、MFCC12次元+エネルギーの13次元ベクトルにさらに動的特徴量としてΔMFCCの13次元とΔΔMFCCの13次元を加えて39次元ベクトルにすることが多いと思いますが、これは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">delta</span>コマンドを使うとできます。SPTKのマニュアルのmfccコマンドのところにdeltaを使った例が書いてありました。これは別の機会に試してみます。</p><p>MFCCの抽出は、他にも<a href=\"http://htk.eng.cam.ac.uk/\">HTK</a>というツールキットのHCopyコマンドでもできました（<a href=\"http://shower.human.waseda.ac.jp/~m-kouki/pukiwiki_public/106.html\">MFCC&#x89E3;&#x6790;&#x306E;&#x30C4;&#x30FC;&#x30EB;</a>）が、SPTKの方が使うの簡単かも。というか、HCopyが出力するmfccのバイナリフォーマットがよくわからなかった・・・<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTK\">HTK</a>のマニュアルに書いてあるのかな？</p>
<div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary"))) (entry nil (title nil " Earth Mover's Distance (EMD)") (link ((href . "http://aidiary.hatenablog.com/entry/20120804/1344058475"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656812") (updated nil "2012-08-04T14:34:35+09:00") (summary nil "Earth Mover's Distance (EMD) について調べたことを整理しておきます。EMDは、ユークリッド距離のような距離尺度の一つで、二つの分布の間の距離を測ることができます。言語処理ではあまり聞いたことなかったのですが、画像処理や音声処理では比較的有名な距離尺度の") (content ((type . "html")) "<p><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth Mover&#39;s Distance (EMD) </a>について調べたことを整理しておきます。EMDは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離のような距離尺度の一つで、二つの分布の間の距離を測ることができます。言語処理ではあまり聞いたことなかったのですが、画像処理や音声処理では比較的有名な距離尺度のようです。</p><p>EMDが使える問題設定は下図のようになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804130722\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804130722.png\" alt=\"f:id:aidiary:20120804130722p:image\" title=\"f:id:aidiary:20120804130722p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは特徴量と重みの集合（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と呼ぶ）で与えられる分布Pと分布Qの間の距離</span>です。ここで、<span class=\"deco\" style=\"color:#FF0000;\">特徴量間では距離 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> が定義されている</span>のが前提です。特徴量がベクトルのときは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離、特徴量が確率分布のときはカルバック・ライブラー距離（情報量）などです。EMDは、特徴量の集合が2つ与えられたときに、1個1個の特徴量間の距離をもとに、特徴量集合間の距離を求められるんですね。これはすごい。</p><p>重みは具体的な応用によって使い方が変わりますが、その特徴量の重要度を表しています。たとえば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>だったら各棒が特徴量にあたり、棒の高さが重みにあたります。前に<a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a> (2009/10/3）で、画像の色の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>からHistogram Intersectionという距離を使いましたが、EMDを使って距離を求めることもできます。参考文献にあげたEMDの原論文は類似画像検索を対象にしています。</p><p>EMDなんて使わず、もっと単純に全特徴量のあらゆる組み合わせ間の距離の総和でもいいんじゃね？と思いましたけど、これだけだと重みを完全に無視していますね・・・重みが重要なんです！</p>

<div class=\"section\">
    <h4>考え方の基本は輸送問題</h4>
    <p>EMDの定義は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C7%C5%AC%B2%BD%CC%E4%C2%EA\">最適化問題</a>の1つの<span class=\"deco\" style=\"color:#FF0000;\">輸送問題（Transportation Problem）</span>の考え方に基づいています。なのでまずは輸送問題について簡単にまとめます。先の図において、Pの各場所P1, ... ,Pmには、重みの量だけ荷物が積まれているとします。そして、Qの各場所Q1, ... ,Qnには重みの量だけ格納できる倉庫があるとします。このとき、Pにある荷物をすべてQに運ぶ<a href=\"#f1\" name=\"fn1\" title=\"実際はすべてではなくQに入る分だけでOK\">*1</a>とき、どこからどこへどのくらい運ぶともっとも効率がよいかを求めるのが輸送問題です。</p><p>ここで、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送するコスト（距離）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> とし、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送する荷物量（フロー）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> と定義します。そして、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ運ぶのに要する仕事量を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D%20%2A%20f_%7Bij%7D\" alt=\"d_{ij} * f_{ij}\"/> と定義します。たとえば、距離が遠いところに大量の荷物を運ぶとそれだけ仕事量が増えるので直感とも一致します。このとき、総仕事量Wを下のように定義すると、W を最小化する <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> を求めればもっとも効率のよい運び方だとわかります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134057\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134057.png\" alt=\"f:id:aidiary:20120804134057p:image\" title=\"f:id:aidiary:20120804134057p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> は与えられるのが前提なので、<span class=\"deco\" style=\"color:#FF0000;\">最適化する変数は輸送量</span> <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> だけです。そして、輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> には下の4つの制約が加えられます。</p><p>(1) かならずPからQへ輸送する。逆方向はない。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134157\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134157.png\" alt=\"f:id:aidiary:20120804134157p:image\" title=\"f:id:aidiary:20120804134157p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
 <br />
(2) Piにある荷物以上は輸送できない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134355\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134355.png\" alt=\"f:id:aidiary:20120804134355p:image\" title=\"f:id:aidiary:20120804134355p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(3) <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a>にある倉庫の容量以上は荷物を受け付けられない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134420\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134420.png\" alt=\"f:id:aidiary:20120804134420p:image\" title=\"f:id:aidiary:20120804134420p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(4) 輸送量の上限は、荷物の総量か倉庫の総容量の小さい方</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134434\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134434.png\" alt=\"f:id:aidiary:20120804134434p:image\" title=\"f:id:aidiary:20120804134434p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>最後の条件は荷物の総量と倉庫の容量が違うときに必要です。荷物総量より倉庫の総容量が大きかったら全部輸送できるので輸送量の上限は荷物の総量となりますが、荷物が倉庫の量より多かったら全部輸送できないので輸送量の上限は倉庫の総容量になります。今回、取り上げる例題は荷物の総量と倉庫の総容量は同じとしています。</p><p>輸送問題の解き方は省略しますが、解くと最適な <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> が求まります。EMDはこの <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> を用いて下のように定義されます。輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> の合計で割っているのは、輸送量によってEMDのスケールが変わらないように正規化しているためですね。これはあとで具体例で確認してみます。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134804\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134804.png\" alt=\"f:id:aidiary:20120804134804p:image\" title=\"f:id:aidiary:20120804134804p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは輸送に必要な最適な仕事量が小さいほど二つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の距離は近い</span>という考え方なのでわりと自然な考え方だと思います。ただし、あらゆる特徴量間の組み合わせについて足し合わせが必要なので特徴量の数が多くなると計算量は非常に大きくなりそうです。そのため、特徴量の数が爆発しないようにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>と組み合わせて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を作る手法が提案されています。これは、後に紹介予定です。</p>

</div>
<div class=\"section\">
    <h4>EMDの定義がわかったところで具体例を解いてみます</h4>
    <p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804135712\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804135712.png\" alt=\"f:id:aidiary:20120804135712p:image\" title=\"f:id:aidiary:20120804135712p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>この例は、EMDの提案者の<a href=\"http://ai.stanford.edu/~rubner/emd/default.htm\">Rubner&#x3055;&#x3093;&#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;</a>に出てくる例題です。特徴量は3次元ベクトルで重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>で与えられています。特徴量の値が0から255の3次元ベクトルなので、分布Pが画像1のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>、分布Qが画像2のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>を表しているようです。この分布Pと分布QのEMDを計算してみます！</p>

</div>
<div class=\"section\">
    <h4>Rubnerの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</h4>
    <p>まずは、Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>のコードを使ってみます（<a href=\"http://ai.stanford.edu/~rubner/emd/example1.c\">example1.c</a>）。実行には、<a href=\"http://ai.stanford.edu/~rubner/emd/emd.c\">emd.c</a>と<a href=\"http://ai.stanford.edu/~rubner/emd/emd.h\">emd.h</a>が必要です。また、emd.hのfeature_tの定義を問題に合わせて書き換える必要があります。今回は、特徴量が3次元ベクトルなので</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">typedef</span> <span class=\"synType\">struct</span> { <span class=\"synType\">int</span> X,Y,Z; } feature_t;
</pre><p>と定義しています。emd.cのライブラリを使って上の例題を解くコードです。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;stdio.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;math.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;emd.h&quot;</span>

<span class=\"synComment\">/* ユークリッド距離 */</span>
<span class=\"synType\">float</span> dist(feature_t *F1, feature_t *F2) {
    <span class=\"synType\">int</span> dX = F1-&gt;X - F2-&gt;X;
    <span class=\"synType\">int</span> dY = F1-&gt;Y - F2-&gt;Y;
    <span class=\"synType\">int</span> dZ = F1-&gt;Z - F2-&gt;Z;
    <span class=\"synStatement\">return</span> sqrt(dX*dX + dY*dY + dZ*dZ);
}

<span class=\"synType\">int</span> main() {
    <span class=\"synComment\">/* 分布Pの特徴ベクトル */</span>
    feature_t f1[<span class=\"synConstant\">4</span>] = { {<span class=\"synConstant\">100</span>,<span class=\"synConstant\">40</span>,<span class=\"synConstant\">22</span>}, {<span class=\"synConstant\">211</span>,<span class=\"synConstant\">20</span>,<span class=\"synConstant\">2</span>}, {<span class=\"synConstant\">32</span>,<span class=\"synConstant\">190</span>,<span class=\"synConstant\">150</span>}, {<span class=\"synConstant\">2</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">100</span>} };
    <span class=\"synComment\">/* 分布Qの特徴ベクトル */</span>
     feature_t f2[<span class=\"synConstant\">3</span>] = { {<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>}, {<span class=\"synConstant\">50</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">80</span>}, {<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>} };
    <span class=\"synComment\">/* 分布Pの重み */</span>
    <span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">0.4</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span>, <span class=\"synConstant\">0.1</span> };
    <span class=\"synComment\">/* 分布Qの重み */</span>
    <span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">0.5</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span> };
    <span class=\"synComment\">/* 分布Pのシグネチャ */</span>
    signature_t s1 = { <span class=\"synConstant\">4</span>, f1, w1 };
    <span class=\"synComment\">/* 分布Qのシグネチャ */</span>
     signature_t s2 = { <span class=\"synConstant\">3</span>, f2, w2};

    <span class=\"synComment\">/* EMDを計算 */</span>
    <span class=\"synType\">float</span> e;
    e = emd(&amp;s1, &amp;s2, dist, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>);
    printf(<span class=\"synConstant\">&quot;emd = </span><span class=\"synSpecial\">%f\\n</span><span class=\"synConstant\">&quot;</span>, e);
    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>emd()関数に2つの分布の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と特徴量間の距離を計算する関数を指定しています。この実装では、重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4\">浮動小数</a>点になっています。合計するとどちらも1.0になるので荷物総量と倉庫の総容量は等しくなっています。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>emd = 160.542770</pre><p>よって、分布Pと分布Qの距離は、160.54とわかります。先に書いたようにEMDは、輸送量で正規化しているため下のように比率を保ったまま重みを変えても結果は同じになります。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink>    <span class=\"synComment\">/* 分布Pの重み */</span>
    <span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">4.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span>, <span class=\"synConstant\">1.0</span> };
    <span class=\"synComment\">/* 分布Qの重み */</span>
    <span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">5.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span> };
</pre>
</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>による実装</h4>
    <p>次は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で同じ例題を解いてみます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で輸送問題を解く関数は、<a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a>というライブラリに含まれていますが、標準では入っていないのでインストールします。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>install.packages<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;lpSolve&quot;</span><span class=\"synSpecial\">)</span>
</pre><p>以下のemd_sample.Rファイルを作成します。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>library<span class=\"synSpecial\">(</span>lpSolve<span class=\"synSpecial\">)</span>

<span class=\"synComment\"># ユークリッド距離</span>
euclid_dist <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">,</span> f2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>sqrt<span class=\"synSpecial\">(</span>sum<span class=\"synSpecial\">((</span>f1 - f2<span class=\"synSpecial\">)</span>^<span class=\"synConstant\">2</span><span class=\"synSpecial\">)))</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># EMDを計算</span>
emd <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synComment\"># lp.transport()を使うための準備</span>
    costs <span class=\"synStatement\">&lt;-</span> dist
    row.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&lt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w1<span class=\"synSpecial\">))</span>
    row.rhs <span class=\"synStatement\">&lt;-</span> w1
    col.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&gt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w2<span class=\"synSpecial\">))</span>
    col.rhs <span class=\"synStatement\">&lt;-</span> w2
    <span class=\"synComment\"># 輸送問題を解く</span>
    t <span class=\"synStatement\">&lt;-</span> lp.transport<span class=\"synSpecial\">(</span>costs<span class=\"synSpecial\">,</span> <span class=\"synConstant\">&quot;min&quot;</span><span class=\"synSpecial\">,</span> row.signs<span class=\"synSpecial\">,</span> row.rhs<span class=\"synSpecial\">,</span> col.signs<span class=\"synSpecial\">,</span> col.rhs<span class=\"synSpecial\">)</span>
    <span class=\"synComment\"># 最適な輸送量を取得</span>
    flow <span class=\"synStatement\">&lt;-</span> t$solution
    <span class=\"synComment\"># 仕事量を計算</span>
    work <span class=\"synStatement\">&lt;-</span> sum<span class=\"synSpecial\">(</span>flow * dist<span class=\"synSpecial\">)</span>
    <span class=\"synComment\"># 正規化してEMDを計算</span>
    e <span class=\"synStatement\">&lt;-</span> work / sum<span class=\"synSpecial\">(</span>flow<span class=\"synSpecial\">)</span>
    <span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>e<span class=\"synSpecial\">)</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># 特徴量</span>
f1 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">40</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">22</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">211</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">20</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">32</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">190</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">150</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>
f2 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">50</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">80</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>

<span class=\"synComment\"># 重み（要整数！）</span>
w1 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">)</span>
w2 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">5</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">)</span>

n1 = length<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>
n2 = length<span class=\"synSpecial\">(</span>f2<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>

<span class=\"synComment\"># 距離行列を作成</span>
dist = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> n1<span class=\"synSpecial\">,</span> n2<span class=\"synSpecial\">)</span>
<span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>i <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n1<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>j <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
        dist<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,</span> j<span class=\"synSpecial\">]</span> = euclid_dist<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,],</span> f2<span class=\"synSpecial\">[</span>j<span class=\"synSpecial\">,])</span>
    <span class=\"synSpecial\">}</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
e = emd<span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span>
cat<span class=\"synSpecial\">(</span>sprintf<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd = %f\\n&quot;</span><span class=\"synSpecial\">,</span> e<span class=\"synSpecial\">))</span>
</pre><p>この実装では、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を渡さずに、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>から計算した距離行列と重みを渡しています。lp.transport()が距離行列を受け付けるのでそれに合わせましたが、まあ、どっちでもよいと思います。Rを起動して以下のように打つと実行できます。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>&gt; source<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd_sample.R&quot;</span><span class=\"synSpecial\">)</span>
emd = <span class=\"synConstant\">160.542763</span>
</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>版と同じ結果になりました！ただ、距離行列の計算がRっぽい書き方でないので効率悪いかも。もっといい書き方があったら教えてください。</p>

</div>
<div class=\"section\">
    <h4>それでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>で書きたいんだよ！</h4>
    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>の<a href=\"http://www.scipy.org/\">SciPy</a>にはlp.transport()に対応する関数はないようです。他の最適化ライブラリ（<a href=\"http://openopt.org/Welcome\">openopt</a>や<a href=\"http://abel.ee.ucla.edu/cvxopt/\">cvxopt</a>）もざっと探しましたが見つけられませんでした。自分で書いてもよかったのですが、せっかくRの関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>からRのlp.transport()を呼び出してみます。</p><p><a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>は、Rの機能を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出せるようにする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>ライブラリです。使い方はやや複雑ですが、今回のように<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>になくてRにあるアルゴリズムもたくさんあるので使えるとはかどります。まあ、Rをラッパーしているのでちょっと複雑になっちゃうけどね。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects

<span class=\"synComment\"># Rのlp.transport()をインポート</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">euclid_dist</span>(feature1, feature2):
    &quot;&quot;&quot;<span class=\"synConstant\">ユークリッド距離を計算</span>&quot;&quot;&quot;
    <span class=\"synStatement\">if</span> len(feature1) != len(feature2):
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: calc euclid_dist: %d &lt;=&gt; %d</span>&quot; % (len(feature1), len(feature2))
        <span class=\"synStatement\">return</span> -1
    <span class=\"synStatement\">return</span> np.sqrt(np.sum((feature1 - feature2) ** 2))

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">emd</span>(dist, w1, w2):
    &quot;&quot;&quot;<span class=\"synConstant\">Rのtransport()関数を使ってEMDを計算</span>&quot;&quot;&quot;
    <span class=\"synComment\"># transport()の引数を用意</span>
    costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
                                 nrow=len(w1), ncol=len(w2),
                                 byrow=True)
    row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
    row_rhs = robjects.FloatVector(w1)
    col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
    col_rhs = robjects.FloatVector(w2)

    t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
    flow = t.rx2('<span class=\"synConstant\">solution</span>')

    dist = dist.reshape(len(w1), len(w2))
    flow = np.array(flow)
    work = np.sum(flow * dist)
    emd = work / np.sum(flow)
    <span class=\"synStatement\">return</span> emd

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    f1 = np.array([ [100, 40, 22], [211, 20, 2], [32, 190, 150], [2, 100, 100] ])
    f2 = np.array([ [0, 0, 0], [50, 100, 80], [255, 255, 255] ])

    <span class=\"synComment\"># 重みは自然数のみ</span>
    w1 = np.array([4, 3, 2, 1])
    w2 = np.array([5, 3, 2])

    n1 = len(f1)
    n2 = len(f2)

    <span class=\"synComment\"># 距離行列を作成</span>
    dist = np.zeros(n1 * n2)
    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(n1):
        <span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(n2):
            dist[i * n2 + j] = euclid_dist(f1[i], f2[j])

    <span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">emd =</span>&quot;, emd(dist, w1, w2)
</pre><p>実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python emd_sample.py
emd = 160.542762808</pre><p>となり、CやRと同じ結果が得られました。</p>

</div>
<div class=\"section\">
    <h4>おわりに</h4>
    <p>今回は、EMDについて調べたことをまとめてみました。できるだけ正確に書くようにしましたが、誤りもあるかもしれません。鵜呑みにしないで他の資料も当たってみてください。</p><p>あとで、EMDを類似楽曲検索という具体的な問題に応用してみる予定です。乞うご期待。</p>

</div>
<div class=\"section\">
    <h4>参考文献</h4>
    
<ul>
<li><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth mover&#39;s distance</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Wikipedia\">Wikipedia</a></li>
<li>Y. Rubner, C. Tomasi and L. J. Guibas: <a href=\"http://vision.stanford.edu/~rubner/papers/rubnerIjcv00.pdf\">The earth mover&#39;s distance as a metric for image retrieval</a> (PDF), International Journal of Computer Vision, 40(2), pp.99-121, 2000 - EMDの原論文。EMDを類似画像検索に適用しています。</li>
<li><a href=\"http://vision.stanford.edu/~rubner/emd/default.htm\">Code for the Earth Movers Distance (EMD) </a>- Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</li>
<li><a href=\"http://www.cs.huji.ac.il/~ofirpele/FastEMD/code/\">Fast Earth Mover&#39;s Distance (EMD) Code</a> - EMDを高速計算する実装</li>
<li>柳本, 大松: <a href=\"http://www.ai-gakkai.or.jp/jsai/conf/2007/data/pdf/100206.pdf\">Earth Mover&#39;s Distance&#x3092;&#x7528;&#x3044;&#x305F;&#x30C6;&#x30AD;&#x30B9;&#x30C8;&#x5206;&#x985E;</a>、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BF%CD%B9%A9%C3%CE%C7%BD\">人工知能</a>学会全国大会, 2007. - EMDの説明がわかりやすい。画像や音声の手法がテキストにも使えるんですね。</li>
<li><a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>のlpSolveのマニュアル。lp.transform()の詳しい仕様はここで。</li>
</ul>
</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">実際はすべてではなくQに入る分だけでOK</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary"))) (entry nil (title nil " SPTKの使い方 (5) フレーム分割") (link ((href . "http://aidiary.hatenablog.com/entry/20120801/1343825329"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656814") (updated nil "2012-08-01T21:48:49+09:00") (summary nil "SPTKの使い方 (4)（2012/7/16）の続き。今回は、音声波形をフレーム単位に分割するSPTKのframeコマンドを使ってみます。音声でフレームというと、信号の複数のサンプルを一定幅でまとめたものを指すことが多いと思います。前に実装した短時間フーリエ変換（2011/7/1") (content ((type . "html")) "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120716/1342414058\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (4)</a>（2012/7/16）の続き。</p><p>今回は、音声波形をフレーム単位に分割するSPTKの<span class=\"deco\" style=\"color:#FF0000;\">frame</span>コマンドを使ってみます。音声でフレームというと、信号の複数のサンプルを一定幅でまとめたものを指すことが多いと思います。前に実装した<a href=\"http://d.hatena.ne.jp/aidiary/20110716#1310824587\">&#x77ED;&#x6642;&#x9593;&#x30D5;&#x30FC;&#x30EA;&#x30A8;&#x5909;&#x63DB;</a>（2011/7/16）では、連続する波形からフレームを切り出し、窓関数をかけて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>というのをフレームを少しずつずらしながら繰り返し行うことでスペクトルの時間変化を求めました。</p><p>ここで、フレームを少しずつずらしながら音声を切り出すのがframeコマンドです。SPTKのマニュアルを見ると、引数で指定するのはフレームの長さLと周期Pになります。周期はフレームの中心をどれくらいずらしていくかを表すパラメータです。LよりPが小さいとオーバーラップしながらずらしていくことになります。</p><p>というわけで簡単なデータを作ってさっそく試してみます。結果がわかりやすいように0, 1, 2, 3, 4, 5, ...という連続した数値が入ったデータを作ります。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synComment\"># make_simple_data.py</span>
<span class=\"synPreProc\">import</span> struct
fp = open(&quot;<span class=\"synConstant\">simple.short</span>&quot;, &quot;<span class=\"synConstant\">wb</span>&quot;)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(100):
    fp.write(struct.pack(&quot;<span class=\"synConstant\">h</span>&quot;, i))
fp.close()
</pre><p>実行するとsimple.shortという0から99までのSHORT型データを書き込んだバイナリファイルができます。SPTKのdmpコマンドで見てみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; dmp +s simple.short
0       0
1       1
2       2
...
97      97
98      98
99      99</pre><p>OK。さっそくこのデータからフレーム長L=10、フレーム周期P=5でフレームを抽出してみます。frameの入力はfloat型しかダメなのでx2xでSHORT型からFLOAT型に変換してます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; simple.short | frame -l 10 -p 5  &gt; simple.frame
dmp -l 10 +f simple.frame</pre><p>dmpコマンドの-lオプションでフレーム長を渡すとフレーム単位でインデックスを割り振ってくれるため少し見やすくなります。もう少し整形すると</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink> 0 frame:  0  0  0  0  0  0  1  2  3  4
 1 frame:  0  1  2  3  4  5  6  7  8  9
 2 frame:  5  6  7  8  9 10 11 12 13 14
 3 frame: 10 11 12 13 14 15 16 17 18 19
 4 frame: 15 16 17 18 19 20 21 22 23 24
                    ...
18 frame: 85 86 87 88 89 90 91 92 93 94
19 frame: 90 91 92 93 94 95 96 97 98 99</pre><p>このようにフレームが並んでいることがわかります。たしかにフレーム長は10でフレーム周期の5ずつずらしながらフレームを抽出していることがわかります。また、元のサンプル数が100で5ずつずらしながらフレームを抽出しているので全部で100/5=20フレームあることもわかります。</p>

<div class=\"section\">
    <h4>フレームを切り出す</h4>
    <p>次に、波形から任意の位置のフレームを切り出してみます。波形から任意のサンプルを切り出すコマンドは<a href=\"http://d.hatena.ne.jp/aidiary/20120704#1341409042\">bcut&#x3067;&#x3057;&#x305F;</a>（2012/7/4）が、<span class=\"deco\" style=\"color:#FF0000;\">bcutに-lオプションを与えると単位がフレームになります</span>。たとえば、18フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 18 -e 18 &lt; data.frame | dmp +f
0       85
1       86
2       87
3       88
4       89
5       90
6       91
7       92
8       93
9       94</pre><p>2から4フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 2 -e 4 &lt; data.frame | dmp +f
0       5
1       6
2       7
3       8
...
27      22
28      23
29      24</pre><p>となります。</p>

</div>
<div class=\"section\">
    <h4>指定したフレームのスペクトルを求める</h4>
    <p>では、frame、bcutを使って音声の任意のフレームのスペクトルを求めてみます。音声はSPTKに付属のサンプル音声data.short（青い植木鉢）で試します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | fftr -l 512 -A &gt; data.fft</pre><p>このようにコマンドをパイプでつなげるだけなのでマジ簡単です。前から順に</p>

<ol>
<li>data.shortをSHORT型からFLOAT型に変換</li>
<li>フレーム長400サンプル、フレーム周期80サンプルでフレームを抽出</li>
<li>フレーム長を400サンプルとし、65フレーム目を切り出す</li>
<li>入力のフレーム長を400サンプル、出力のフレーム長を512サンプルとする窓関数をかける</li>
<li>フレーム長512サンプルで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを出力</li>
</ol><p>となります。さっそく、data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>を<a href=\"http://d.hatena.ne.jp/aidiary/20120716#1342414058\">&#x524D;&#x56DE;</a>（2012/7/16）作ったplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyで表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python plot_fft.py data.fft 512 16000</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212608\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212608.png\" alt=\"f:id:aidiary:20120801212608p:image\" title=\"f:id:aidiary:20120801212608p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>縦軸は対数にすることが多いのでplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyの下の部分を書き換えてみます。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink>plot(freqList[:N/2], fft[:N/2])
            ↓
plot(freqList[:N/2], np.log2(fft[:N/2]))
</pre><p>実行すると対数スペクトルになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212614\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212614.png\" alt=\"f:id:aidiary:20120801212614p:image\" title=\"f:id:aidiary:20120801212614p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>

</div>
<div class=\"section\">
    <h4>SPTKで対数スペクトルを求める</h4>
    <p>SPTKにも対数スペクトルを求める<span class=\"deco\" style=\"color:#FF0000;\">spec</span>コマンドとそれを表示する<span class=\"deco\" style=\"color:#FF0000;\">glogsp</span>コマンドがあるので試してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | \\
spec -l 512 | glogsp -l 512 -x 8 -p 2 | xgr</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801214054\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801214054.png\" alt=\"f:id:aidiary:20120801214054p:image\" title=\"f:id:aidiary:20120801214054p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>先の結果と同じです。縦軸のスケールが違うけどこれは特に問題ないのかな？frameコマンドは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>以外にもMFCCやLPCの抽出でも頻繁に使うのでここで慣れておきたいな。</p>

</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary"))))) ("はてなブログに移行しました" "<p>はてなダイアリーからはてなブログに移行しました。</p>" "http://aidiary.hatenablog.com/entry/20121222/1356153770" (20693 17322) old 1 nil nil ((title nil "はてなブログに移行しました") (link ((href . "http://aidiary.hatenablog.com/entry/20121222/1356153770"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096659843") (updated nil "2012-12-22T14:22:50+09:00") (summary nil "はてなダイアリーからはてなブログに移行しました。 ") (content ((type . "html")) "<p>はてなダイアリーからはてなブログに移行しました。</p>
") (author nil (name nil "aidiary")))) ("類似楽曲検索システムを作ろう" "<p>もう1年以上かけて音声信号処理の勉強をしてきました（<a href=\"http://d.hatena.ne.jp/aidiary/20110514/1305377659\">Python&#x3067;&#x97F3;&#x58F0;&#x4FE1;&#x53F7;&#x51E6;&#x7406;</a>）。ここらで具体的なアプリケーションとして類似楽曲検索の実験をしてみたのでレポートをまとめておきます。言語は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>です。</p><p>前に</p>
<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;&#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x3092;&#x4F5C;&#x308D;&#x3046;</a>（2009/10/3）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）</li>
</ul><p>という画像の類似検索に関するエントリを書きましたが、今回は画像ではなく<span class=\"deco\" style=\"color:#FF0000;\">音楽を対象に</span>類似検索をやってみたいと思います！</p><p>今回作る類似楽曲検索システムは、従来からよくあるアーティスト名や曲名などテキストで検索するシステムや購買履歴をもとにオススメする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%A8%C4%B4%A5%D5%A5%A3%A5%EB%A5%BF%A5%EA%A5%F3%A5%B0\">協調フィルタリング</a>ベースのシステムとは異なります。WAVEファイルやMP3ファイルなどの<span class=\"deco\" style=\"color:#FF0000;\">音楽波形そのものを入力とする</span>のが特徴です。たとえば、「<span class=\"deco\" style=\"color:#FF0000;\">具体的なアーティストや曲名は知らないけれど、この曲とメロディや雰囲気が似た曲がほしいな</span>」なんていうときに便利に使えるシステムです。</p><p>この研究分野は、<span class=\"deco\" style=\"color:#FF0000;\">Music Information Retrieval (MIR)</span> と呼ばれています。私自身、アーティストによって曲を買うことはほとんどないので、以前からこういうシステムがほしいなぁと思ってました。</p><p>とりあえず実験結果だけ見たい方は下のページにあります。1位がクエリの楽曲で似ている順に上位10件を出力しました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTML5\">HTML5</a>でオーディオ断片を埋め込んだので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>だと音声で確認できます。</p>
<ul>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
</ul><p>どうでしょう？似てますかね？</p>
<div class=\"section\">
<h4>概要</h4>
<p>今回の実験で参考にした資料は、</p>
<ul>
<li>Pampalk, E., <a href=\"http://www.ofai.at/~elias.pampalk/publications/pampalk06thesis.pdf\">Computational Models of Music Similarity and their Application in Music Information Retrieval</a> (PDF), Doctoral Thesis, Vienna University of Technology, Austria, March 2006.</li>
</ul>
<ul>
<li>Logan, B. and Salomon, A., <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.9.9328\">A Content-based Music Similarity Function</a>, Technical report, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Compaq\">Compaq</a> Cambridge Research Lab, 2001.</li>
</ul><p>という2つの論文です。上の論文は、類似楽曲検索の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B5%A1%BC%A5%D9%A5%A4\">サーベイ</a>論文としてよくまとまっています。今回はPampalkさんの論文で紹介されているLoganさんの論文の手法を実際に試してみました。</p><p>Loganさんが提案したのは音声の局所特徴量を用いたアプローチで<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）と考え方がよく似ています。類似画像検索だとSIFTやSURFといった局所特徴量を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してVisual wordsを作りました。そして、各画像をVisual wordsの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>間の距離を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>インターセクションで求めました。</p><p>今回の音楽の場合は<a href=\"http://d.hatena.ne.jp/aidiary/20120225#1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;</a>（2012/2/25）、略して<span class=\"deco\" style=\"color:#FF0000;\">MFCC</span>というスペクトル特徴量を使います。各楽曲から得られるMFCCベクトル集合を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して楽曲を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の集合で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>集合間の距離を<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover's Distance</a>（2012/8/4）で求めます。<span class=\"deco\" style=\"color:#FF0000;\">EMDが近い楽曲が互いに類似した楽曲</span>となるわけです。</p><p>コンテンツの表現方法や使用する距離の定義が多少違いますが、アプローチはよく似ています。というわけで論文にそって早速試してみます！</p>
</div>
<div class=\"section\">
<h4>MP3ファイルの準備</h4>
<p>類似楽曲検索なのでまず楽曲ファイルが必要です。最初、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E9%A5%B4%A5%F3%A5%AF%A5%A8%A5%B9%A5%C8\">ドラゴンクエスト</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%A1%A5%A4%A5%CA%A5%EB%A5%D5%A5%A1%A5%F3%A5%BF%A5%B8%A1%BC\">ファイナルファンタジー</a>のサウンドトラックで試してみたのですが、どうもよい結果が得られませんでした。いろいろ試したところインストだけの曲よりボーカルが入ってた方がよい結果になるみたいです。</p><p>私自身はボーカル入りのCDはあんまり持ってなかったので、妹の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>を<del datetime=\"2012-10-14T19:45:06+09:00\">パクって</del>借りて、500曲くらいのボーカル曲のリストを作りました。そんなわけで、検索結果の曲のすべてが私の趣味というわけではないのであしからず（笑）500曲のMP3ファイルは当然ながら公開できないのでお手持ちの曲でぜひ試してみてください。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>はアルバム名やアーティスト名で階層構造になっていますが、ここでは簡単のためすべての曲をmp3というフォルダにまとめました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>で買った曲などMP3以外のフォーマットがある場合は、MP3への変換が必要です。やり方はググってください。</p>
</div>
<div class=\"section\">
<h4>MFCCの抽出</h4>
<p>まず、MP3ファイルからスペクトル特徴量の<span class=\"deco\" style=\"color:#FF0000;\">メル周波数ケプストラム係数（MFCC）</span>を抽出します。MFCCはスペクトルの概形を表すパラメータなので音色を表すと考えてよいと思います。MFCCに関しては、前に書いた記事を参考にしてください。</p>
<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;&#xFF08;MFCC&#xFF09;</a>（2012/2/25）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (6) MFCC&#x306E;&#x62BD;&#x51FA;</a>（2012/8/5）</li>
</ul><p>以下が、指定したMP3ディレクトリ（mp3）にあるすべてのMP3ファイルからMFCCを抽出してMFCCディレクトリ（mfcc）に保存する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトです。音声フォーマットの変換に<a href=\"http://sox.sourceforge.net\">sox</a>と<a href=\"http://lame.sourceforge.net\">lame</a>、波形の切り出し、MFCCの抽出に<a href=\"http://sp-tk.sourceforge.net\">SPTK</a>というツールを使っています。両方ともインストールしないと動きません。SPTKのインストールは</p>
<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120701/1341126474\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (1) &#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x30FB;&#x6CE2;&#x5F62;&#x63CF;&#x753B;&#x30FB;&#x97F3;&#x58F0;&#x518D;&#x751F;</a>（2012/7/1）</li>
</ul><p>という記事にまとめました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys
<span class=\"synComment\"># mp3_to_mfcc.py</span>
<span class=\"synComment\"># usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>
<span class=\"synComment\"># ディレクトリ内のMP3ファイルからMFCCを抽出する</span>
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">mp3ToRaw</span>(mp3File, rawFile):
<span class=\"synComment\"># mp3を16kHz, 32bitでリサンプリング</span>
os.system(&quot;<span class=\"synConstant\">lame --resample 16 -b 32 -a '%s' temp.mp3</span>&quot; % mp3File)
<span class=\"synComment\"># mp3をwavに変換</span>
os.system(&quot;<span class=\"synConstant\">lame --decode temp.mp3 temp.wav</span>&quot;)
<span class=\"synComment\"># wavをrawに変換</span>
os.system(&quot;<span class=\"synConstant\">sox temp.wav %s</span>&quot; % rawFile)
os.remove(&quot;<span class=\"synConstant\">temp.mp3</span>&quot;)
os.remove(&quot;<span class=\"synConstant\">temp.wav</span>&quot;)
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcNumSample</span>(rawFile):
<span class=\"synComment\"># 1サンプルはshort型（2byte）なのでファイルサイズを2で割る</span>
filesize = os.path.getsize(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
numsample = filesize / 2
<span class=\"synStatement\">return</span> numsample
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">extractCenter</span>(inFile, outFile, period):
<span class=\"synComment\"># 波形のサンプル数を求める</span>
numsample = calcNumSample(inFile)
fs = 16000
center = numsample / 2
start = center - fs * period
end = center + fs * period
<span class=\"synComment\"># period*2秒未満の場合は範囲を狭める</span>
<span class=\"synStatement\">if</span> start &lt; 0: start = 0
<span class=\"synStatement\">if</span> end &gt; numsample - 1: end = numsample - 1
<span class=\"synComment\"># SPTKのbcutコマンドで切り出す</span>
os.system(&quot;<span class=\"synConstant\">bcut +s -s %d -e %d &lt; '%s' &gt; '%s'</span>&quot; <span class=\"synSpecial\">\\</span>
% (start, end, &quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile))
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcMFCC</span>(rawFile, mfccFile):
<span class=\"synComment\"># サンプリング周波数: 16kHz</span>
<span class=\"synComment\"># フレーム長: 400サンプル</span>
<span class=\"synComment\"># シフト幅  : 160サンプル</span>
<span class=\"synComment\"># チャンネル数: 40</span>
<span class=\"synComment\"># MFCC: 19次元 + エネルギー</span>
os.system(&quot;<span class=\"synConstant\">x2x +sf &lt; '%s' | frame -l 400 -p 160 | mfcc -l 400 -f 16 -n 40 -m 19 -E &gt; '%s'</span>&quot;
% (rawFile, mfccFile))
<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
<span class=\"synStatement\">if</span> len(sys.argv) != 4:
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>&quot;
sys.exit()
mp3Dir = sys.argv[1]
mfccDir = sys.argv[2]
rawDir = sys.argv[3]
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(mfccDir):
os.mkdir(mfccDir)
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(rawDir):
os.mkdir(rawDir)
<span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mp3Dir):
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mp3</span>&quot;): <span class=\"synStatement\">continue</span>
mp3File = os.path.join(mp3Dir, file)
mfccFile = os.path.join(mfccDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.mfc</span>&quot;))
rawFile = os.path.join(rawDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.raw</span>&quot;))
<span class=\"synStatement\">try</span>:
<span class=\"synComment\"># MP3を変換</span>
mp3ToRaw(mp3File, &quot;<span class=\"synConstant\">temp.raw</span>&quot;)
<span class=\"synComment\"># 中央の30秒だけ抽出してrawFileへ</span>
extractCenter(&quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile, 15)
<span class=\"synComment\"># MFCCを計算</span>
calcMFCC(rawFile, mfccFile)
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%s =&gt; %s</span>&quot; % (mp3File, mfccFile)
<span class=\"synComment\"># 後片付け</span>
os.remove(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
<span class=\"synStatement\">except</span>:
<span class=\"synStatement\">continue</span>
</pre><p>曲全体からMFCCを抽出すると処理が重すぎるので、Pampalkさんの論文に従って、曲の中心の30秒間だけを対象にしました。本当は、画像の局所特徴量SIFTのようにその曲の特徴をよく表す部分（サビ？）からとりたかったのだけどどうやればいいんだろう。</p><p>MFCCファイルは、SPTKのバイナリ形式になっています。前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">print_mfcc.py</a>というスクリプトでダンプできます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>を20次元ずつダンプしてみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py mfcc/愛は勝つ.mfc 20
-14.77  -8.78   -6.70   ...    3.45    7.37    1.44    2.80    22.29
-13.84  -9.71   -3.28   ...    -0.82   6.72    2.70    1.92    22.85
-15.45  -12.54  -7.64   ...    -5.64   3.45    2.31    6.03    22.67
-14.64  -10.72  -4.96   ...    -5.24   3.64    0.71    5.49    22.78</pre><p>各行が1フレームの20次元MFCCベクトル（19次元+パワー）です。サンプリング周波数16kHz、シフト幅160サンプル、30秒間の楽曲なので、30 x 16000 / 160 = 3000フレームあります。つまり、「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>」の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>ファイルは<span class=\"deco\" style=\"color:#FF0000;\">20次元のMFCCベクトルが3000行もあります</span>。1曲を表すベクトルとしては大きすぎですね・・・</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214857\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214857.png\" alt=\"f:id:aidiary:20121015214857p:image\" title=\"f:id:aidiary:20121015214857p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p>
</div>
<div class=\"section\">
<h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の計算</h4>
<p>1曲を表す特徴ベクトルが、20次元ベクトル3000個（20x3000 = 60000個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>）では大きすぎるのでもう少し情報を圧縮します。こんなときに使えるのが前に紹介した<a href=\"http://d.hatena.ne.jp/aidiary/20120813/1344853878\">&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x91CF;&#x5B50;&#x5316;</a>（2012/8/13）というアルゴリズムです。ようは3000個のベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してよく似たベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>にまとめてしまいます。そして各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>と仮定してその平均ベクトルと分散共分散行列を求め、それをあらたな特徴量とします。式で表すと楽曲Pの特徴量は、<br />
<center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013175637\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013175637.png\" alt=\"f:id:aidiary:20121013175637p:image\" title=\"f:id:aidiary:20121013175637p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
となります。mは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の数です。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>にはよく使われる<span class=\"deco\" style=\"color:#FF0000;\">k-means</span>を用いました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数は上の論文に合わせて16としました。つまり、3000個のベクトル集合をたった16個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均ベクトルは20次元ベクトル、分散共分散行列は20x20次元の行列になります。つまり、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>(20次元平均ベクトル + 20x20次元の分散共分散行列) x 16クラスタ = 6720個の浮動小数点数</pre><p>まで情報を圧縮できます。実際は、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均と分散のほかに重み（その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されたベクトルの数）の情報も加えるので正確には6736個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>になります。60000個に比べたらずいぶん減ります。下のスクリプトは、各局のMFCCファイルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルに変換するスクリプトです。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster
<span class=\"synComment\"># mfcc_to_signature.py</span>
<span class=\"synComment\"># usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>
<span class=\"synComment\"># 各曲のMFCCをシグネチャに変換する</span>
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadMFCC</span>(mfccFile, m):
&quot;&quot;&quot;<span class=\"synConstant\">MFCCをロードする、mはMFCCの次元数</span>&quot;&quot;&quot;
mfcc = []
fp = open(mfccFile, &quot;<span class=\"synConstant\">rb</span>&quot;)
<span class=\"synStatement\">while</span> True:
b = fp.read(4)
<span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>
val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
mfcc.append(val)
fp.close()
<span class=\"synComment\"># 各行がフレームのMFCC</span>
<span class=\"synComment\"># numFrame行、m列の行列形式に変換</span>
mfcc = np.array(mfcc)
numFrame = len(mfcc) / m
mfcc = mfcc.reshape(numFrame, m)
<span class=\"synStatement\">return</span> mfcc
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">vq</span>(mfcc, k):
&quot;&quot;&quot;<span class=\"synConstant\">mfccのベクトル集合をk個のクラスタにベクトル量子化</span>&quot;&quot;&quot;
codebook, destortion = scipy.cluster.vq.kmeans(mfcc, k)
code, dist = scipy.cluster.vq.vq(mfcc, codebook)
<span class=\"synStatement\">return</span> code
<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
<span class=\"synStatement\">if</span> len(sys.argv) != 3:
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>&quot;
sys.exit()
mfccDir = sys.argv[1]
sigDir  = sys.argv[2]
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(sigDir):
os.mkdir(sigDir)
<span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mfccDir):
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mfc</span>&quot;): <span class=\"synStatement\">continue</span>
mfccFile = os.path.join(mfccDir, file)
sigFile = os.path.join(sigDir, file.replace(&quot;<span class=\"synConstant\">.mfc</span>&quot;, &quot;<span class=\"synConstant\">.sig</span>&quot;))
<span class=\"synStatement\">print</span> mfccFile, &quot;<span class=\"synConstant\">=&gt;</span>&quot;, sigFile
fout = open(sigFile, &quot;<span class=\"synConstant\">w</span>&quot;)
<span class=\"synComment\"># MFCCをロード</span>
<span class=\"synComment\"># 各行がフレームのMFCCベクトル</span>
mfcc = loadMFCC(mfccFile, 20)
<span class=\"synComment\"># MFCCをベクトル量子化してコードを求める</span>
code = vq(mfcc, 16)
<span class=\"synComment\"># 各クラスタのデータ数、平均ベクトル、</span>
<span class=\"synComment\"># 共分散行列を求めてシグネチャとする</span>
<span class=\"synStatement\">for</span> k <span class=\"synStatement\">in</span> range(16):
<span class=\"synComment\"># クラスタkのフレームのみ抽出</span>
frames = np.array([mfcc[i] <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)) <span class=\"synStatement\">if</span> code[i] == k])
<span class=\"synComment\"># MFCCの各次元の平均をとって平均ベクトルを求める</span>
m = np.apply_along_axis(np.mean, 0, frames)  <span class=\"synComment\"># 0は縦方向</span>
<span class=\"synComment\"># MFCCの各次元間での分散・共分散行列を求める</span>
sigma = np.cov(frames.T)
<span class=\"synComment\"># 重み（各クラスタのデータ数）</span>
w = len(frames)
<span class=\"synComment\"># このクラスタの特徴量をフラット形式で出力</span>
<span class=\"synComment\"># 1行が重み1個、平均ベクトル20個、分散・共分散行列400個の計421個の数値列</span>
features = np.hstack((w, m, sigma.flatten()))
features = [str(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> features]
fout.write(&quot;<span class=\"synConstant\"> </span>&quot;.join(features) + &quot;<span class=\"synSpecial\">\\n</span>&quot;)
fout.close()
</pre><p>出力である楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルは、1行に (重み、20次元平均ベクトル、20x20次元の分散・共分散行列) の421個の数値が並びます。それが、16<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>分あるので16行のファイルです。</p>
</div>
<div class=\"section\">
<h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離と楽曲間の距離</h4>
<p>次に2つの楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離を求めます。これには、前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover's Distance</a>（2012/8/4）を使います。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214928\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214928.png\" alt=\"f:id:aidiary:20121015214928p:image\" title=\"f:id:aidiary:20121015214928p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>左側が楽曲Pの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>で右側が楽曲Qの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>です。楽曲Pと楽曲Qの距離を求めるのが課題です。EMDの詳しい解説は、<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover's Distance</a>（2012/8/4）を参照してください。先のページのEMD具体例では、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>が単純な<span class=\"deco\" style=\"color:#FF0000;\">ベクトル</span>なので、各特徴量間の距離に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えました。ですが、今回は各特徴量がベクトルではなく、<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a></span>になっています。というわけで単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えません・・・</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離がはかれる指標として<span class=\"deco\" style=\"color:#FF0000;\">カルバック・ライブラー情報量（Kullback Leibler Divergence）</span>というのがあります。<a href=\"http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\">Kullback-Leibler divergence - Wikipedia</a>によると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>N1とN2（それぞれ平均ベクトル、分散共分散行列がある）の間のカルバック・ライブラー情報量の定義は、</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190723\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190723.png\" alt=\"f:id:aidiary:20121013190723p:image\" title=\"f:id:aidiary:20121013190723p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>です。うう、目がくらむぅ。kは平均ベクトルの次元数です。一般的にカルバック・ライブラー情報量は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が成り立ちません。つまり、<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N1%7C%7CN2%29\" alt=\"D_{KL}(N1||N2)\"/>と<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N2%7C%7CN1%29\" alt=\"D_{KL}(N2||N1)\"/>で異なる値が出てきます。そのため、上の式をそのまま使うと楽曲Pからみた楽曲Qの距離と楽曲Qからみた楽曲Pの距離が違ってきます。これでは使いにくい。そのため、論文では<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量</span>を使っています<a href=\"#f1\" name=\"fn1\" title=\"ただ、先の論文には誤りがあるようです。traceがぬけているため結果がスカラーになりません。\">*1</a>。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190948\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190948.png\" alt=\"f:id:aidiary:20121013190948p:image\" title=\"f:id:aidiary:20121013190948p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>単純にひっくり返した距離も足し合わせているだけですね。これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が保たれます。カルバック・ライブラー情報量は、<a href=\"http://rss.acs.unt.edu/Rdoc/library/monomvn/html/kl.norm.html\">R&#x306B;&#x306F;&#x95A2;&#x6570;&#x304C;&#x7528;&#x610F;&#x3055;&#x308C;&#x3066;&#x3044;&#x308B;</a>のですが、SciPy/NumPyにはないので自作します。カルバック・ライブラー情報量の定義式において定数倍や定数項は、距離の比較では必要ないので省略しました。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%D4%CE%F3%BC%B0\">行列式</a>の項は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量を使うと打ち消し合って消えるので省略しました。trは、traceの略で行列の対角成分の和です。スクリプトでは、diag()で対角成分を取り出して、sum()で合計しています。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">KLDiv</span>(mu1, S1, mu2, S2):
&quot;&quot;&quot;<span class=\"synConstant\">正規分布間のカルバック・ライブラー情報量</span>&quot;&quot;&quot;
<span class=\"synComment\"># 逆行列を計算</span>
<span class=\"synStatement\">try</span>:
invS1 = np.linalg.inv(S1)
<span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
<span class=\"synStatement\">raise</span>;
<span class=\"synStatement\">try</span>:
invS2 = np.linalg.inv(S2)
<span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
<span class=\"synStatement\">raise</span>;
<span class=\"synComment\"># KL Divergenceを計算</span>
t1 = np.sum(np.diag(np.dot(invS2, S1)))
t2 = (mu2 - mu1).transpose()
t3 = mu2 - mu1
<span class=\"synStatement\">return</span> t1 + np.dot(np.dot(t2, invS2), t3)
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">symKLDiv</span>(mu1, S1, mu2, S2):
&quot;&quot;&quot;<span class=\"synConstant\">対称性のあるカルバック・ライブラー情報量</span>&quot;&quot;&quot;
<span class=\"synStatement\">return</span> 0.5 * (KLDiv(mu1, S1, mu2, S2) + KLDiv(mu2, S2, mu1, S1))
</pre><p>これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離が定義できたのでEMDを計算する関数も作ります。<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover's Distance</a>（2012/8/4）にも書きましたが、RにはEMDの輸送問題を解く関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使ってRの関数を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出しました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects
<span class=\"synComment\"># Rで輸送問題を解くライブラリ</span>
<span class=\"synComment\"># Rのデフォルトパッケージではないのでインストールが必要</span>
<span class=\"synComment\"># Rでinstall.packages(&quot;lpSolve&quot;)</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcEMD</span>(sigFile1, sigFile2):
<span class=\"synComment\"># シグネチャをロード</span>
sig1 = loadSignature(sigFile1)
sig2 = loadSignature(sigFile2)
<span class=\"synComment\"># 距離行列を計算</span>
numFeatures = sig1.shape[0]                 <span class=\"synComment\"># クラスタの数</span>
dist = np.zeros(numFeatures * numFeatures)  <span class=\"synComment\"># 距離行列（フラット形式）</span>
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(numFeatures):
mu1 = sig1[i, 1:21].reshape(20, 1)   <span class=\"synComment\"># 縦ベクトル</span>
S1 = sig1[i, 21:421].reshape(20, 20)
<span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(numFeatures):
mu2 = sig2[j, 1:21].reshape(20, 1)
S2 = sig2[j, 21:421].reshape(20, 20)
<span class=\"synComment\"># 特徴量iと特徴量j間のKLダイバージェンスを計算</span>
dist[i * numFeatures + j] = symKLDiv(mu1, S1, mu2, S2)
<span class=\"synComment\"># シグネチャの重み（0列目）を取得</span>
w1 = sig1[:,0]
w2 = sig2[:,0]
<span class=\"synComment\"># 重みと距離行列からEMDを計算</span>
<span class=\"synComment\"># transport()の引数を用意</span>
costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
nrow=len(w1), ncol=len(w2),
byrow=True)
row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
row_rhs = robjects.FloatVector(w1)
col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
col_rhs = robjects.FloatVector(w2)
t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
flow = t.rx2('<span class=\"synConstant\">solution</span>')
dist = dist.reshape(len(w1), len(w2))
flow = np.array(flow)
work = np.sum(flow * dist)
emd = work / np.sum(flow)
<span class=\"synStatement\">return</span> emd
</pre><p>これでようやく二つの楽曲間の距離を測れるようになりました。次は、与えたクエリと距離が近い楽曲を検索する部分を作ります。</p>
</div>
<div class=\"section\">
<h4>類似楽曲検索</h4>
<p>今回は検索対象の楽曲が500曲程度なので単純な線形探索を使いました。クエリの楽曲と500曲全部の間でEMDを計算して、距離が近い順にランキングを出力します。ついでに<a href=\"http://eyed3.nicfit.net/\">eyeD3</a>というMP3ファイルからタグ情報を読み書きするライブラリを用いて、MP3ファイルからアーティスト名を読み取って出力してみました。また、検索結果をテキストで出力しただけでは検証しにくいので、オーディオタグを埋め込んだHTMLも合わせて出力しています。</p><p>先ほどの3つの関数（KLDiv、symKLDiv、calcEMD）は省略しているので下のスクリプトに追加してください。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects
<span class=\"synPreProc\">from</span> collections <span class=\"synPreProc\">import</span> defaultdict
<span class=\"synComment\"># mir.py</span>
<span class=\"synComment\"># usage: python mir.py [sig file] [sig dir] [html file]</span>
<span class=\"synComment\"># sig file  : クエリ楽曲のシグネチャファイル</span>
<span class=\"synComment\"># sig dir   : 検索対象のシグネチャファイルのディレクトリ</span>
<span class=\"synComment\"># html file : 検索結果を出力するHTMLファイル</span>
<span class=\"synComment\"># 引数で指定したシグネチャファイルに近い</span>
<span class=\"synComment\"># 上位N件の楽曲を出力する</span>
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadSignature</span>(sigFile):
&quot;&quot;&quot;<span class=\"synConstant\">シグネチャファイルをロード</span>&quot;&quot;&quot;
mat = []
fp = open(sigFile, &quot;<span class=\"synConstant\">r</span>&quot;)
<span class=\"synStatement\">for</span> line <span class=\"synStatement\">in</span> fp:
line = line.rstrip()
mat.append([float(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> line.split()])
fp.close()
<span class=\"synStatement\">return</span> np.array(mat)
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">getArtist</span>(mp3Path):
&quot;&quot;&quot;<span class=\"synConstant\">MP3ファイルからアーティストを取得</span>&quot;&quot;&quot;
<span class=\"synPreProc\">import</span> eyeD3
<span class=\"synStatement\">try</span>:
tag = eyeD3.Tag()
tag.link(mp3Path)
artist = tag.getArtist()
<span class=\"synStatement\">except</span>:
artist = &quot;<span class=\"synConstant\">None</span>&quot;
<span class=\"synComment\"># 空白のとき</span>
<span class=\"synStatement\">if</span> artist == &quot;&quot;: artist = &quot;<span class=\"synConstant\">None</span>&quot;
<span class=\"synStatement\">return</span> artist
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">makeHTML</span>(ranking, htmlFile, N=10):
&quot;&quot;&quot;<span class=\"synConstant\">ランキングをHTML形式で出力</span>&quot;&quot;&quot;
<span class=\"synPreProc\">import</span> codecs
fout = codecs.open(htmlFile, &quot;<span class=\"synConstant\">w</span>&quot;, &quot;<span class=\"synConstant\">utf-8</span>&quot;)
<span class=\"synComment\"># HTMLヘッダを出力</span>
fout.write('<span class=\"synConstant\">&lt;!DOCTYPE html&gt;</span><span class=\"synSpecial\">\\n</span>')
fout.write('<span class=\"synConstant\">&lt;html lang=&quot;ja&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
fout.write('<span class=\"synConstant\">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;</span><span class=\"synSpecial\">\\n</span>' % htmlFile)
fout.write('<span class=\"synConstant\">&lt;body&gt;</span><span class=\"synSpecial\">\\n</span>')
fout.write('<span class=\"synConstant\">&lt;table border=&quot;1&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
fout.write(u'<span class=\"synConstant\">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ランク&lt;/th&gt;&lt;th&gt;EMD&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;</span>')
fout.write(u'<span class=\"synConstant\">&lt;th&gt;アーティスト&lt;/th&gt;&lt;th&gt;音声&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><span class=\"synSpecial\">\\n</span>')
fout.write(u'<span class=\"synConstant\">&lt;tbody&gt;</span><span class=\"synSpecial\">\\n</span>')
<span class=\"synComment\"># ランキングを出力</span>
rank = 1
<span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
prefix = sigFile.replace(&quot;<span class=\"synConstant\">.sig</span>&quot;, &quot;&quot;)
<span class=\"synComment\"># rawをwavに変換（HTMLプレーヤー用）</span>
rawPath = os.path.join(&quot;<span class=\"synConstant\">raw</span>&quot;, prefix + &quot;<span class=\"synConstant\">.raw</span>&quot;)
wavPath = os.path.join(&quot;<span class=\"synConstant\">wav</span>&quot;, prefix + &quot;<span class=\"synConstant\">.wav</span>&quot;)
<span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(&quot;<span class=\"synConstant\">wav</span>&quot;): os.mkdir(&quot;<span class=\"synConstant\">wav</span>&quot;)
os.system('<span class=\"synConstant\">sox -r 16000 -e signed-integer -b 16 &quot;%s&quot; &quot;%s&quot;</span>' % (rawPath, wavPath))
<span class=\"synComment\"># アーティスト名を取得</span>
mp3Path = os.path.join(&quot;<span class=\"synConstant\">mp3</span>&quot;, prefix + &quot;<span class=\"synConstant\">.mp3</span>&quot;)
artist = getArtist(mp3Path)
<span class=\"synComment\"># HTML出力</span>
<span class=\"synComment\"># HTML5のオーディオプレーヤーを埋め込む</span>
audio = '<span class=\"synConstant\">&lt;audio src=&quot;%s&quot; controls&gt;</span>' % wavPath
fout.write(&quot;<span class=\"synConstant\">&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;</span><span class=\"synSpecial\">\\n</span>&quot;
% (rank, emd, prefix, artist, audio))
rank += 1
fout.write(&quot;<span class=\"synConstant\">&lt;/tbody&gt;</span><span class=\"synSpecial\">\\n</span>&quot;);
fout.write(&quot;<span class=\"synConstant\">&lt;/table&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
fout.write(&quot;<span class=\"synConstant\">&lt;/body&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
fout.write(&quot;<span class=\"synConstant\">&lt;/html&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
fout.close()
<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
<span class=\"synStatement\">if</span> len(sys.argv) != 4:
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">python mir.py [sig file] [sig dir] [html file]</span>&quot;
sys.exit()
targetSigPath = sys.argv[1]
sigDir = sys.argv[2]
htmlFile = sys.argv[3]
ranking = defaultdict(float)
<span class=\"synComment\"># 全楽曲との間で距離を求める</span>
<span class=\"synStatement\">for</span> sigFile <span class=\"synStatement\">in</span> os.listdir(sigDir):
sigPath = os.path.join(sigDir, sigFile)
emd = calcEMD(targetSigPath, sigPath)
<span class=\"synStatement\">if</span> emd &lt; 0: <span class=\"synStatement\">continue</span>
ranking[sigFile] = emd
<span class=\"synComment\"># ランキングをEMDの降順にソートして出力</span>
N = 10
rank = 1
<span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%d</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%.2f</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%s</span>&quot; % (rank, emd, sigFile)
rank += 1
<span class=\"synComment\"># EMDの昇順に上位10件をHTMLにして出力</span>
makeHTML(ranking, htmlFile, N)
</pre>
</div>
<div class=\"section\">
<h4>実験</h4>
<p>では、いくつかの楽曲をクエリとして与えてさっそく結果をみてみましょう！</p><p>この実験は、やはり音が聞けないと大部分の人にはわからないと思うので、各楽曲の中心30秒間のWAVファイルを再生できるHTMLページも用意しました。引用の範囲なのでおそらく大丈夫だとは思いますが・・・著作権者様からの連絡があったら削除します。結果の2列目がクエリとの間のEMDです。1位がクエリの曲になります。1位にクエリと同じ曲がくるのはまあ当然ですよね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/愛は勝つ.sig sig ai_ha_katu.html
1	20.00	愛は勝つ.sig
2	51.51	WE GOTTA POWER.sig
3	51.67	時の河.sig
4	52.30	Ilusion.sig
5	52.51	君がいるだけで.sig
6	53.26	君がいるから.sig
7	53.50	心のPhotograph.sig
8	53.65	ルネッサンス情熱.sig
9	54.25	嘘.sig
10	55.17	謳う丘.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。小学校のときすごい流行りました（笑）検索結果は、男性の力強いボーカル中心ということでけっこう似ているように思うのですがいかがでしょう？ところどころ女性ボーカルが入ってますが何でだろう？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/魔法の人.sig sig maho_no_hito.html
1	20.00	魔法の人.sig
2	64.30	変わらないもの.sig
3	65.87	優しい風.sig
4	66.34	Thanks.sig
5	67.06	旅の途中.sig
6	68.11	碧いうさぎ.sig
7	68.32	窓絵.sig
8	69.03	Garnet.sig
9	72.18	奇跡の海 (オリジナル・カラオケ).sig
10	72.19	甘えんぼ.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。女性の優しいボーカルが検索結果として並んでいるように思います。「変わらないもの」と「Garnet」はクエリと同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%FC%B2%DA%BB%D2\">奥華子</a>さんの曲みたいですね。聞いてみたところ雰囲気は何となく似ていると思います。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/Prayer.sig sig prayer.html
1	20.00	Prayer.sig
2	81.31	Windancer.sig
3	85.38	Escape.sig
4	89.42	Appassionata.sig
5	89.42	First Day Of Spring.sig
6	90.56	Celebration.sig
7	91.46	Steps.sig
8	91.84	Moving.sig
9	97.62	Passacaglia.sig
10	98.97	陽だまりの歌.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。海外アーティストの英語の曲です。9位まではすべて同じSecret Gardenのアルバムからでした。同じアルバムということで非常に雰囲気が似ています。10位も優しい曲で同じような雰囲気を感じます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/君をのせて.sig sig kimi_wo_nosete.html
1	20.00	君をのせて.sig
2	80.20	魔法のぬくもり.sig
3	82.78	青空っていいな.sig
4	83.66	風のとおり道.sig
5	84.07	カントリー・ロード.sig
6	87.44	Garnet.sig
7	88.42	やさしさに包まれたなら.sig
8	88.91	わたしが不思議.sig
9	89.48	Hello My Friend.sig
10	89.95	つないだ手.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%B7%B6%F5%A4%CE%BE%EB%A5%E9%A5%D4%A5%E5%A5%BF\">天空の城ラピュタ</a>」のエンディング曲ですね。2位の「魔法のぬくもり」は同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%E6%BE%E5%A4%A2%A4%BA%A4%DF\">井上あずみ</a>さんの曲です。「風のとおり道」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AB%A5%F3%A5%C8%A5%EA%A1%BC%A1%A6%A5%ED%A1%BC%A5%C9\">カントリー・ロード</a>」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%E4%A4%B5%A4%B7%A4%B5%A4%CB%CA%F1%A4%DE%A4%EC%A4%BF%A4%CA%A4%E9\">やさしさに包まれたなら</a>」は全部<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の曲じゃないか！？これはおどろき。やっぱり雰囲気は似ているのかな？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/蒼い鳥.sig sig aoi_tori.html
1	20.00	蒼い鳥.sig
2	66.21	蒼い鳥（アレンシ&amp;#12441;版）.sig
3	83.96	青空っていいな.sig
4	85.03	春よ来い.sig
5	87.98	わたしが不思議.sig
6	88.12	遠い音楽.sig
7	90.25	Appassionata.sig
8	92.86	Dear You -Feel-.sig
9	93.21	やさしさに包まれたなら.sig
10	94.33	葬列.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。悲しげな感じがするきれいな曲です。2位に同じ「蒼い鳥」という曲が入りましたが、微妙に違うアレンジ版のようです。6位の「遠い音楽」も同じ今井さんの曲です。その他も何か悲しげな曲が多い感じです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/さくらんぼ.sig sig sakuranbo.html
1	20.00	さくらんぼ.sig
2	49.84	WILL.sig
3	50.58	Good Day.sig
4	51.12	扉の向こうへ.sig
5	51.75	夢想歌.sig
6	51.80	ショットガン・ラヴァーズ.sig
7	52.08	深く眠れ.sig
8	52.25	Vermillion.sig
9	52.46	西のそらへ.sig
10	52.87	大爆発No.1.sig</pre><p>最後は、<a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。元気な感じの女性のボーカルです。まあ検索結果も元気な感じの女性の曲が並んでいました。6位の「ショットガン・ラヴァーズ」は今話題の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BD%E9%B2%BB%A5%DF%A5%AF\">初音ミク</a>の曲のようです。合成音声でも関係ないのかな？</p>
</div>
<div class=\"section\">
<h4>おわりに</h4>
<p>今回は、類似楽曲検索システムを実験してみました。今回作ったのは非常に基本的なシステムでMFCCという特徴量だけに基づいています。さらにメロディ、リズムの類似性を考慮するなど改良できる点はたくさんあると思います。また、大量の楽曲を対象に検索するには並列処理やより効率的なアルゴリズムも必要ですね。たぶん、実用化に関してはそっちの方が問題になりそうです・・・上であげたPampalkさんの論文はさらに追究するスタートポイントとしてよくまとまっていると思います。</p><p><a href=\"http://d.hatena.ne.jp/aidiary/20120101/1325465854\">&#x4ECA;&#x5E74;&#x306E;&#x76EE;&#x6A19;</a>（2012/1/1）は、類似楽曲検索システムの実験をすることだったのでとりあえず達成！達成できたのは珍しいぞ。</p>
</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">ただ、先の論文には誤りがあるようです。traceがぬけているため結果が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AB%A5%E9%A1%BC\">スカラー</a>になりません。</span></p>
</div>" "http://aidiary.hatenablog.com/entry/20121014/1350211413" (20602 38741) old 2 nil nil ((title nil " 類似楽曲検索システムを作ろう") (link ((href . "http://aidiary.hatenablog.com/entry/20121014/1350211413"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656801") (updated nil "2012-10-14T19:43:33+09:00") (summary nil "もう1年以上かけて音声信号処理の勉強をしてきました（Pythonで音声信号処理）。ここらで具体的なアプリケーションとして類似楽曲検索の実験をしてみたのでレポートをまとめておきます。言語はPythonです。前に 類似画像検索システムを作ろう（2009/10/3） Visual Wo") (content ((type . "html")) "<p>もう1年以上かけて音声信号処理の勉強をしてきました（<a href=\"http://d.hatena.ne.jp/aidiary/20110514/1305377659\">Python&#x3067;&#x97F3;&#x58F0;&#x4FE1;&#x53F7;&#x51E6;&#x7406;</a>）。ここらで具体的なアプリケーションとして類似楽曲検索の実験をしてみたのでレポートをまとめておきます。言語は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>です。</p><p>前に</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;&#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x3092;&#x4F5C;&#x308D;&#x3046;</a>（2009/10/3）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）</li>
</ul><p>という画像の類似検索に関するエントリを書きましたが、今回は画像ではなく<span class=\"deco\" style=\"color:#FF0000;\">音楽を対象に</span>類似検索をやってみたいと思います！</p><p>今回作る類似楽曲検索システムは、従来からよくあるアーティスト名や曲名などテキストで検索するシステムや購買履歴をもとにオススメする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B6%A8%C4%B4%A5%D5%A5%A3%A5%EB%A5%BF%A5%EA%A5%F3%A5%B0\">協調フィルタリング</a>ベースのシステムとは異なります。WAVEファイルやMP3ファイルなどの<span class=\"deco\" style=\"color:#FF0000;\">音楽波形そのものを入力とする</span>のが特徴です。たとえば、「<span class=\"deco\" style=\"color:#FF0000;\">具体的なアーティストや曲名は知らないけれど、この曲とメロディや雰囲気が似た曲がほしいな</span>」なんていうときに便利に使えるシステムです。</p><p>この研究分野は、<span class=\"deco\" style=\"color:#FF0000;\">Music Information Retrieval (MIR)</span> と呼ばれています。私自身、アーティストによって曲を買うことはほとんどないので、以前からこういうシステムがほしいなぁと思ってました。</p><p>とりあえず実験結果だけ見たい方は下のページにあります。1位がクエリの楽曲で似ている順に上位10件を出力しました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTML5\">HTML5</a>でオーディオ断片を埋め込んだので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>だと音声で確認できます。</p>

<ul>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
<li><a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a></li>
</ul><p>どうでしょう？似てますかね？</p>

<div class=\"section\">
    <h4>概要</h4>
    <p>今回の実験で参考にした資料は、</p>

<ul>
<li>Pampalk, E., <a href=\"http://www.ofai.at/~elias.pampalk/publications/pampalk06thesis.pdf\">Computational Models of Music Similarity and their Application in Music Information Retrieval</a> (PDF), Doctoral Thesis, Vienna University of Technology, Austria, March 2006.</li>
</ul>
<ul>
<li>Logan, B. and Salomon, A., <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.9.9328\">A Content-based Music Similarity Function</a>, Technical report, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Compaq\">Compaq</a> Cambridge Research Lab, 2001.</li>
</ul><p>という2つの論文です。上の論文は、類似楽曲検索の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B5%A1%BC%A5%D9%A5%A4\">サーベイ</a>論文としてよくまとまっています。今回はPampalkさんの論文で紹介されているLoganさんの論文の手法を実際に試してみました。</p><p>Loganさんが提案したのは音声の局所特徴量を用いたアプローチで<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Visual Words&#x3092;&#x7528;&#x3044;&#x305F;&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a>（2010/2/27）と考え方がよく似ています。類似画像検索だとSIFTやSURFといった局所特徴量を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してVisual wordsを作りました。そして、各画像をVisual wordsの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>間の距離を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>インターセクションで求めました。</p><p>今回の音楽の場合は<a href=\"http://d.hatena.ne.jp/aidiary/20120225#1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;</a>（2012/2/25）、略して<span class=\"deco\" style=\"color:#FF0000;\">MFCC</span>というスペクトル特徴量を使います。各楽曲から得られるMFCCベクトル集合を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して楽曲を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の集合で表現し、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>集合間の距離を<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）で求めます。<span class=\"deco\" style=\"color:#FF0000;\">EMDが近い楽曲が互いに類似した楽曲</span>となるわけです。</p><p>コンテンツの表現方法や使用する距離の定義が多少違いますが、アプローチはよく似ています。というわけで論文にそって早速試してみます！</p>

</div>
<div class=\"section\">
    <h4>MP3ファイルの準備</h4>
    <p>類似楽曲検索なのでまず楽曲ファイルが必要です。最初、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E9%A5%B4%A5%F3%A5%AF%A5%A8%A5%B9%A5%C8\">ドラゴンクエスト</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%A1%A5%A4%A5%CA%A5%EB%A5%D5%A5%A1%A5%F3%A5%BF%A5%B8%A1%BC\">ファイナルファンタジー</a>のサウンドトラックで試してみたのですが、どうもよい結果が得られませんでした。いろいろ試したところインストだけの曲よりボーカルが入ってた方がよい結果になるみたいです。</p><p>私自身はボーカル入りのCDはあんまり持ってなかったので、妹の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>を<del datetime=\"2012-10-14T19:45:06+09:00\">パクって</del>借りて、500曲くらいのボーカル曲のリストを作りました。そんなわけで、検索結果の曲のすべてが私の趣味というわけではないのであしからず（笑）500曲のMP3ファイルは当然ながら公開できないのでお手持ちの曲でぜひ試してみてください。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>はアルバム名やアーティスト名で階層構造になっていますが、ここでは簡単のためすべての曲をmp3というフォルダにまとめました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iTunes\">iTunes</a>で買った曲などMP3以外のフォーマットがある場合は、MP3への変換が必要です。やり方はググってください。</p>

</div>
<div class=\"section\">
    <h4>MFCCの抽出</h4>
    <p>まず、MP3ファイルからスペクトル特徴量の<span class=\"deco\" style=\"color:#FF0000;\">メル周波数ケプストラム係数（MFCC）</span>を抽出します。MFCCはスペクトルの概形を表すパラメータなので音色を表すと考えてよいと思います。MFCCに関しては、前に書いた記事を参考にしてください。</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">&#x30E1;&#x30EB;&#x5468;&#x6CE2;&#x6570;&#x30B1;&#x30D7;&#x30B9;&#x30C8;&#x30E9;&#x30E0;&#x4FC2;&#x6570;&#xFF08;MFCC&#xFF09;</a>（2012/2/25）</li>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (6) MFCC&#x306E;&#x62BD;&#x51FA;</a>（2012/8/5）</li>
</ul><p>以下が、指定したMP3ディレクトリ（mp3）にあるすべてのMP3ファイルからMFCCを抽出してMFCCディレクトリ（mfcc）に保存する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトです。音声フォーマットの変換に<a href=\"http://sox.sourceforge.net\">sox</a>と<a href=\"http://lame.sourceforge.net\">lame</a>、波形の切り出し、MFCCの抽出に<a href=\"http://sp-tk.sourceforge.net\">SPTK</a>というツールを使っています。両方ともインストールしないと動きません。SPTKのインストールは</p>

<ul>
<li><a href=\"http://d.hatena.ne.jp/aidiary/20120701/1341126474\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (1) &#x30A4;&#x30F3;&#x30B9;&#x30C8;&#x30FC;&#x30EB;&#x30FB;&#x6CE2;&#x5F62;&#x63CF;&#x753B;&#x30FB;&#x97F3;&#x58F0;&#x518D;&#x751F;</a>（2012/7/1）</li>
</ul><p>という記事にまとめました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys

<span class=\"synComment\"># mp3_to_mfcc.py</span>
<span class=\"synComment\"># usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>
<span class=\"synComment\"># ディレクトリ内のMP3ファイルからMFCCを抽出する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">mp3ToRaw</span>(mp3File, rawFile):
    <span class=\"synComment\"># mp3を16kHz, 32bitでリサンプリング</span>
    os.system(&quot;<span class=\"synConstant\">lame --resample 16 -b 32 -a '%s' temp.mp3</span>&quot; % mp3File)
    <span class=\"synComment\"># mp3をwavに変換</span>
    os.system(&quot;<span class=\"synConstant\">lame --decode temp.mp3 temp.wav</span>&quot;)
    <span class=\"synComment\"># wavをrawに変換</span>
    os.system(&quot;<span class=\"synConstant\">sox temp.wav %s</span>&quot; % rawFile)
    os.remove(&quot;<span class=\"synConstant\">temp.mp3</span>&quot;)
    os.remove(&quot;<span class=\"synConstant\">temp.wav</span>&quot;)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcNumSample</span>(rawFile):
    <span class=\"synComment\"># 1サンプルはshort型（2byte）なのでファイルサイズを2で割る</span>
    filesize = os.path.getsize(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
    numsample = filesize / 2
    <span class=\"synStatement\">return</span> numsample

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">extractCenter</span>(inFile, outFile, period):
    <span class=\"synComment\"># 波形のサンプル数を求める</span>
    numsample = calcNumSample(inFile)

    fs = 16000
    center = numsample / 2
    start = center - fs * period
    end = center + fs * period
    
    <span class=\"synComment\"># period*2秒未満の場合は範囲を狭める</span>
    <span class=\"synStatement\">if</span> start &lt; 0: start = 0
    <span class=\"synStatement\">if</span> end &gt; numsample - 1: end = numsample - 1

    <span class=\"synComment\"># SPTKのbcutコマンドで切り出す</span>
    os.system(&quot;<span class=\"synConstant\">bcut +s -s %d -e %d &lt; '%s' &gt; '%s'</span>&quot; <span class=\"synSpecial\">\\</span>
              % (start, end, &quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile))

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcMFCC</span>(rawFile, mfccFile):
    <span class=\"synComment\"># サンプリング周波数: 16kHz</span>
    <span class=\"synComment\"># フレーム長: 400サンプル</span>
    <span class=\"synComment\"># シフト幅  : 160サンプル</span>
    <span class=\"synComment\"># チャンネル数: 40</span>
    <span class=\"synComment\"># MFCC: 19次元 + エネルギー</span>
    os.system(&quot;<span class=\"synConstant\">x2x +sf &lt; '%s' | frame -l 400 -p 160 | mfcc -l 400 -f 16 -n 40 -m 19 -E &gt; '%s'</span>&quot;
              % (rawFile, mfccFile))

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 4:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mp3_to_mfcc.py [mp3dir] [mfccdir] [rawdir]</span>&quot;
        sys.exit()

    mp3Dir = sys.argv[1]
    mfccDir = sys.argv[2]
    rawDir = sys.argv[3]

    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(mfccDir):
        os.mkdir(mfccDir)
    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(rawDir):
        os.mkdir(rawDir)

    <span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mp3Dir):
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mp3</span>&quot;): <span class=\"synStatement\">continue</span>
        mp3File = os.path.join(mp3Dir, file)
        mfccFile = os.path.join(mfccDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.mfc</span>&quot;))
        rawFile = os.path.join(rawDir, file.replace(&quot;<span class=\"synConstant\">.mp3</span>&quot;, &quot;<span class=\"synConstant\">.raw</span>&quot;))

        <span class=\"synStatement\">try</span>:
            <span class=\"synComment\"># MP3を変換</span>
            mp3ToRaw(mp3File, &quot;<span class=\"synConstant\">temp.raw</span>&quot;)
        
            <span class=\"synComment\"># 中央の30秒だけ抽出してrawFileへ</span>
            extractCenter(&quot;<span class=\"synConstant\">temp.raw</span>&quot;, rawFile, 15)

            <span class=\"synComment\"># MFCCを計算</span>
            calcMFCC(rawFile, mfccFile)

            <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%s =&gt; %s</span>&quot; % (mp3File, mfccFile)

            <span class=\"synComment\"># 後片付け</span>
            os.remove(&quot;<span class=\"synConstant\">temp.raw</span>&quot;)
        <span class=\"synStatement\">except</span>:
            <span class=\"synStatement\">continue</span>
</pre><p>曲全体からMFCCを抽出すると処理が重すぎるので、Pampalkさんの論文に従って、曲の中心の30秒間だけを対象にしました。本当は、画像の局所特徴量SIFTのようにその曲の特徴をよく表す部分（サビ？）からとりたかったのだけどどうやればいいんだろう。</p><p>MFCCファイルは、SPTKのバイナリ形式になっています。前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120805/1343825329\">print_mfcc.py</a>というスクリプトでダンプできます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>を20次元ずつダンプしてみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py mfcc/愛は勝つ.mfc 20
-14.77  -8.78   -6.70   ...    3.45    7.37    1.44    2.80    22.29
-13.84  -9.71   -3.28   ...    -0.82   6.72    2.70    1.92    22.85
-15.45  -12.54  -7.64   ...    -5.64   3.45    2.31    6.03    22.67
-14.64  -10.72  -4.96   ...    -5.24   3.64    0.71    5.49    22.78</pre><p>各行が1フレームの20次元MFCCベクトル（19次元+パワー）です。サンプリング周波数16kHz、シフト幅160サンプル、30秒間の楽曲なので、30 x 16000 / 160 = 3000フレームあります。つまり、「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%A6%A4%CF%BE%A1%A4%C4\">愛は勝つ</a>」の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>ファイルは<span class=\"deco\" style=\"color:#FF0000;\">20次元のMFCCベクトルが3000行もあります</span>。1曲を表すベクトルとしては大きすぎですね・・・</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214857\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214857.png\" alt=\"f:id:aidiary:20121015214857p:image\" title=\"f:id:aidiary:20121015214857p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p>

</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の計算</h4>
    <p>1曲を表す特徴ベクトルが、20次元ベクトル3000個（20x3000 = 60000個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>）では大きすぎるのでもう少し情報を圧縮します。こんなときに使えるのが前に紹介した<a href=\"http://d.hatena.ne.jp/aidiary/20120813/1344853878\">&#x30D9;&#x30AF;&#x30C8;&#x30EB;&#x91CF;&#x5B50;&#x5316;</a>（2012/8/13）というアルゴリズムです。ようは3000個のベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してよく似たベクトルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>にまとめてしまいます。そして各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>と仮定してその平均ベクトルと分散共分散行列を求め、それをあらたな特徴量とします。式で表すと楽曲Pの特徴量は、<br />
<center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013175637\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013175637.png\" alt=\"f:id:aidiary:20121013175637p:image\" title=\"f:id:aidiary:20121013175637p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
となります。mは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の数です。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>にはよく使われる<span class=\"deco\" style=\"color:#FF0000;\">k-means</span>を用いました。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数は上の論文に合わせて16としました。つまり、3000個のベクトル集合をたった16個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均ベクトルは20次元ベクトル、分散共分散行列は20x20次元の行列になります。つまり、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>(20次元平均ベクトル + 20x20次元の分散共分散行列) x 16クラスタ = 6720個の浮動小数点数</pre><p>まで情報を圧縮できます。実際は、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の平均と分散のほかに重み（その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されたベクトルの数）の情報も加えるので正確には6736個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>になります。60000個に比べたらずいぶん減ります。下のスクリプトは、各局のMFCCファイルを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルに変換するスクリプトです。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster

<span class=\"synComment\"># mfcc_to_signature.py</span>
<span class=\"synComment\"># usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>
<span class=\"synComment\"># 各曲のMFCCをシグネチャに変換する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadMFCC</span>(mfccFile, m):
    &quot;&quot;&quot;<span class=\"synConstant\">MFCCをロードする、mはMFCCの次元数</span>&quot;&quot;&quot;
    mfcc = []
    fp = open(mfccFile, &quot;<span class=\"synConstant\">rb</span>&quot;)
    <span class=\"synStatement\">while</span> True:
        b = fp.read(4)
        <span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>
        val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
        mfcc.append(val)
    fp.close()

    <span class=\"synComment\"># 各行がフレームのMFCC</span>
    <span class=\"synComment\"># numFrame行、m列の行列形式に変換</span>
    mfcc = np.array(mfcc)
    numFrame = len(mfcc) / m
    mfcc = mfcc.reshape(numFrame, m)

    <span class=\"synStatement\">return</span> mfcc

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">vq</span>(mfcc, k):
    &quot;&quot;&quot;<span class=\"synConstant\">mfccのベクトル集合をk個のクラスタにベクトル量子化</span>&quot;&quot;&quot;
    codebook, destortion = scipy.cluster.vq.kmeans(mfcc, k)
    code, dist = scipy.cluster.vq.vq(mfcc, codebook)
    <span class=\"synStatement\">return</span> code

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 3:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python mfcc_to_signature.py [mfccdir] [sigdir]</span>&quot;
        sys.exit()

    mfccDir = sys.argv[1]
    sigDir  = sys.argv[2]

    <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(sigDir):
        os.mkdir(sigDir)

    <span class=\"synStatement\">for</span> file <span class=\"synStatement\">in</span> os.listdir(mfccDir):
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> file.endswith(&quot;<span class=\"synConstant\">.mfc</span>&quot;): <span class=\"synStatement\">continue</span>
        mfccFile = os.path.join(mfccDir, file)
        sigFile = os.path.join(sigDir, file.replace(&quot;<span class=\"synConstant\">.mfc</span>&quot;, &quot;<span class=\"synConstant\">.sig</span>&quot;))

        <span class=\"synStatement\">print</span> mfccFile, &quot;<span class=\"synConstant\">=&gt;</span>&quot;, sigFile

        fout = open(sigFile, &quot;<span class=\"synConstant\">w</span>&quot;)

        <span class=\"synComment\"># MFCCをロード</span>
        <span class=\"synComment\"># 各行がフレームのMFCCベクトル</span>
        mfcc = loadMFCC(mfccFile, 20)

        <span class=\"synComment\"># MFCCをベクトル量子化してコードを求める</span>
        code = vq(mfcc, 16)

        <span class=\"synComment\"># 各クラスタのデータ数、平均ベクトル、</span>
        <span class=\"synComment\"># 共分散行列を求めてシグネチャとする</span>
        <span class=\"synStatement\">for</span> k <span class=\"synStatement\">in</span> range(16):
            <span class=\"synComment\"># クラスタkのフレームのみ抽出</span>
            frames = np.array([mfcc[i] <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)) <span class=\"synStatement\">if</span> code[i] == k])
            <span class=\"synComment\"># MFCCの各次元の平均をとって平均ベクトルを求める</span>
            m = np.apply_along_axis(np.mean, 0, frames)  <span class=\"synComment\"># 0は縦方向</span>
            <span class=\"synComment\"># MFCCの各次元間での分散・共分散行列を求める</span>
            sigma = np.cov(frames.T)
            <span class=\"synComment\"># 重み（各クラスタのデータ数）</span>
            w = len(frames)
            <span class=\"synComment\"># このクラスタの特徴量をフラット形式で出力</span>
            <span class=\"synComment\"># 1行が重み1個、平均ベクトル20個、分散・共分散行列400個の計421個の数値列</span>
            features = np.hstack((w, m, sigma.flatten()))
            features = [str(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> features]
            fout.write(&quot;<span class=\"synConstant\"> </span>&quot;.join(features) + &quot;<span class=\"synSpecial\">\\n</span>&quot;)
        fout.close()
</pre><p>出力である楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>ファイルは、1行に (重み、20次元平均ベクトル、20x20次元の分散・共分散行列) の421個の数値が並びます。それが、16<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>分あるので16行のファイルです。</p>

</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離と楽曲間の距離</h4>
    <p>次に2つの楽曲の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>間の距離を求めます。これには、前に書いた<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）を使います。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121015214928\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121015/20121015214928.png\" alt=\"f:id:aidiary:20121015214928p:image\" title=\"f:id:aidiary:20121015214928p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>左側が楽曲Pの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>で右側が楽曲Qの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>です。楽曲Pと楽曲Qの距離を求めるのが課題です。EMDの詳しい解説は、<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）を参照してください。先のページのEMD具体例では、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>が単純な<span class=\"deco\" style=\"color:#FF0000;\">ベクトル</span>なので、各特徴量間の距離に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えました。ですが、今回は各特徴量がベクトルではなく、<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a></span>になっています。というわけで単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離が使えません・・・</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離がはかれる指標として<span class=\"deco\" style=\"color:#FF0000;\">カルバック・ライブラー情報量（Kullback Leibler Divergence）</span>というのがあります。<a href=\"http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\">Kullback-Leibler divergence - Wikipedia</a>によると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>N1とN2（それぞれ平均ベクトル、分散共分散行列がある）の間のカルバック・ライブラー情報量の定義は、</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190723\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190723.png\" alt=\"f:id:aidiary:20121013190723p:image\" title=\"f:id:aidiary:20121013190723p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>です。うう、目がくらむぅ。kは平均ベクトルの次元数です。一般的にカルバック・ライブラー情報量は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が成り立ちません。つまり、<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N1%7C%7CN2%29\" alt=\"D_{KL}(N1||N2)\"/>と<img src=\"http://chart.apis.google.com/chart?cht=tx&chl=D_%7BKL%7D%28N2%7C%7CN1%29\" alt=\"D_{KL}(N2||N1)\"/>で異なる値が出てきます。そのため、上の式をそのまま使うと楽曲Pからみた楽曲Qの距離と楽曲Qからみた楽曲Pの距離が違ってきます。これでは使いにくい。そのため、論文では<span class=\"deco\" style=\"color:#FF0000;\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量</span>を使っています<a href=\"#f1\" name=\"fn1\" title=\"ただ、先の論文には誤りがあるようです。traceがぬけているため結果がスカラーになりません。\">*1</a>。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20121013190948\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20121013/20121013190948.png\" alt=\"f:id:aidiary:20121013190948p:image\" title=\"f:id:aidiary:20121013190948p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>単純にひっくり返した距離も足し合わせているだけですね。これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>が保たれます。カルバック・ライブラー情報量は、<a href=\"http://rss.acs.unt.edu/Rdoc/library/monomvn/html/kl.norm.html\">R&#x306B;&#x306F;&#x95A2;&#x6570;&#x304C;&#x7528;&#x610F;&#x3055;&#x308C;&#x3066;&#x3044;&#x308B;</a>のですが、SciPy/NumPyにはないので自作します。カルバック・ライブラー情報量の定義式において定数倍や定数項は、距離の比較では必要ないので省略しました。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B9%D4%CE%F3%BC%B0\">行列式</a>の項は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C2%D0%BE%CE%C0%AD\">対称性</a>のあるカルバック・ライブラー情報量を使うと打ち消し合って消えるので省略しました。trは、traceの略で行列の対角成分の和です。スクリプトでは、diag()で対角成分を取り出して、sum()で合計しています。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">KLDiv</span>(mu1, S1, mu2, S2):
    &quot;&quot;&quot;<span class=\"synConstant\">正規分布間のカルバック・ライブラー情報量</span>&quot;&quot;&quot;
    <span class=\"synComment\"># 逆行列を計算</span>
    <span class=\"synStatement\">try</span>:
        invS1 = np.linalg.inv(S1)
    <span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
        <span class=\"synStatement\">raise</span>;
    <span class=\"synStatement\">try</span>:
        invS2 = np.linalg.inv(S2)
    <span class=\"synStatement\">except</span> numpy.linalg.linalg.LinAlgError:
        <span class=\"synStatement\">raise</span>;

    <span class=\"synComment\"># KL Divergenceを計算</span>
    t1 = np.sum(np.diag(np.dot(invS2, S1)))
    t2 = (mu2 - mu1).transpose()
    t3 = mu2 - mu1
    <span class=\"synStatement\">return</span> t1 + np.dot(np.dot(t2, invS2), t3)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">symKLDiv</span>(mu1, S1, mu2, S2):
    &quot;&quot;&quot;<span class=\"synConstant\">対称性のあるカルバック・ライブラー情報量</span>&quot;&quot;&quot;
    <span class=\"synStatement\">return</span> 0.5 * (KLDiv(mu1, S1, mu2, S2) + KLDiv(mu2, S2, mu1, S1))
</pre><p>これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%B5%B5%AC%CA%AC%C9%DB\">正規分布</a>間の距離が定義できたのでEMDを計算する関数も作ります。<a href=\"http://d.hatena.ne.jp/aidiary/20120804#1344058475\">Earth Mover&#39;s Distance</a>（2012/8/4）にも書きましたが、RにはEMDの輸送問題を解く関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使ってRの関数を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出しました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects

<span class=\"synComment\"># Rで輸送問題を解くライブラリ</span>
<span class=\"synComment\"># Rのデフォルトパッケージではないのでインストールが必要</span>
<span class=\"synComment\"># Rでinstall.packages(&quot;lpSolve&quot;)</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">calcEMD</span>(sigFile1, sigFile2):
    <span class=\"synComment\"># シグネチャをロード</span>
    sig1 = loadSignature(sigFile1)
    sig2 = loadSignature(sigFile2)

    <span class=\"synComment\"># 距離行列を計算</span>
    numFeatures = sig1.shape[0]                 <span class=\"synComment\"># クラスタの数</span>
    dist = np.zeros(numFeatures * numFeatures)  <span class=\"synComment\"># 距離行列（フラット形式）</span>

    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(numFeatures):
        mu1 = sig1[i, 1:21].reshape(20, 1)   <span class=\"synComment\"># 縦ベクトル</span>
        S1 = sig1[i, 21:421].reshape(20, 20)
        <span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(numFeatures):
            mu2 = sig2[j, 1:21].reshape(20, 1)
            S2 = sig2[j, 21:421].reshape(20, 20)
            <span class=\"synComment\"># 特徴量iと特徴量j間のKLダイバージェンスを計算</span>
            dist[i * numFeatures + j] = symKLDiv(mu1, S1, mu2, S2)

    <span class=\"synComment\"># シグネチャの重み（0列目）を取得</span>
    w1 = sig1[:,0]
    w2 = sig2[:,0]

    <span class=\"synComment\"># 重みと距離行列からEMDを計算</span>
    <span class=\"synComment\"># transport()の引数を用意</span>
    costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
                                 nrow=len(w1), ncol=len(w2),
                                 byrow=True)
    row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
    row_rhs = robjects.FloatVector(w1)
    col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
    col_rhs = robjects.FloatVector(w2)
    
    t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
    flow = t.rx2('<span class=\"synConstant\">solution</span>')
    
    dist = dist.reshape(len(w1), len(w2))
    flow = np.array(flow)
    work = np.sum(flow * dist)
    emd = work / np.sum(flow)
    <span class=\"synStatement\">return</span> emd
</pre><p>これでようやく二つの楽曲間の距離を測れるようになりました。次は、与えたクエリと距離が近い楽曲を検索する部分を作ります。</p>

</div>
<div class=\"section\">
    <h4>類似楽曲検索</h4>
    <p>今回は検索対象の楽曲が500曲程度なので単純な線形探索を使いました。クエリの楽曲と500曲全部の間でEMDを計算して、距離が近い順にランキングを出力します。ついでに<a href=\"http://eyed3.nicfit.net/\">eyeD3</a>というMP3ファイルからタグ情報を読み書きするライブラリを用いて、MP3ファイルからアーティスト名を読み取って出力してみました。また、検索結果をテキストで出力しただけでは検証しにくいので、オーディオタグを埋め込んだHTMLも合わせて出力しています。</p><p>先ほどの3つの関数（KLDiv、symKLDiv、calcEMD）は省略しているので下のスクリプトに追加してください。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> os
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> numpy.linalg
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects
<span class=\"synPreProc\">from</span> collections <span class=\"synPreProc\">import</span> defaultdict

<span class=\"synComment\"># mir.py</span>
<span class=\"synComment\"># usage: python mir.py [sig file] [sig dir] [html file]</span>
<span class=\"synComment\"># sig file  : クエリ楽曲のシグネチャファイル</span>
<span class=\"synComment\"># sig dir   : 検索対象のシグネチャファイルのディレクトリ</span>
<span class=\"synComment\"># html file : 検索結果を出力するHTMLファイル</span>

<span class=\"synComment\"># 引数で指定したシグネチャファイルに近い</span>
<span class=\"synComment\"># 上位N件の楽曲を出力する</span>

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">loadSignature</span>(sigFile):
    &quot;&quot;&quot;<span class=\"synConstant\">シグネチャファイルをロード</span>&quot;&quot;&quot;
    mat = []
    fp = open(sigFile, &quot;<span class=\"synConstant\">r</span>&quot;)
    <span class=\"synStatement\">for</span> line <span class=\"synStatement\">in</span> fp:
        line = line.rstrip()
        mat.append([float(x) <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> line.split()])
    fp.close()
    <span class=\"synStatement\">return</span> np.array(mat)

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">getArtist</span>(mp3Path):
    &quot;&quot;&quot;<span class=\"synConstant\">MP3ファイルからアーティストを取得</span>&quot;&quot;&quot;
    <span class=\"synPreProc\">import</span> eyeD3
    <span class=\"synStatement\">try</span>:
        tag = eyeD3.Tag()
        tag.link(mp3Path)
        artist = tag.getArtist()
    <span class=\"synStatement\">except</span>:
        artist = &quot;<span class=\"synConstant\">None</span>&quot;
    <span class=\"synComment\"># 空白のとき</span>
    <span class=\"synStatement\">if</span> artist == &quot;&quot;: artist = &quot;<span class=\"synConstant\">None</span>&quot;
    <span class=\"synStatement\">return</span> artist

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">makeHTML</span>(ranking, htmlFile, N=10):
    &quot;&quot;&quot;<span class=\"synConstant\">ランキングをHTML形式で出力</span>&quot;&quot;&quot;
    <span class=\"synPreProc\">import</span> codecs
    fout = codecs.open(htmlFile, &quot;<span class=\"synConstant\">w</span>&quot;, &quot;<span class=\"synConstant\">utf-8</span>&quot;)

    <span class=\"synComment\"># HTMLヘッダを出力</span>
    fout.write('<span class=\"synConstant\">&lt;!DOCTYPE html&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;html lang=&quot;ja&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;</span><span class=\"synSpecial\">\\n</span>' % htmlFile)
    fout.write('<span class=\"synConstant\">&lt;body&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write('<span class=\"synConstant\">&lt;table border=&quot;1&quot;&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write(u'<span class=\"synConstant\">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ランク&lt;/th&gt;&lt;th&gt;EMD&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;</span>')
    fout.write(u'<span class=\"synConstant\">&lt;th&gt;アーティスト&lt;/th&gt;&lt;th&gt;音声&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><span class=\"synSpecial\">\\n</span>')
    fout.write(u'<span class=\"synConstant\">&lt;tbody&gt;</span><span class=\"synSpecial\">\\n</span>')

    <span class=\"synComment\"># ランキングを出力</span>
    rank = 1
    <span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
        prefix = sigFile.replace(&quot;<span class=\"synConstant\">.sig</span>&quot;, &quot;&quot;)

        <span class=\"synComment\"># rawをwavに変換（HTMLプレーヤー用）</span>
        rawPath = os.path.join(&quot;<span class=\"synConstant\">raw</span>&quot;, prefix + &quot;<span class=\"synConstant\">.raw</span>&quot;)
        wavPath = os.path.join(&quot;<span class=\"synConstant\">wav</span>&quot;, prefix + &quot;<span class=\"synConstant\">.wav</span>&quot;)
        <span class=\"synStatement\">if</span> <span class=\"synStatement\">not</span> os.path.exists(&quot;<span class=\"synConstant\">wav</span>&quot;): os.mkdir(&quot;<span class=\"synConstant\">wav</span>&quot;)
        os.system('<span class=\"synConstant\">sox -r 16000 -e signed-integer -b 16 &quot;%s&quot; &quot;%s&quot;</span>' % (rawPath, wavPath))

        <span class=\"synComment\"># アーティスト名を取得</span>
        mp3Path = os.path.join(&quot;<span class=\"synConstant\">mp3</span>&quot;, prefix + &quot;<span class=\"synConstant\">.mp3</span>&quot;)
        artist = getArtist(mp3Path)

        <span class=\"synComment\"># HTML出力</span>
        <span class=\"synComment\"># HTML5のオーディオプレーヤーを埋め込む</span>
        audio = '<span class=\"synConstant\">&lt;audio src=&quot;%s&quot; controls&gt;</span>' % wavPath
        fout.write(&quot;<span class=\"synConstant\">&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%.2f&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;</span><span class=\"synSpecial\">\\n</span>&quot;
                   % (rank, emd, prefix, artist, audio))
        rank += 1

    fout.write(&quot;<span class=\"synConstant\">&lt;/tbody&gt;</span><span class=\"synSpecial\">\\n</span>&quot;);
    fout.write(&quot;<span class=\"synConstant\">&lt;/table&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.write(&quot;<span class=\"synConstant\">&lt;/body&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.write(&quot;<span class=\"synConstant\">&lt;/html&gt;</span><span class=\"synSpecial\">\\n</span>&quot;)
    fout.close()

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    <span class=\"synStatement\">if</span> len(sys.argv) != 4:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">python mir.py [sig file] [sig dir] [html file]</span>&quot;
        sys.exit()

    targetSigPath = sys.argv[1]
    sigDir = sys.argv[2]
    htmlFile = sys.argv[3]

    ranking = defaultdict(float)
    
    <span class=\"synComment\"># 全楽曲との間で距離を求める</span>
    <span class=\"synStatement\">for</span> sigFile <span class=\"synStatement\">in</span> os.listdir(sigDir):
        sigPath = os.path.join(sigDir, sigFile)
        emd = calcEMD(targetSigPath, sigPath)
        <span class=\"synStatement\">if</span> emd &lt; 0: <span class=\"synStatement\">continue</span>
        ranking[sigFile] = emd

    <span class=\"synComment\"># ランキングをEMDの降順にソートして出力</span>
    N = 10
    rank = 1
    <span class=\"synStatement\">for</span> sigFile, emd <span class=\"synStatement\">in</span> sorted(ranking.items(), key=<span class=\"synStatement\">lambda</span> x:x[1], reverse=False)[:N]:
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">%d</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%.2f</span><span class=\"synSpecial\">\\t</span><span class=\"synConstant\">%s</span>&quot; % (rank, emd, sigFile)
        rank += 1

    <span class=\"synComment\"># EMDの昇順に上位10件をHTMLにして出力</span>
    makeHTML(ranking, htmlFile, N)
</pre>
</div>
<div class=\"section\">
    <h4>実験</h4>
    <p>では、いくつかの楽曲をクエリとして与えてさっそく結果をみてみましょう！</p><p>この実験は、やはり音が聞けないと大部分の人にはわからないと思うので、各楽曲の中心30秒間のWAVファイルを再生できるHTMLページも用意しました。引用の範囲なのでおそらく大丈夫だとは思いますが・・・著作権者様からの連絡があったら削除します。結果の2列目がクエリとの間のEMDです。1位がクエリの曲になります。1位にクエリと同じ曲がくるのはまあ当然ですよね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/愛は勝つ.sig sig ai_ha_katu.html
1	20.00	愛は勝つ.sig
2	51.51	WE GOTTA POWER.sig
3	51.67	時の河.sig
4	52.30	Ilusion.sig
5	52.51	君がいるだけで.sig
6	53.26	君がいるから.sig
7	53.50	心のPhotograph.sig
8	53.65	ルネッサンス情熱.sig
9	54.25	嘘.sig
10	55.17	謳う丘.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/ai_ha_katu.html\">&#x611B;&#x306F;&#x52DD;&#x3064;&#xFF08;KAN&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。小学校のときすごい流行りました（笑）検索結果は、男性の力強いボーカル中心ということでけっこう似ているように思うのですがいかがでしょう？ところどころ女性ボーカルが入ってますが何でだろう？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/魔法の人.sig sig maho_no_hito.html
1	20.00	魔法の人.sig
2	64.30	変わらないもの.sig
3	65.87	優しい風.sig
4	66.34	Thanks.sig
5	67.06	旅の途中.sig
6	68.11	碧いうさぎ.sig
7	68.32	窓絵.sig
8	69.03	Garnet.sig
9	72.18	奇跡の海 (オリジナル・カラオケ).sig
10	72.19	甘えんぼ.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/maho_no_hito.html\">&#x9B54;&#x6CD5;&#x306E;&#x4EBA;&#xFF08;&#x5965;&#x83EF;&#x5B50;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。女性の優しいボーカルが検索結果として並んでいるように思います。「変わらないもの」と「Garnet」はクエリと同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B1%FC%B2%DA%BB%D2\">奥華子</a>さんの曲みたいですね。聞いてみたところ雰囲気は何となく似ていると思います。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/Prayer.sig sig prayer.html        
1	20.00	Prayer.sig
2	81.31	Windancer.sig
3	85.38	Escape.sig
4	89.42	Appassionata.sig
5	89.42	First Day Of Spring.sig
6	90.56	Celebration.sig
7	91.46	Steps.sig
8	91.84	Moving.sig
9	97.62	Passacaglia.sig
10	98.97	陽だまりの歌.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/prayer.html\">Prayer&#xFF08;Secret Garden&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。海外アーティストの英語の曲です。9位まではすべて同じSecret Gardenのアルバムからでした。同じアルバムということで非常に雰囲気が似ています。10位も優しい曲で同じような雰囲気を感じます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/君をのせて.sig sig kimi_wo_nosete.html
1	20.00	君をのせて.sig
2	80.20	魔法のぬくもり.sig
3	82.78	青空っていいな.sig
4	83.66	風のとおり道.sig
5	84.07	カントリー・ロード.sig
6	87.44	Garnet.sig
7	88.42	やさしさに包まれたなら.sig
8	88.91	わたしが不思議.sig
9	89.48	Hello My Friend.sig
10	89.95	つないだ手.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/kimi_wo_nosete.html\">&#x541B;&#x3092;&#x306E;&#x305B;&#x3066;&#xFF08;&#x4E95;&#x4E0A;&#x3042;&#x305A;&#x307F;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%B7%B6%F5%A4%CE%BE%EB%A5%E9%A5%D4%A5%E5%A5%BF\">天空の城ラピュタ</a>」のエンディング曲ですね。2位の「魔法のぬくもり」は同じ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B0%E6%BE%E5%A4%A2%A4%BA%A4%DF\">井上あずみ</a>さんの曲です。「風のとおり道」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AB%A5%F3%A5%C8%A5%EA%A1%BC%A1%A6%A5%ED%A1%BC%A5%C9\">カントリー・ロード</a>」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%E4%A4%B5%A4%B7%A4%B5%A4%CB%CA%F1%A4%DE%A4%EC%A4%BF%A4%CA%A4%E9\">やさしさに包まれたなら</a>」は全部<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%D6%A5%EA\">ジブリ</a>の曲じゃないか！？これはおどろき。やっぱり雰囲気は似ているのかな？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/蒼い鳥.sig sig aoi_tori.html
1	20.00	蒼い鳥.sig
2	66.21	蒼い鳥（アレンシ&amp;#12441;版）.sig
3	83.96	青空っていいな.sig
4	85.03	春よ来い.sig
5	87.98	わたしが不思議.sig
6	88.12	遠い音楽.sig
7	90.25	Appassionata.sig
8	92.86	Dear You -Feel-.sig
9	93.21	やさしさに包まれたなら.sig
10	94.33	葬列.sig</pre><p><a href=\"https://dl.dropbox.com/u/285709/mir/aoi_tori.html\">&#x84BC;&#x3044;&#x9CE5;&#xFF08;&#x4ECA;&#x4E95;&#x9EBB;&#x7F8E;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。悲しげな感じがするきれいな曲です。2位に同じ「蒼い鳥」という曲が入りましたが、微妙に違うアレンジ版のようです。6位の「遠い音楽」も同じ今井さんの曲です。その他も何か悲しげな曲が多い感じです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python mir.py sig/さくらんぼ.sig sig sakuranbo.html
1	20.00	さくらんぼ.sig
2	49.84	WILL.sig
3	50.58	Good Day.sig
4	51.12	扉の向こうへ.sig
5	51.75	夢想歌.sig
6	51.80	ショットガン・ラヴァーズ.sig
7	52.08	深く眠れ.sig
8	52.25	Vermillion.sig
9	52.46	西のそらへ.sig
10	52.87	大爆発No.1.sig</pre><p>最後は、<a href=\"https://dl.dropbox.com/u/285709/mir/sakuranbo.html\">&#x3055;&#x304F;&#x3089;&#x3093;&#x307C;&#xFF08;&#x5927;&#x585A;&#x611B;&#xFF09;&#x306E;&#x691C;&#x7D22;&#x7D50;&#x679C;&#xFF08;HTML&#xFF09;</a>です。元気な感じの女性のボーカルです。まあ検索結果も元気な感じの女性の曲が並んでいました。6位の「ショットガン・ラヴァーズ」は今話題の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BD%E9%B2%BB%A5%DF%A5%AF\">初音ミク</a>の曲のようです。合成音声でも関係ないのかな？</p>

</div>
<div class=\"section\">
    <h4>おわりに</h4>
    <p>今回は、類似楽曲検索システムを実験してみました。今回作ったのは非常に基本的なシステムでMFCCという特徴量だけに基づいています。さらにメロディ、リズムの類似性を考慮するなど改良できる点はたくさんあると思います。また、大量の楽曲を対象に検索するには並列処理やより効率的なアルゴリズムも必要ですね。たぶん、実用化に関してはそっちの方が問題になりそうです・・・上であげたPampalkさんの論文はさらに追究するスタートポイントとしてよくまとまっていると思います。</p><p><a href=\"http://d.hatena.ne.jp/aidiary/20120101/1325465854\">&#x4ECA;&#x5E74;&#x306E;&#x76EE;&#x6A19;</a>（2012/1/1）は、類似楽曲検索システムの実験をすることだったのでとりあえず達成！達成できたのは珍しいぞ。</p>

</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">ただ、先の論文には誤りがあるようです。traceがぬけているため結果が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AB%A5%E9%A1%BC\">スカラー</a>になりません。</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary")))) ("SciPyでベクトル量子化" "<p><span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vector\">Vector</a> Quantization: VQ）</span>とは、<span class=\"deco\" style=\"color:#FF0000;\">ベクトルで表されたデータ集合を有限個の代表的なパターン（セントロイド）に置き換える処理のことです</span>。代表パターン（セントロイド）のリストは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">コードブック（code book）</span>と呼ばれます。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の番号をコードと呼びます。各ベクトルデータは、距離が一番近いコードに置き換えられます。大量のデータを少ない代表パターンで置き換えることができるためデータの圧縮に使えます。ただし、コードブックから元のデータは復元できないため<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F3%B2%C4%B5%D5%B0%B5%BD%CC\">非可逆圧縮</a>になります。</p><p>コードブックを学習するためのアルゴリズムの代表例が<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a></span>です。ベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して、各データをそのデータが属する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドに置き換えることでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>が実現できます。</p>
<div class=\"section\">
<h4>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用</h4>
<p>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用例の一つに、前に取り上げた画像の<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Bag-of-Visual Words&#x8868;&#x73FE;</a>（2010/02/27）があります。Bag-of-Visual Wordsでは、ベクトルで表される画像の局所特徴量（SIFT、SURFなど）をK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。そして、K個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドをVisual Wordとし、各画像をVisual Wordの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現します。ここでは、Visual Wordsの集合がコードブックになりますね。</p><p>今回は、類似楽曲検索にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を応用する予定です。その場合、楽曲のMFCCベクトル集合がベクトルデータになり、これをK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類し、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の多次元分布（平均ベクトルと分散・共分散行列）を楽曲の特徴量とします。こうすることで、<span class=\"deco\" style=\"color:#FF0000;\">楽曲のMFCCベクトル集合をより少ないパラメータで表現できます</span>（データ次元の圧縮）。</p><p>まあ、応用は今後いろいろ試すことにして、ここでは単純な人工データでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を試してみます。</p>
</div>
<div class=\"section\">
<h4>SciPyでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a></h4>
<p>k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>は、以前実装しましたが、SciPyには、<a href=\"http://docs.scipy.org/doc/scipy/reference/cluster.vq.html#module-scipy.cluster.vq\">scipy.cluster.vq</a>というベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>に関するライブラリがあるのでそれを使ってみます。使うのは、コードブックを学習する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">kmeans()</span>関数とデータをベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">vq()</span>関数です。</p><p>この例では、3つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AC%A5%A6%A5%B9%CA%AC%C9%DB\">ガウス分布</a>から二次元データを100個ずつ生成しました。このベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してコードブックを求めています。そのコードブックをもとにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>して各データをコードに置き換えています。最後にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>されたデータをコード別に色分けして図示してみました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster
frompylab <span class=\"synPreProc\">import</span> *
<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
cls1 = []
cls2 = []
cls3 = []
<span class=\"synComment\"># 分布1</span>
mean1 = [-2, 2]
cov1 = [[1.0, 0.0], [0.0, 1.0]]
<span class=\"synComment\"># 分布2</span>
mean2 = [0, 0]
cov2 = [[1.0, 0.8], [0.8, 1.0]]
<span class=\"synComment\"># 分布3</span>
mean3 = [2, -2]
cov3 = [[0.5, 0.3], [0.8, 0.4]]
<span class=\"synComment\"># 分布にしたがうデータ生成</span>
cls1.extend(np.random.multivariate_normal(mean1, cov1, 100))
cls2.extend(np.random.multivariate_normal(mean2, cov2, 100))
cls3.extend(np.random.multivariate_normal(mean3, cov3, 100))
X = vstack((cls1, cls2, cls3))
<span class=\"synComment\"># データをクラスタリング</span>
codebook, destortion = scipy.cluster.vq.kmeans(X, 3, iter=20, thresh=1e-05)
<span class=\"synStatement\">print</span> codebook, destortion
<span class=\"synComment\"># ベクトル量子化</span>
<span class=\"synComment\"># 各データをセントロイドに分類する</span>
code, dist = scipy.cluster.vq.vq(X, codebook)
<span class=\"synComment\"># 各データをクラスタ別に色分けして描画</span>
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(X)):
x1, x2 = X[i, ]
<span class=\"synStatement\">if</span> code[i] == 0: color = '<span class=\"synConstant\">r+</span>'
<span class=\"synStatement\">elif</span> code[i] == 1: color = '<span class=\"synConstant\">b+</span>'
<span class=\"synStatement\">elif</span> code[i] == 2: color = '<span class=\"synConstant\">g+</span>'
plot(x1, x2, color)
<span class=\"synComment\"># セントロイドを描画</span>
x1, x2 = np.transpose(codebook)
plot(x1, x2, '<span class=\"synConstant\">yo</span>')
xlim(-6.0, 6.0)
ylim(-6.0, 6.0)
show()
</pre><p>実行するとこうなります。黄色い●がコードブックのセントロイドです。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120813192552\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120813/20120813192552.png\" alt=\"f:id:aidiary:20120813192552p:image\" title=\"f:id:aidiary:20120813192552p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>ちゃんと各データが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されていることがわかります。今回は、3つの分布からデータを生成したのでコードブックサイズ（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数、セントロイド数）は3としましたが、わからないときははいくつにすればいいんでしょうね？<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数を多くすればするほどkmeans()の返すdestortion（歪み）は小さくなり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の精度も上がるようです。だけどその代償としてコードブックのサイズは大きくなります。コードブックサイズと精度の間に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%EC%A1%BC%A5%C9%A5%AA%A5%D5\">トレードオフ</a>は応用や目的によって試行錯誤で決めるのかな？</p>
</div>" "http://aidiary.hatenablog.com/entry/20120813/1344853878" (20520 55158) old 3 nil nil ((title nil " SciPyでベクトル量子化") (link ((href . "http://aidiary.hatenablog.com/entry/20120813/1344853878"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656806") (updated nil "2012-08-13T19:31:18+09:00") (summary nil "ベクトル量子化（Vector Quantization: VQ）とは、ベクトルで表されたデータ集合を有限個の代表的なパターン（セントロイド）に置き換える処理のことです。代表パターン（セントロイド）のリストはコードブック（code book）と呼ばれます。また、クラスタの番号をコー") (content ((type . "html")) "<p><span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vector\">Vector</a> Quantization: VQ）</span>とは、<span class=\"deco\" style=\"color:#FF0000;\">ベクトルで表されたデータ集合を有限個の代表的なパターン（セントロイド）に置き換える処理のことです</span>。代表パターン（セントロイド）のリストは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">コードブック（code book）</span>と呼ばれます。また、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の番号をコードと呼びます。各ベクトルデータは、距離が一番近いコードに置き換えられます。大量のデータを少ない代表パターンで置き換えることができるためデータの圧縮に使えます。ただし、コードブックから元のデータは復元できないため<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C8%F3%B2%C4%B5%D5%B0%B5%BD%CC\">非可逆圧縮</a>になります。</p><p>コードブックを学習するためのアルゴリズムの代表例が<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a></span>です。ベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>して、各データをそのデータが属する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドに置き換えることでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>が実現できます。</p>

<div class=\"section\">
    <h4>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用</h4>
    <p>ベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の応用例の一つに、前に取り上げた画像の<a href=\"http://d.hatena.ne.jp/aidiary/20100227/1267277731\">Bag-of-Visual Words&#x8868;&#x73FE;</a>（2010/02/27）があります。Bag-of-Visual Wordsでは、ベクトルで表される画像の局所特徴量（SIFT、SURFなど）をK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類します。そして、K個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>のセントロイドをVisual Wordとし、各画像をVisual Wordの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>で表現します。ここでは、Visual Wordsの集合がコードブックになりますね。</p><p>今回は、類似楽曲検索にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を応用する予定です。その場合、楽曲のMFCCベクトル集合がベクトルデータになり、これをK個の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類し、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>の多次元分布（平均ベクトルと分散・共分散行列）を楽曲の特徴量とします。こうすることで、<span class=\"deco\" style=\"color:#FF0000;\">楽曲のMFCCベクトル集合をより少ないパラメータで表現できます</span>（データ次元の圧縮）。</p><p>まあ、応用は今後いろいろ試すことにして、ここでは単純な人工データでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>を試してみます。</p>

</div>
<div class=\"section\">
    <h4>SciPyでベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a></h4>
    <p>k-means<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>は、以前実装しましたが、SciPyには、<a href=\"http://docs.scipy.org/doc/scipy/reference/cluster.vq.html#module-scipy.cluster.vq\">scipy.cluster.vq</a>というベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>に関するライブラリがあるのでそれを使ってみます。使うのは、コードブックを学習する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">kmeans()</span>関数とデータをベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>する<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">vq()</span>関数です。</p><p>この例では、3つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AC%A5%A6%A5%B9%CA%AC%C9%DB\">ガウス分布</a>から二次元データを100個ずつ生成しました。このベクトルデータを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF%A5%EA%A5%F3%A5%B0\">クラスタリング</a>してコードブックを求めています。そのコードブックをもとにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>して各データをコードに置き換えています。最後にベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>されたデータをコード別に色分けして図示してみました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> scipy.cluster
frompylab <span class=\"synPreProc\">import</span> *

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    cls1 = []
    cls2 = []
    cls3 = []

    <span class=\"synComment\"># 分布1</span>
    mean1 = [-2, 2]
    cov1 = [[1.0, 0.0], [0.0, 1.0]]

    <span class=\"synComment\"># 分布2</span>
    mean2 = [0, 0]
    cov2 = [[1.0, 0.8], [0.8, 1.0]]

    <span class=\"synComment\"># 分布3</span>
    mean3 = [2, -2]
    cov3 = [[0.5, 0.3], [0.8, 0.4]]

    <span class=\"synComment\"># 分布にしたがうデータ生成</span>
    cls1.extend(np.random.multivariate_normal(mean1, cov1, 100))
    cls2.extend(np.random.multivariate_normal(mean2, cov2, 100))
    cls3.extend(np.random.multivariate_normal(mean3, cov3, 100))
    X = vstack((cls1, cls2, cls3))

    <span class=\"synComment\"># データをクラスタリング</span>
    codebook, destortion = scipy.cluster.vq.kmeans(X, 3, iter=20, thresh=1e-05)
    <span class=\"synStatement\">print</span> codebook, destortion

    <span class=\"synComment\"># ベクトル量子化</span>
    <span class=\"synComment\"># 各データをセントロイドに分類する</span>
    code, dist = scipy.cluster.vq.vq(X, codebook)

    <span class=\"synComment\"># 各データをクラスタ別に色分けして描画</span>
    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(X)):
        x1, x2 = X[i, ]

        <span class=\"synStatement\">if</span> code[i] == 0: color = '<span class=\"synConstant\">r+</span>'
        <span class=\"synStatement\">elif</span> code[i] == 1: color = '<span class=\"synConstant\">b+</span>'
        <span class=\"synStatement\">elif</span> code[i] == 2: color = '<span class=\"synConstant\">g+</span>'
        plot(x1, x2, color)

    <span class=\"synComment\"># セントロイドを描画</span>
    x1, x2 = np.transpose(codebook)
    plot(x1, x2, '<span class=\"synConstant\">yo</span>')

    xlim(-6.0, 6.0)
    ylim(-6.0, 6.0)
    show()
</pre><p>実行するとこうなります。黄色い●がコードブックのセントロイドです。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120813192552\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120813/20120813192552.png\" alt=\"f:id:aidiary:20120813192552p:image\" title=\"f:id:aidiary:20120813192552p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>ちゃんと各データが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>に分類されていることがわかります。今回は、3つの分布からデータを生成したのでコードブックサイズ（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数、セントロイド数）は3としましたが、わからないときははいくつにすればいいんでしょうね？<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%B9%A5%BF\">クラスタ</a>数を多くすればするほどkmeans()の返すdestortion（歪み）は小さくなり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>の精度も上がるようです。だけどその代償としてコードブックのサイズは大きくなります。コードブックサイズと精度の間に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%EC%A1%BC%A5%C9%A5%AA%A5%D5\">トレードオフ</a>は応用や目的によって試行錯誤で決めるのかな？</p>

</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary")))) ("ODEをMacにインストール" "<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Mountain Lion に物理シミュレーションエンジンの <a href=\"http://www.ode.org/\">Open Dynamics Engine</a> (ODE) を入れようとしてすごく苦労したのでまとめておきます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>にもodeはありますが、これだとdrawstuffというライブラリが入っていなかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>からコンパイルしています。</p><p>コンパイルに使ったg++は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>ではなく、Xcode4.4のものです。Xcode4.4の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>ツールのインストールは、<a href=\"http://memo.yomukaku.net/entries/UaLbzhE\">&#x3053;&#x3061;&#x3089;</a>を参考にしてください。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; which g++
/usr/bin/g++
&gt; ls -l /usr/bin/g++
lrwxr-xr-x  1 root  wheel  12  7 28 21:19 /usr/bin/g++@ -&gt; llvm-g++-4.2</pre><p><a href=\"http://www.ode.org/\">Open Dynamics Engine</a> のサイトから <span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ode-0.12.tar.bz2</span> をダウンロードし、倍精度でコンパイルしました。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>tar xvzf ode-0.12.tar.bz2
cd ode-0.12
./configure --enable-double-precision
make
sudo make install</pre><p>ここまでで、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/lib</span>と<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/include</span>にODEがインストールされますが、実はこれだけではダメでデフォルトだとなぜかdrawstuffがインストールされなかったです。なので、<span class=\"deco\" style=\"color:#FF0000;\">drawstuffのライブラリファイルとヘッダファイルを手動でコピー</span>します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>sudo cp drawstuff/src/.libs/libdrawstuff.* /usr/local/lib/
sudo mkdir /usr/local/include/drawstuff
sudo cp include/drawstuff/*.h /usr/local/include/drawstuff/</pre><p>また、デフォルトのテクスチャファイルはあとで使うので作業ディレクトリにコピーしておくとよいです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>cp -R drawstuff/textures ~/work</pre><p>最後に<a href=\"http://demura.net/tutorials\">ODE&#x30C1;&#x30E5;&#x30FC;&#x30C8;&#x30EA;&#x30A2;&#x30EB;</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>をコンパイルして動作確認。<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">fn.path_to_textures</span>のtexturesは先ほどテクスチャをコピーした場所を設定します。</p>
<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synComment\">/* sample.cpp */</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;ode/ode.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;drawstuff/drawstuff.h&gt;</span>
<span class=\"synPreProc\">#ifdef dDOUBLE</span>
<span class=\"synPreProc\">#define dsDrawSphere dsDrawSphereD</span>
<span class=\"synPreProc\">#endif</span>
<span class=\"synType\">static</span> dWorldID world;
dBodyID ball;
<span class=\"synType\">const</span> dReal radius = <span class=\"synConstant\">0.2</span>, mass = <span class=\"synConstant\">1.0</span>;
<span class=\"synType\">static</span> <span class=\"synType\">void</span> simLoop(<span class=\"synType\">int</span> pause) {
<span class=\"synType\">const</span> dReal *pos, *R;
dWorldStep(world, <span class=\"synConstant\">0.05</span>);
dsSetColor(<span class=\"synConstant\">1.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>);
pos = dBodyGetPosition(ball);
R = dBodyGetRotation(ball);
dsDrawSphere(pos, R, radius);
}
<span class=\"synType\">void</span> start() {
<span class=\"synType\">static</span> <span class=\"synType\">float</span> xyz[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">0.0</span>, -<span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">1.0</span>};
<span class=\"synType\">static</span> <span class=\"synType\">float</span> hpr[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">90.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>};
dsSetViewpoint(xyz, hpr);
}
<span class=\"synType\">int</span> main(<span class=\"synType\">int</span> argc, <span class=\"synType\">char</span> **argv) {
dReal x0 = <span class=\"synConstant\">0.0</span>, y0 = <span class=\"synConstant\">0.0</span>, z0 = <span class=\"synConstant\">1.0</span>;
dMass m1;
dsFunctions fn;
fn.version = DS_VERSION;
fn.start = &amp;start;
fn.step = &amp;simLoop;
fn.command = <span class=\"synConstant\">NULL</span>;
fn.stop = <span class=\"synConstant\">NULL</span>;
fn.path_to_textures = <span class=\"synConstant\">&quot;./textures&quot;</span>;
dInitODE();
world = dWorldCreate();
dWorldSetGravity(world, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, -<span class=\"synConstant\">0.01</span>);
ball = dBodyCreate(world);
dMassSetZero(&amp;m1);
dMassSetSphereTotal(&amp;m1, mass, radius);
dBodySetMass(ball, &amp;m1);
dBodySetPosition(ball, x0, y0, z0);
dsSimulationLoop(argc, argv, <span class=\"synConstant\">352</span>, <span class=\"synConstant\">288</span>, &amp;fn);
dWorldDestroy(world);
dCloseODE();
<span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>で、最後にコンパイルですが、ここではまりにはまった。まず、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE</pre><p>とやってみた。libodeとlibdrawstuffは、標準の/usr/local/libにあるので-Lでパスを指定する必要はないはず。それなのに、下のようなよくわからないコンパイルエラー。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>Undefined symbols for architecture x86_64:
\"_glBegin\", referenced from:
drawConvexD(double*, unsigned int, double*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
drawCapsule(float, float)in libdrawstuff.a(drawstuff.o)
drawCylinder(float, float, float)in libdrawstuff.a(drawstuff.o)
drawConvex(float*, unsigned int, float*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
drawBox(float const*)in libdrawstuff.a(drawstuff.o)
_dsDrawTriangleD in libdrawstuff.a(drawstuff.o)
_dsDrawLine in libdrawstuff.a(drawstuff.o)
...
ld: symbol(s) not found for architecture x86_64
collect2: ld returned 1 exit status</pre><p>このエラーは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Lion 以降頻発するらしくWeb上にいろいろ情報があったのですが、なかなか解決しなかった・・・</p><p>で、数時間格闘したあと、最終的に下のように<span class=\"deco\" style=\"color:#FF0000;\">-frameworkで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GLUT\">GLUT</a>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OpenGL\">OpenGL</a>を指定することでコンパイルできる</span>ことが判明。<a href=\"http://www44.atwiki.jp/kencyo/pages/14.html\">&#x3053;&#x3053;&#x306E;&#x30B5;&#x30A4;&#x30C8;</a>が決め手になりました。64bitとか関係あったの？？？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE -framework GLUT -framework OpenGL</pre><p>もしくは、ODEのコマンドode-configを使って下のようにも書けます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp `ode-config --cflags --libs` -ldrawstuff -framework GLUT -framework OpenGL</pre><p>ode-configは、ライブラリ、ヘッダファイルのパスとインストールしたときの精度を返してくれるようです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; ode-config --cflags --libs
-I/usr/local/include -DdDOUBLE
-L/usr/local/lib -lode</pre><p>よーし、これで動作確認もできたし、本格的に物理シミュで遊ぶぞ！</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120807094656\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120807/20120807094656.png\" alt=\"f:id:aidiary:20120807094656p:image\" title=\"f:id:aidiary:20120807094656p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>" "http://aidiary.hatenablog.com/entry/20120807/1344300689" (20512 26257) old 4 nil nil ((title nil " ODEをMacにインストール") (link ((href . "http://aidiary.hatenablog.com/entry/20120807/1344300689"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656808") (updated nil "2012-08-07T09:51:29+09:00") (summary nil "Mac OS X Mountain Lion に物理シミュレーションエンジンの Open Dynamics Engine (ODE) を入れようとしてすごく苦労したのでまとめておきます。macportsにもodeはありますが、これだとdrawstuffというライブラリが入っていな") (content ((type . "html")) "<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Mountain Lion に物理シミュレーションエンジンの <a href=\"http://www.ode.org/\">Open Dynamics Engine</a> (ODE) を入れようとしてすごく苦労したのでまとめておきます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>にもodeはありますが、これだとdrawstuffというライブラリが入っていなかったので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>からコンパイルしています。</p><p>コンパイルに使ったg++は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macports\">macports</a>ではなく、Xcode4.4のものです。Xcode4.4の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>ツールのインストールは、<a href=\"http://memo.yomukaku.net/entries/UaLbzhE\">&#x3053;&#x3061;&#x3089;</a>を参考にしてください。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; which g++
/usr/bin/g++
&gt; ls -l /usr/bin/g++
lrwxr-xr-x  1 root  wheel  12  7 28 21:19 /usr/bin/g++@ -&gt; llvm-g++-4.2</pre><p><a href=\"http://www.ode.org/\">Open Dynamics Engine</a> のサイトから <span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">ode-0.12.tar.bz2</span> をダウンロードし、倍精度でコンパイルしました。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>tar xvzf ode-0.12.tar.bz2
cd ode-0.12
./configure --enable-double-precision
make
sudo make install</pre><p>ここまでで、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/lib</span>と<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">/usr/local/include</span>にODEがインストールされますが、実はこれだけではダメでデフォルトだとなぜかdrawstuffがインストールされなかったです。なので、<span class=\"deco\" style=\"color:#FF0000;\">drawstuffのライブラリファイルとヘッダファイルを手動でコピー</span>します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>sudo cp drawstuff/src/.libs/libdrawstuff.* /usr/local/lib/
sudo mkdir /usr/local/include/drawstuff
sudo cp include/drawstuff/*.h /usr/local/include/drawstuff/</pre><p>また、デフォルトのテクスチャファイルはあとで使うので作業ディレクトリにコピーしておくとよいです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>cp -R drawstuff/textures ~/work</pre><p>最後に<a href=\"http://demura.net/tutorials\">ODE&#x30C1;&#x30E5;&#x30FC;&#x30C8;&#x30EA;&#x30A2;&#x30EB;</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>をコンパイルして動作確認。<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">fn.path_to_textures</span>のtexturesは先ほどテクスチャをコピーした場所を設定します。</p>
<pre class=\"code lang-cpp\" data-lang=\"cpp\" data-unlink><span class=\"synComment\">/* sample.cpp */</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;ode/ode.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;drawstuff/drawstuff.h&gt;</span>

<span class=\"synPreProc\">#ifdef dDOUBLE</span>
<span class=\"synPreProc\">#define dsDrawSphere dsDrawSphereD</span>
<span class=\"synPreProc\">#endif</span>

<span class=\"synType\">static</span> dWorldID world;
dBodyID ball;
<span class=\"synType\">const</span> dReal radius = <span class=\"synConstant\">0.2</span>, mass = <span class=\"synConstant\">1.0</span>;

<span class=\"synType\">static</span> <span class=\"synType\">void</span> simLoop(<span class=\"synType\">int</span> pause) {
    <span class=\"synType\">const</span> dReal *pos, *R;
    dWorldStep(world, <span class=\"synConstant\">0.05</span>);
    dsSetColor(<span class=\"synConstant\">1.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>);
    pos = dBodyGetPosition(ball);
    R = dBodyGetRotation(ball);
    dsDrawSphere(pos, R, radius);
}

<span class=\"synType\">void</span> start() {
    <span class=\"synType\">static</span> <span class=\"synType\">float</span> xyz[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">0.0</span>, -<span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">1.0</span>};
    <span class=\"synType\">static</span> <span class=\"synType\">float</span> hpr[<span class=\"synConstant\">3</span>] = {<span class=\"synConstant\">90.0</span>, <span class=\"synConstant\">0.0</span>, <span class=\"synConstant\">0.0</span>};
    dsSetViewpoint(xyz, hpr);
}

<span class=\"synType\">int</span> main(<span class=\"synType\">int</span> argc, <span class=\"synType\">char</span> **argv) {
    dReal x0 = <span class=\"synConstant\">0.0</span>, y0 = <span class=\"synConstant\">0.0</span>, z0 = <span class=\"synConstant\">1.0</span>;
    dMass m1;

    dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start = &amp;start;
    fn.step = &amp;simLoop;
    fn.command = <span class=\"synConstant\">NULL</span>;
    fn.stop = <span class=\"synConstant\">NULL</span>;
    fn.path_to_textures = <span class=\"synConstant\">&quot;./textures&quot;</span>;

    dInitODE();
    world = dWorldCreate();
    dWorldSetGravity(world, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, -<span class=\"synConstant\">0.01</span>);

    ball = dBodyCreate(world);
    dMassSetZero(&amp;m1);
    dMassSetSphereTotal(&amp;m1, mass, radius);
    dBodySetMass(ball, &amp;m1);
    dBodySetPosition(ball, x0, y0, z0);

    dsSimulationLoop(argc, argv, <span class=\"synConstant\">352</span>, <span class=\"synConstant\">288</span>, &amp;fn);

    dWorldDestroy(world);
    dCloseODE();

    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>で、最後にコンパイルですが、ここではまりにはまった。まず、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE</pre><p>とやってみた。libodeとlibdrawstuffは、標準の/usr/local/libにあるので-Lでパスを指定する必要はないはず。それなのに、下のようなよくわからないコンパイルエラー。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>Undefined symbols for architecture x86_64:
  &#34;_glBegin&#34;, referenced from:
      drawConvexD(double*, unsigned int, double*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
      drawCapsule(float, float)in libdrawstuff.a(drawstuff.o)
      drawCylinder(float, float, float)in libdrawstuff.a(drawstuff.o)
      drawConvex(float*, unsigned int, float*, unsigned int, unsigned int*)in libdrawstuff.a(drawstuff.o)
      drawBox(float const*)in libdrawstuff.a(drawstuff.o)
      _dsDrawTriangleD in libdrawstuff.a(drawstuff.o)
      _dsDrawLine in libdrawstuff.a(drawstuff.o)
      ...
ld: symbol(s) not found for architecture x86_64
collect2: ld returned 1 exit status</pre><p>このエラーは <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac%20OS%20X\">Mac OS X</a> Lion 以降頻発するらしくWeb上にいろいろ情報があったのですが、なかなか解決しなかった・・・</p><p>で、数時間格闘したあと、最終的に下のように<span class=\"deco\" style=\"color:#FF0000;\">-frameworkで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GLUT\">GLUT</a>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OpenGL\">OpenGL</a>を指定することでコンパイルできる</span>ことが判明。<a href=\"http://www44.atwiki.jp/kencyo/pages/14.html\">&#x3053;&#x3053;&#x306E;&#x30B5;&#x30A4;&#x30C8;</a>が決め手になりました。64bitとか関係あったの？？？</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp -lode -ldrawstuff -DdDOUBLE -framework GLUT -framework OpenGL</pre><p>もしくは、ODEのコマンドode-configを使って下のようにも書けます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>g++ sample.cpp `ode-config --cflags --libs` -ldrawstuff -framework GLUT -framework OpenGL</pre><p>ode-configは、ライブラリ、ヘッダファイルのパスとインストールしたときの精度を返してくれるようです。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; ode-config --cflags --libs
-I/usr/local/include -DdDOUBLE
-L/usr/local/lib -lode</pre><p>よーし、これで動作確認もできたし、本格的に物理シミュで遊ぶぞ！</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120807094656\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120807/20120807094656.png\" alt=\"f:id:aidiary:20120807094656p:image\" title=\"f:id:aidiary:20120807094656p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>
") (category ((term . "ロボティクス") (label . "ロボティクス"))) (author nil (name nil "aidiary")))) ("SPTKの使い方 (6) MFCCの抽出" "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120801/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (5)</a>（2012/8/1）の続き。</p><p>今回は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>の特徴量としてよく使われるメル周波数ケプストラム係数 <a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">MFCC</a>（2012/2/25）をSPTKで抽出してみました。使うコマンドは、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">mfcc</span>です<a href=\"#f1\" name=\"fn1\" title=\"例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・\">*1</a>。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 &gt; data.mfc</pre><p>パラメータの意味は、</p>
<table>
<tr>
<td>-l</td>
<td>640</td>
<td>フレーム長は640サンプル</td>
</tr>
<tr>
<td>-f</td>
<td>16</td>
<td>サンプリング周波数は16kHz</td>
</tr>
<tr>
<td>-m</td>
<td>12</td>
<td>MFCCの次元は12次元</td>
</tr>
<tr>
<td>-n</td>
<td>20</td>
<td>メルフィルタバンクのチャンネル数は20</td>
</tr>
<tr>
<td>-a</td>
<td>0.97</td>
<td>プリエンファシス係数は0.97</td>
</tr>
</table><p>です。まあ、-lと-fと-m以外はデフォルトでいいかな？mfccコマンドには、-c 22（リフタリング係数）というオプションもあったのですが、これは何だろう？私が認識していたMFCCの抽出手順は、</p>
<ol>
<li>プリエンファシスフィルタで波形の高域成分を強調する（-a）</li>
<li>窓関数をかけた後に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを求める（-l, -f）</li>
<li>振幅スペクトルにメルフィルタバンクをかけて圧縮する（-n）</li>
<li>上記の圧縮した数値列を信号とみなして離散コサイン変換する</li>
<li>得られたケプストラムの低次成分がMFCC（-m）</li>
</ol><p>だったのですが、リフタリングはどこでするのだろう・・・一番最後で低次成分をとるところなのかな？私の認識だとDCTしたあとに出てくる係数を単純に上から-m個とったもの（=低次成分のみ取り出す）がmfccだと思っているのだけど、それだと-cとはどこで使うのだろう？どなたか知ってたら教えてください。</p><p>先のコマンドを実行すると各フレームのMFCCが抽出されます。data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>はバイナリファイルなので文字列で出力する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトを書きました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synComment\"># print_mfcc.py</span>
<span class=\"synStatement\">if</span> len(sys.argv) != 3:
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python print_mfcc.py [mfcc_file] [m]</span>&quot;
sys.exit()
mfccfile = sys.argv[1]
m = int(sys.argv[2])
mfcc = []
f = open(mfccfile, &quot;<span class=\"synConstant\">rb</span>&quot;)
<span class=\"synStatement\">while</span> True:
b = f.read(4)
<span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>;
val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
mfcc.append(val)
f.close()
mfcc = np.array(mfcc)
numframe = len(mfcc) / m
<span class=\"synStatement\">if</span> numframe * m != len(mfcc):
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: #mfcc:%d #frame:%d m:%d</span>&quot; % (len(mfcc), numframe, m)
sys.exit(1)
mfcc = mfcc.reshape(numframe, m)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)):
<span class=\"synStatement\">print</span> &quot;<span class=\"synSpecial\">\\t</span>&quot;.join(&quot;<span class=\"synConstant\">%.2f</span>&quot; % x <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> mfcc[i,])
</pre><p>第二引数は、MFCCの次元数です。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc data.mfc 12
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77
・・・</pre><p>こんな感じに各フレームのMFCCの12次元ベクトルが表示されます。各行がフレームです。</p><p> -Eオプションをつけると、MFCCに加えてエネルギーも出力することができます。MFCCの12次元+エネルギーで13次元ベクトルにするって設定はよく見かけますね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 -E &gt; data.mfc</pre><p>表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py data.mfc 13
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65	10.51
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40	11.07
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27	11.42
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77	11.75</pre><p>13列目がエネルギーです。MFCCに比べて少し大きい値になってます。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>では、MFCC12次元+エネルギーの13次元ベクトルにさらに動的特徴量としてΔMFCCの13次元とΔΔMFCCの13次元を加えて39次元ベクトルにすることが多いと思いますが、これは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">delta</span>コマンドを使うとできます。SPTKのマニュアルのmfccコマンドのところにdeltaを使った例が書いてありました。これは別の機会に試してみます。</p><p>MFCCの抽出は、他にも<a href=\"http://htk.eng.cam.ac.uk/\">HTK</a>というツールキットのHCopyコマンドでもできました（<a href=\"http://shower.human.waseda.ac.jp/~m-kouki/pukiwiki_public/106.html\">MFCC&#x89E3;&#x6790;&#x306E;&#x30C4;&#x30FC;&#x30EB;</a>）が、SPTKの方が使うの簡単かも。というか、HCopyが出力するmfccのバイナリフォーマットがよくわからなかった・・・<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTK\">HTK</a>のマニュアルに書いてあるのかな？</p>
<div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・</span></p>
</div>" "http://aidiary.hatenablog.com/entry/20120805/1343825329" (20510 27569) old 5 nil nil ((title nil " SPTKの使い方 (6) MFCCの抽出") (link ((href . "http://aidiary.hatenablog.com/entry/20120805/1343825329"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656810") (updated nil "2012-08-05T21:48:49+09:00") (summary nil "SPTKの使い方 (5)（2012/8/1）の続き。今回は、音声認識の特徴量としてよく使われるメル周波数ケプストラム係数 MFCC（2012/2/25）をSPTKで抽出してみました。使うコマンドは、mfccです*1。 x2x +sf < data.short| frame -l ") (content ((type . "html")) "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120801/1343825329\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (5)</a>（2012/8/1）の続き。</p><p>今回は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>の特徴量としてよく使われるメル周波数ケプストラム係数 <a href=\"http://d.hatena.ne.jp/aidiary/20120225/1330179868\">MFCC</a>（2012/2/25）をSPTKで抽出してみました。使うコマンドは、<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">mfcc</span>です<a href=\"#f1\" name=\"fn1\" title=\"例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・\">*1</a>。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 &gt; data.mfc</pre><p>パラメータの意味は、</p>

<table>
    <tr>
    <td>-l</td>
    <td>640</td>
    <td>フレーム長は640サンプル</td>
    </tr>
    <tr>
    <td>-f</td>
    <td>16</td>
    <td>サンプリング周波数は16kHz</td>
    </tr>
    <tr>
    <td>-m</td>
    <td>12</td>
    <td>MFCCの次元は12次元</td>
    </tr>
    <tr>
    <td>-n</td>
    <td>20</td>
    <td>メルフィルタバンクのチャンネル数は20</td>
    </tr>
    <tr>
    <td>-a</td>
    <td>0.97</td>
    <td>プリエンファシス係数は0.97</td>
    </tr>
</table><p>です。まあ、-lと-fと-m以外はデフォルトでいいかな？mfccコマンドには、-c 22（リフタリング係数）というオプションもあったのですが、これは何だろう？私が認識していたMFCCの抽出手順は、</p>

<ol>
<li>プリエンファシスフィルタで波形の高域成分を強調する（-a）</li>
<li>窓関数をかけた後に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを求める（-l, -f）</li>
<li>振幅スペクトルにメルフィルタバンクをかけて圧縮する（-n）</li>
<li>上記の圧縮した数値列を信号とみなして離散コサイン変換する</li>
<li>得られたケプストラムの低次成分がMFCC（-m）</li>
</ol><p>だったのですが、リフタリングはどこでするのだろう・・・一番最後で低次成分をとるところなのかな？私の認識だとDCTしたあとに出てくる係数を単純に上から-m個とったもの（=低次成分のみ取り出す）がmfccだと思っているのだけど、それだと-cとはどこで使うのだろう？どなたか知ってたら教えてください。</p><p>先のコマンドを実行すると各フレームのMFCCが抽出されます。data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mfc\">mfc</a>はバイナリファイルなので文字列で出力する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>スクリプトを書きました。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> struct
<span class=\"synPreProc\">import</span> sys
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np

<span class=\"synComment\"># print_mfcc.py</span>

<span class=\"synStatement\">if</span> len(sys.argv) != 3:
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">usage: python print_mfcc.py [mfcc_file] [m]</span>&quot;
    sys.exit()

mfccfile = sys.argv[1]
m = int(sys.argv[2])

mfcc = []
f = open(mfccfile, &quot;<span class=\"synConstant\">rb</span>&quot;)
<span class=\"synStatement\">while</span> True:
    b = f.read(4)
    <span class=\"synStatement\">if</span> b == &quot;&quot;: <span class=\"synStatement\">break</span>;
    val = struct.unpack(&quot;<span class=\"synConstant\">f</span>&quot;, b)[0]
    mfcc.append(val)
f.close()

mfcc = np.array(mfcc)
numframe = len(mfcc) / m

<span class=\"synStatement\">if</span> numframe * m != len(mfcc):
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: #mfcc:%d #frame:%d m:%d</span>&quot; % (len(mfcc), numframe, m)
    sys.exit(1)

mfcc = mfcc.reshape(numframe, m)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(len(mfcc)):
    <span class=\"synStatement\">print</span> &quot;<span class=\"synSpecial\">\\t</span>&quot;.join(&quot;<span class=\"synConstant\">%.2f</span>&quot; % x <span class=\"synStatement\">for</span> x <span class=\"synStatement\">in</span> mfcc[i,])
</pre><p>第二引数は、MFCCの次元数です。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc data.mfc 12
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77
・・・</pre><p>こんな感じに各フレームのMFCCの12次元ベクトルが表示されます。各行がフレームです。</p><p> -Eオプションをつけると、MFCCに加えてエネルギーも出力することができます。MFCCの12次元+エネルギーで13次元ベクトルにするって設定はよく見かけますね。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short| frame -l 640 -p 160 | \\ 
mfcc -l 640 -f 16 -m 12 -n 20 -a 0.97 -E &gt; data.mfc</pre><p>表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python print_mfcc.py data.mfc 13
-11.75	-0.31	-6.73	0.24	4.32	3.89	-1.38	2.27	3.07	8.11	-0.63	-1.65	10.51
-12.45	0.51	-5.58	1.54	2.47	1.90	-1.73	2.38	7.31	8.20	-1.47	-2.40	11.07
-13.48	1.95	-3.17	4.40	4.20	1.41	-1.68	1.34	5.90	6.95	-0.02	-0.27	11.42
-14.92	5.96	-0.64	5.05	3.75	-0.11	-0.73	1.75	2.97	3.35	1.52	-1.77	11.75</pre><p>13列目がエネルギーです。MFCCに比べて少し大きい値になってます。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%BB%C0%BC%C7%A7%BC%B1\">音声認識</a>では、MFCC12次元+エネルギーの13次元ベクトルにさらに動的特徴量としてΔMFCCの13次元とΔΔMFCCの13次元を加えて39次元ベクトルにすることが多いと思いますが、これは<span class=\"deco\" style=\"color:#FF0000;font-weight:bold;\">delta</span>コマンドを使うとできます。SPTKのマニュアルのmfccコマンドのところにdeltaを使った例が書いてありました。これは別の機会に試してみます。</p><p>MFCCの抽出は、他にも<a href=\"http://htk.eng.cam.ac.uk/\">HTK</a>というツールキットのHCopyコマンドでもできました（<a href=\"http://shower.human.waseda.ac.jp/~m-kouki/pukiwiki_public/106.html\">MFCC&#x89E3;&#x6790;&#x306E;&#x30C4;&#x30FC;&#x30EB;</a>）が、SPTKの方が使うの簡単かも。というか、HCopyが出力するmfccのバイナリフォーマットがよくわからなかった・・・<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/HTK\">HTK</a>のマニュアルに書いてあるのかな？</p>
<div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">例題集の3章にあるメルケプストラム（mcepコマンド）をMFCCと勘違いしていたのですが違うものでした・・・</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary")))) ("Earth Mover's Distance (EMD)" "<p><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth Mover's Distance (EMD) </a>について調べたことを整理しておきます。EMDは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離のような距離尺度の一つで、二つの分布の間の距離を測ることができます。言語処理ではあまり聞いたことなかったのですが、画像処理や音声処理では比較的有名な距離尺度のようです。</p><p>EMDが使える問題設定は下図のようになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804130722\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804130722.png\" alt=\"f:id:aidiary:20120804130722p:image\" title=\"f:id:aidiary:20120804130722p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは特徴量と重みの集合（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と呼ぶ）で与えられる分布Pと分布Qの間の距離</span>です。ここで、<span class=\"deco\" style=\"color:#FF0000;\">特徴量間では距離 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> が定義されている</span>のが前提です。特徴量がベクトルのときは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離、特徴量が確率分布のときはカルバック・ライブラー距離（情報量）などです。EMDは、特徴量の集合が2つ与えられたときに、1個1個の特徴量間の距離をもとに、特徴量集合間の距離を求められるんですね。これはすごい。</p><p>重みは具体的な応用によって使い方が変わりますが、その特徴量の重要度を表しています。たとえば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>だったら各棒が特徴量にあたり、棒の高さが重みにあたります。前に<a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a> (2009/10/3）で、画像の色の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>からHistogram Intersectionという距離を使いましたが、EMDを使って距離を求めることもできます。参考文献にあげたEMDの原論文は類似画像検索を対象にしています。</p><p>EMDなんて使わず、もっと単純に全特徴量のあらゆる組み合わせ間の距離の総和でもいいんじゃね？と思いましたけど、これだけだと重みを完全に無視していますね・・・重みが重要なんです！</p>
<div class=\"section\">
<h4>考え方の基本は輸送問題</h4>
<p>EMDの定義は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C7%C5%AC%B2%BD%CC%E4%C2%EA\">最適化問題</a>の1つの<span class=\"deco\" style=\"color:#FF0000;\">輸送問題（Transportation Problem）</span>の考え方に基づいています。なのでまずは輸送問題について簡単にまとめます。先の図において、Pの各場所P1, ... ,Pmには、重みの量だけ荷物が積まれているとします。そして、Qの各場所Q1, ... ,Qnには重みの量だけ格納できる倉庫があるとします。このとき、Pにある荷物をすべてQに運ぶ<a href=\"#f1\" name=\"fn1\" title=\"実際はすべてではなくQに入る分だけでOK\">*1</a>とき、どこからどこへどのくらい運ぶともっとも効率がよいかを求めるのが輸送問題です。</p><p>ここで、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送するコスト（距離）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> とし、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送する荷物量（フロー）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> と定義します。そして、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ運ぶのに要する仕事量を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D%20%2A%20f_%7Bij%7D\" alt=\"d_{ij} * f_{ij}\"/> と定義します。たとえば、距離が遠いところに大量の荷物を運ぶとそれだけ仕事量が増えるので直感とも一致します。このとき、総仕事量Wを下のように定義すると、W を最小化する <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> を求めればもっとも効率のよい運び方だとわかります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134057\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134057.png\" alt=\"f:id:aidiary:20120804134057p:image\" title=\"f:id:aidiary:20120804134057p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> は与えられるのが前提なので、<span class=\"deco\" style=\"color:#FF0000;\">最適化する変数は輸送量</span> <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> だけです。そして、輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> には下の4つの制約が加えられます。</p><p>(1) かならずPからQへ輸送する。逆方向はない。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134157\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134157.png\" alt=\"f:id:aidiary:20120804134157p:image\" title=\"f:id:aidiary:20120804134157p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
<br />
(2) Piにある荷物以上は輸送できない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134355\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134355.png\" alt=\"f:id:aidiary:20120804134355p:image\" title=\"f:id:aidiary:20120804134355p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(3) <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a>にある倉庫の容量以上は荷物を受け付けられない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134420\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134420.png\" alt=\"f:id:aidiary:20120804134420p:image\" title=\"f:id:aidiary:20120804134420p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(4) 輸送量の上限は、荷物の総量か倉庫の総容量の小さい方</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134434\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134434.png\" alt=\"f:id:aidiary:20120804134434p:image\" title=\"f:id:aidiary:20120804134434p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>最後の条件は荷物の総量と倉庫の容量が違うときに必要です。荷物総量より倉庫の総容量が大きかったら全部輸送できるので輸送量の上限は荷物の総量となりますが、荷物が倉庫の量より多かったら全部輸送できないので輸送量の上限は倉庫の総容量になります。今回、取り上げる例題は荷物の総量と倉庫の総容量は同じとしています。</p><p>輸送問題の解き方は省略しますが、解くと最適な <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> が求まります。EMDはこの <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> を用いて下のように定義されます。輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> の合計で割っているのは、輸送量によってEMDのスケールが変わらないように正規化しているためですね。これはあとで具体例で確認してみます。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134804\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134804.png\" alt=\"f:id:aidiary:20120804134804p:image\" title=\"f:id:aidiary:20120804134804p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは輸送に必要な最適な仕事量が小さいほど二つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の距離は近い</span>という考え方なのでわりと自然な考え方だと思います。ただし、あらゆる特徴量間の組み合わせについて足し合わせが必要なので特徴量の数が多くなると計算量は非常に大きくなりそうです。そのため、特徴量の数が爆発しないようにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>と組み合わせて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を作る手法が提案されています。これは、後に紹介予定です。</p>
</div>
<div class=\"section\">
<h4>EMDの定義がわかったところで具体例を解いてみます</h4>
<p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804135712\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804135712.png\" alt=\"f:id:aidiary:20120804135712p:image\" title=\"f:id:aidiary:20120804135712p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>この例は、EMDの提案者の<a href=\"http://ai.stanford.edu/~rubner/emd/default.htm\">Rubner&#x3055;&#x3093;&#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;</a>に出てくる例題です。特徴量は3次元ベクトルで重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>で与えられています。特徴量の値が0から255の3次元ベクトルなので、分布Pが画像1のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>、分布Qが画像2のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>を表しているようです。この分布Pと分布QのEMDを計算してみます！</p>
</div>
<div class=\"section\">
<h4>Rubnerの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</h4>
<p>まずは、Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>のコードを使ってみます（<a href=\"http://ai.stanford.edu/~rubner/emd/example1.c\">example1.c</a>）。実行には、<a href=\"http://ai.stanford.edu/~rubner/emd/emd.c\">emd.c</a>と<a href=\"http://ai.stanford.edu/~rubner/emd/emd.h\">emd.h</a>が必要です。また、emd.hのfeature_tの定義を問題に合わせて書き換える必要があります。今回は、特徴量が3次元ベクトルなので</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">typedef</span> <span class=\"synType\">struct</span> { <span class=\"synType\">int</span> X,Y,Z; } feature_t;
</pre><p>と定義しています。emd.cのライブラリを使って上の例題を解くコードです。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;stdio.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;math.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;emd.h&quot;</span>
<span class=\"synComment\">/* ユークリッド距離 */</span>
<span class=\"synType\">float</span> dist(feature_t *F1, feature_t *F2) {
<span class=\"synType\">int</span> dX = F1-&gt;X - F2-&gt;X;
<span class=\"synType\">int</span> dY = F1-&gt;Y - F2-&gt;Y;
<span class=\"synType\">int</span> dZ = F1-&gt;Z - F2-&gt;Z;
<span class=\"synStatement\">return</span> sqrt(dX*dX + dY*dY + dZ*dZ);
}
<span class=\"synType\">int</span> main() {
<span class=\"synComment\">/* 分布Pの特徴ベクトル */</span>
feature_t f1[<span class=\"synConstant\">4</span>] = { {<span class=\"synConstant\">100</span>,<span class=\"synConstant\">40</span>,<span class=\"synConstant\">22</span>}, {<span class=\"synConstant\">211</span>,<span class=\"synConstant\">20</span>,<span class=\"synConstant\">2</span>}, {<span class=\"synConstant\">32</span>,<span class=\"synConstant\">190</span>,<span class=\"synConstant\">150</span>}, {<span class=\"synConstant\">2</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">100</span>} };
<span class=\"synComment\">/* 分布Qの特徴ベクトル */</span>
feature_t f2[<span class=\"synConstant\">3</span>] = { {<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>}, {<span class=\"synConstant\">50</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">80</span>}, {<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>} };
<span class=\"synComment\">/* 分布Pの重み */</span>
<span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">0.4</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span>, <span class=\"synConstant\">0.1</span> };
<span class=\"synComment\">/* 分布Qの重み */</span>
<span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">0.5</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span> };
<span class=\"synComment\">/* 分布Pのシグネチャ */</span>
signature_t s1 = { <span class=\"synConstant\">4</span>, f1, w1 };
<span class=\"synComment\">/* 分布Qのシグネチャ */</span>
signature_t s2 = { <span class=\"synConstant\">3</span>, f2, w2};
<span class=\"synComment\">/* EMDを計算 */</span>
<span class=\"synType\">float</span> e;
e = emd(&amp;s1, &amp;s2, dist, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>);
printf(<span class=\"synConstant\">&quot;emd = </span><span class=\"synSpecial\">%f\\n</span><span class=\"synConstant\">&quot;</span>, e);
<span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>emd()関数に2つの分布の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と特徴量間の距離を計算する関数を指定しています。この実装では、重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4\">浮動小数</a>点になっています。合計するとどちらも1.0になるので荷物総量と倉庫の総容量は等しくなっています。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>emd = 160.542770</pre><p>よって、分布Pと分布Qの距離は、160.54とわかります。先に書いたようにEMDは、輸送量で正規化しているため下のように比率を保ったまま重みを変えても結果は同じになります。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink>    <span class=\"synComment\">/* 分布Pの重み */</span>
<span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">4.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span>, <span class=\"synConstant\">1.0</span> };
<span class=\"synComment\">/* 分布Qの重み */</span>
<span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">5.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span> };
</pre>
</div>
<div class=\"section\">
<h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>による実装</h4>
<p>次は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で同じ例題を解いてみます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で輸送問題を解く関数は、<a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a>というライブラリに含まれていますが、標準では入っていないのでインストールします。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>install.packages<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;lpSolve&quot;</span><span class=\"synSpecial\">)</span>
</pre><p>以下のemd_sample.Rファイルを作成します。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>library<span class=\"synSpecial\">(</span>lpSolve<span class=\"synSpecial\">)</span>
<span class=\"synComment\"># ユークリッド距離</span>
euclid_dist <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">,</span> f2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
<span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>sqrt<span class=\"synSpecial\">(</span>sum<span class=\"synSpecial\">((</span>f1 - f2<span class=\"synSpecial\">)</span>^<span class=\"synConstant\">2</span><span class=\"synSpecial\">)))</span>
<span class=\"synSpecial\">}</span>
<span class=\"synComment\"># EMDを計算</span>
emd <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
<span class=\"synComment\"># lp.transport()を使うための準備</span>
costs <span class=\"synStatement\">&lt;-</span> dist
row.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&lt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w1<span class=\"synSpecial\">))</span>
row.rhs <span class=\"synStatement\">&lt;-</span> w1
col.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&gt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w2<span class=\"synSpecial\">))</span>
col.rhs <span class=\"synStatement\">&lt;-</span> w2
<span class=\"synComment\"># 輸送問題を解く</span>
t <span class=\"synStatement\">&lt;-</span> lp.transport<span class=\"synSpecial\">(</span>costs<span class=\"synSpecial\">,</span> <span class=\"synConstant\">&quot;min&quot;</span><span class=\"synSpecial\">,</span> row.signs<span class=\"synSpecial\">,</span> row.rhs<span class=\"synSpecial\">,</span> col.signs<span class=\"synSpecial\">,</span> col.rhs<span class=\"synSpecial\">)</span>
<span class=\"synComment\"># 最適な輸送量を取得</span>
flow <span class=\"synStatement\">&lt;-</span> t$solution
<span class=\"synComment\"># 仕事量を計算</span>
work <span class=\"synStatement\">&lt;-</span> sum<span class=\"synSpecial\">(</span>flow * dist<span class=\"synSpecial\">)</span>
<span class=\"synComment\"># 正規化してEMDを計算</span>
e <span class=\"synStatement\">&lt;-</span> work / sum<span class=\"synSpecial\">(</span>flow<span class=\"synSpecial\">)</span>
<span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>e<span class=\"synSpecial\">)</span>
<span class=\"synSpecial\">}</span>
<span class=\"synComment\"># 特徴量</span>
f1 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">40</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">22</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">211</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">20</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">32</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">190</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">150</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>
f2 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">50</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">80</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>
<span class=\"synComment\"># 重み（要整数！）</span>
w1 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">)</span>
w2 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">5</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">)</span>
n1 = length<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>
n2 = length<span class=\"synSpecial\">(</span>f2<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>
<span class=\"synComment\"># 距離行列を作成</span>
dist = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> n1<span class=\"synSpecial\">,</span> n2<span class=\"synSpecial\">)</span>
<span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>i <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n1<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
<span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>j <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
dist<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,</span> j<span class=\"synSpecial\">]</span> = euclid_dist<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,],</span> f2<span class=\"synSpecial\">[</span>j<span class=\"synSpecial\">,])</span>
<span class=\"synSpecial\">}</span>
<span class=\"synSpecial\">}</span>
<span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
e = emd<span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span>
cat<span class=\"synSpecial\">(</span>sprintf<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd = %f\\n&quot;</span><span class=\"synSpecial\">,</span> e<span class=\"synSpecial\">))</span>
</pre><p>この実装では、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を渡さずに、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>から計算した距離行列と重みを渡しています。lp.transport()が距離行列を受け付けるのでそれに合わせましたが、まあ、どっちでもよいと思います。Rを起動して以下のように打つと実行できます。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>&gt; source<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd_sample.R&quot;</span><span class=\"synSpecial\">)</span>
emd = <span class=\"synConstant\">160.542763</span>
</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>版と同じ結果になりました！ただ、距離行列の計算がRっぽい書き方でないので効率悪いかも。もっといい書き方があったら教えてください。</p>
</div>
<div class=\"section\">
<h4>それでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>で書きたいんだよ！</h4>
<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>の<a href=\"http://www.scipy.org/\">SciPy</a>にはlp.transport()に対応する関数はないようです。他の最適化ライブラリ（<a href=\"http://openopt.org/Welcome\">openopt</a>や<a href=\"http://abel.ee.ucla.edu/cvxopt/\">cvxopt</a>）もざっと探しましたが見つけられませんでした。自分で書いてもよかったのですが、せっかくRの関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>からRのlp.transport()を呼び出してみます。</p><p><a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>は、Rの機能を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出せるようにする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>ライブラリです。使い方はやや複雑ですが、今回のように<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>になくてRにあるアルゴリズムもたくさんあるので使えるとはかどります。まあ、Rをラッパーしているのでちょっと複雑になっちゃうけどね。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects
<span class=\"synComment\"># Rのlp.transport()をインポート</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">euclid_dist</span>(feature1, feature2):
&quot;&quot;&quot;<span class=\"synConstant\">ユークリッド距離を計算</span>&quot;&quot;&quot;
<span class=\"synStatement\">if</span> len(feature1) != len(feature2):
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: calc euclid_dist: %d &lt;=&gt; %d</span>&quot; % (len(feature1), len(feature2))
<span class=\"synStatement\">return</span> -1
<span class=\"synStatement\">return</span> np.sqrt(np.sum((feature1 - feature2) ** 2))
<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">emd</span>(dist, w1, w2):
&quot;&quot;&quot;<span class=\"synConstant\">Rのtransport()関数を使ってEMDを計算</span>&quot;&quot;&quot;
<span class=\"synComment\"># transport()の引数を用意</span>
costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
nrow=len(w1), ncol=len(w2),
byrow=True)
row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
row_rhs = robjects.FloatVector(w1)
col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
col_rhs = robjects.FloatVector(w2)
t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
flow = t.rx2('<span class=\"synConstant\">solution</span>')
dist = dist.reshape(len(w1), len(w2))
flow = np.array(flow)
work = np.sum(flow * dist)
emd = work / np.sum(flow)
<span class=\"synStatement\">return</span> emd
<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
f1 = np.array([ [100, 40, 22], [211, 20, 2], [32, 190, 150], [2, 100, 100] ])
f2 = np.array([ [0, 0, 0], [50, 100, 80], [255, 255, 255] ])
<span class=\"synComment\"># 重みは自然数のみ</span>
w1 = np.array([4, 3, 2, 1])
w2 = np.array([5, 3, 2])
n1 = len(f1)
n2 = len(f2)
<span class=\"synComment\"># 距離行列を作成</span>
dist = np.zeros(n1 * n2)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(n1):
<span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(n2):
dist[i * n2 + j] = euclid_dist(f1[i], f2[j])
<span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
<span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">emd =</span>&quot;, emd(dist, w1, w2)
</pre><p>実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python emd_sample.py
emd = 160.542762808</pre><p>となり、CやRと同じ結果が得られました。</p>
</div>
<div class=\"section\">
<h4>おわりに</h4>
<p>今回は、EMDについて調べたことをまとめてみました。できるだけ正確に書くようにしましたが、誤りもあるかもしれません。鵜呑みにしないで他の資料も当たってみてください。</p><p>あとで、EMDを類似楽曲検索という具体的な問題に応用してみる予定です。乞うご期待。</p>
</div>
<div class=\"section\">
<h4>参考文献</h4>
<ul>
<li><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth mover's distance</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Wikipedia\">Wikipedia</a></li>
<li>Y. Rubner, C. Tomasi and L. J. Guibas: <a href=\"http://vision.stanford.edu/~rubner/papers/rubnerIjcv00.pdf\">The earth mover's distance as a metric for image retrieval</a> (PDF), International Journal of Computer Vision, 40(2), pp.99-121, 2000 - EMDの原論文。EMDを類似画像検索に適用しています。</li>
<li><a href=\"http://vision.stanford.edu/~rubner/emd/default.htm\">Code for the Earth Movers Distance (EMD) </a>- Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</li>
<li><a href=\"http://www.cs.huji.ac.il/~ofirpele/FastEMD/code/\">Fast Earth Mover's Distance (EMD) Code</a> - EMDを高速計算する実装</li>
<li>柳本, 大松: <a href=\"http://www.ai-gakkai.or.jp/jsai/conf/2007/data/pdf/100206.pdf\">Earth Mover's Distance&#x3092;&#x7528;&#x3044;&#x305F;&#x30C6;&#x30AD;&#x30B9;&#x30C8;&#x5206;&#x985E;</a>、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BF%CD%B9%A9%C3%CE%C7%BD\">人工知能</a>学会全国大会, 2007. - EMDの説明がわかりやすい。画像や音声の手法がテキストにも使えるんですね。</li>
<li><a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>のlpSolveのマニュアル。lp.transform()の詳しい仕様はここで。</li>
</ul>
</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">実際はすべてではなくQに入る分だけでOK</span></p>
</div>" "http://aidiary.hatenablog.com/entry/20120804/1344058475" (20508 46187) old 6 nil nil ((title nil " Earth Mover's Distance (EMD)") (link ((href . "http://aidiary.hatenablog.com/entry/20120804/1344058475"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656812") (updated nil "2012-08-04T14:34:35+09:00") (summary nil "Earth Mover's Distance (EMD) について調べたことを整理しておきます。EMDは、ユークリッド距離のような距離尺度の一つで、二つの分布の間の距離を測ることができます。言語処理ではあまり聞いたことなかったのですが、画像処理や音声処理では比較的有名な距離尺度の") (content ((type . "html")) "<p><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth Mover&#39;s Distance (EMD) </a>について調べたことを整理しておきます。EMDは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離のような距離尺度の一つで、二つの分布の間の距離を測ることができます。言語処理ではあまり聞いたことなかったのですが、画像処理や音声処理では比較的有名な距離尺度のようです。</p><p>EMDが使える問題設定は下図のようになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804130722\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804130722.png\" alt=\"f:id:aidiary:20120804130722p:image\" title=\"f:id:aidiary:20120804130722p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは特徴量と重みの集合（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と呼ぶ）で与えられる分布Pと分布Qの間の距離</span>です。ここで、<span class=\"deco\" style=\"color:#FF0000;\">特徴量間では距離 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> が定義されている</span>のが前提です。特徴量がベクトルのときは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%AF%A5%EA%A5%C3%A5%C9\">ユークリッド</a>距離、特徴量が確率分布のときはカルバック・ライブラー距離（情報量）などです。EMDは、特徴量の集合が2つ与えられたときに、1個1個の特徴量間の距離をもとに、特徴量集合間の距離を求められるんですね。これはすごい。</p><p>重みは具体的な応用によって使い方が変わりますが、その特徴量の重要度を表しています。たとえば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>だったら各棒が特徴量にあたり、棒の高さが重みにあたります。前に<a href=\"http://d.hatena.ne.jp/aidiary/20091003/1254574041\">&#x985E;&#x4F3C;&#x753B;&#x50CF;&#x691C;&#x7D22;</a> (2009/10/3）で、画像の色の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>からHistogram Intersectionという距離を使いましたが、EMDを使って距離を求めることもできます。参考文献にあげたEMDの原論文は類似画像検索を対象にしています。</p><p>EMDなんて使わず、もっと単純に全特徴量のあらゆる組み合わせ間の距離の総和でもいいんじゃね？と思いましたけど、これだけだと重みを完全に無視していますね・・・重みが重要なんです！</p>

<div class=\"section\">
    <h4>考え方の基本は輸送問題</h4>
    <p>EMDの定義は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C7%C5%AC%B2%BD%CC%E4%C2%EA\">最適化問題</a>の1つの<span class=\"deco\" style=\"color:#FF0000;\">輸送問題（Transportation Problem）</span>の考え方に基づいています。なのでまずは輸送問題について簡単にまとめます。先の図において、Pの各場所P1, ... ,Pmには、重みの量だけ荷物が積まれているとします。そして、Qの各場所Q1, ... ,Qnには重みの量だけ格納できる倉庫があるとします。このとき、Pにある荷物をすべてQに運ぶ<a href=\"#f1\" name=\"fn1\" title=\"実際はすべてではなくQに入る分だけでOK\">*1</a>とき、どこからどこへどのくらい運ぶともっとも効率がよいかを求めるのが輸送問題です。</p><p>ここで、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送するコスト（距離）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> とし、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ輸送する荷物量（フロー）を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> と定義します。そして、Pi から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a> へ運ぶのに要する仕事量を <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D%20%2A%20f_%7Bij%7D\" alt=\"d_{ij} * f_{ij}\"/> と定義します。たとえば、距離が遠いところに大量の荷物を運ぶとそれだけ仕事量が増えるので直感とも一致します。このとき、総仕事量Wを下のように定義すると、W を最小化する <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> を求めればもっとも効率のよい運び方だとわかります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134057\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134057.png\" alt=\"f:id:aidiary:20120804134057p:image\" title=\"f:id:aidiary:20120804134057p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><img src=\"http://chart.apis.google.com/chart?cht=tx&chl=d_%7Bij%7D\" alt=\"d_{ij}\"/> は与えられるのが前提なので、<span class=\"deco\" style=\"color:#FF0000;\">最適化する変数は輸送量</span> <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> だけです。そして、輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D\" alt=\"f_{ij}\"/> には下の4つの制約が加えられます。</p><p>(1) かならずPからQへ輸送する。逆方向はない。</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134157\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134157.png\" alt=\"f:id:aidiary:20120804134157p:image\" title=\"f:id:aidiary:20120804134157p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center><br />
 <br />
(2) Piにある荷物以上は輸送できない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134355\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134355.png\" alt=\"f:id:aidiary:20120804134355p:image\" title=\"f:id:aidiary:20120804134355p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(3) <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Qj\">Qj</a>にある倉庫の容量以上は荷物を受け付けられない</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134420\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134420.png\" alt=\"f:id:aidiary:20120804134420p:image\" title=\"f:id:aidiary:20120804134420p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>(4) 輸送量の上限は、荷物の総量か倉庫の総容量の小さい方</p><p><center><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134434\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134434.png\" alt=\"f:id:aidiary:20120804134434p:image\" title=\"f:id:aidiary:20120804134434p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></center></p><p>最後の条件は荷物の総量と倉庫の容量が違うときに必要です。荷物総量より倉庫の総容量が大きかったら全部輸送できるので輸送量の上限は荷物の総量となりますが、荷物が倉庫の量より多かったら全部輸送できないので輸送量の上限は倉庫の総容量になります。今回、取り上げる例題は荷物の総量と倉庫の総容量は同じとしています。</p><p>輸送問題の解き方は省略しますが、解くと最適な <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> が求まります。EMDはこの <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> を用いて下のように定義されます。輸送量 <img src=\"http://chart.apis.google.com/chart?cht=tx&chl=f_%7Bij%7D%5E%2A\" alt=\"f_{ij}^*\"/> の合計で割っているのは、輸送量によってEMDのスケールが変わらないように正規化しているためですね。これはあとで具体例で確認してみます。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804134804\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804134804.png\" alt=\"f:id:aidiary:20120804134804p:image\" title=\"f:id:aidiary:20120804134804p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p><span class=\"deco\" style=\"color:#FF0000;\">EMDは輸送に必要な最適な仕事量が小さいほど二つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>の距離は近い</span>という考え方なのでわりと自然な考え方だと思います。ただし、あらゆる特徴量間の組み合わせについて足し合わせが必要なので特徴量の数が多くなると計算量は非常に大きくなりそうです。そのため、特徴量の数が爆発しないようにベクトル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CE%CC%BB%D2%B2%BD\">量子化</a>と組み合わせて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を作る手法が提案されています。これは、後に紹介予定です。</p>

</div>
<div class=\"section\">
    <h4>EMDの定義がわかったところで具体例を解いてみます</h4>
    <p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120804135712\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120804/20120804135712.png\" alt=\"f:id:aidiary:20120804135712p:image\" title=\"f:id:aidiary:20120804135712p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>この例は、EMDの提案者の<a href=\"http://ai.stanford.edu/~rubner/emd/default.htm\">Rubner&#x3055;&#x3093;&#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;</a>に出てくる例題です。特徴量は3次元ベクトルで重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4%C5%C0%BF%F4\">浮動小数点数</a>で与えられています。特徴量の値が0から255の3次元ベクトルなので、分布Pが画像1のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>、分布Qが画像2のカラー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D2%A5%B9%A5%C8%A5%B0%A5%E9%A5%E0\">ヒストグラム</a>を表しているようです。この分布Pと分布QのEMDを計算してみます！</p>

</div>
<div class=\"section\">
    <h4>Rubnerの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</h4>
    <p>まずは、Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>のコードを使ってみます（<a href=\"http://ai.stanford.edu/~rubner/emd/example1.c\">example1.c</a>）。実行には、<a href=\"http://ai.stanford.edu/~rubner/emd/emd.c\">emd.c</a>と<a href=\"http://ai.stanford.edu/~rubner/emd/emd.h\">emd.h</a>が必要です。また、emd.hのfeature_tの定義を問題に合わせて書き換える必要があります。今回は、特徴量が3次元ベクトルなので</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synType\">typedef</span> <span class=\"synType\">struct</span> { <span class=\"synType\">int</span> X,Y,Z; } feature_t;
</pre><p>と定義しています。emd.cのライブラリを使って上の例題を解くコードです。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink><span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;stdio.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&lt;math.h&gt;</span>
<span class=\"synPreProc\">#include </span><span class=\"synConstant\">&quot;emd.h&quot;</span>

<span class=\"synComment\">/* ユークリッド距離 */</span>
<span class=\"synType\">float</span> dist(feature_t *F1, feature_t *F2) {
    <span class=\"synType\">int</span> dX = F1-&gt;X - F2-&gt;X;
    <span class=\"synType\">int</span> dY = F1-&gt;Y - F2-&gt;Y;
    <span class=\"synType\">int</span> dZ = F1-&gt;Z - F2-&gt;Z;
    <span class=\"synStatement\">return</span> sqrt(dX*dX + dY*dY + dZ*dZ);
}

<span class=\"synType\">int</span> main() {
    <span class=\"synComment\">/* 分布Pの特徴ベクトル */</span>
    feature_t f1[<span class=\"synConstant\">4</span>] = { {<span class=\"synConstant\">100</span>,<span class=\"synConstant\">40</span>,<span class=\"synConstant\">22</span>}, {<span class=\"synConstant\">211</span>,<span class=\"synConstant\">20</span>,<span class=\"synConstant\">2</span>}, {<span class=\"synConstant\">32</span>,<span class=\"synConstant\">190</span>,<span class=\"synConstant\">150</span>}, {<span class=\"synConstant\">2</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">100</span>} };
    <span class=\"synComment\">/* 分布Qの特徴ベクトル */</span>
     feature_t f2[<span class=\"synConstant\">3</span>] = { {<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>,<span class=\"synConstant\">0</span>}, {<span class=\"synConstant\">50</span>,<span class=\"synConstant\">100</span>,<span class=\"synConstant\">80</span>}, {<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>,<span class=\"synConstant\">255</span>} };
    <span class=\"synComment\">/* 分布Pの重み */</span>
    <span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">0.4</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span>, <span class=\"synConstant\">0.1</span> };
    <span class=\"synComment\">/* 分布Qの重み */</span>
    <span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">0.5</span>, <span class=\"synConstant\">0.3</span>, <span class=\"synConstant\">0.2</span> };
    <span class=\"synComment\">/* 分布Pのシグネチャ */</span>
    signature_t s1 = { <span class=\"synConstant\">4</span>, f1, w1 };
    <span class=\"synComment\">/* 分布Qのシグネチャ */</span>
     signature_t s2 = { <span class=\"synConstant\">3</span>, f2, w2};

    <span class=\"synComment\">/* EMDを計算 */</span>
    <span class=\"synType\">float</span> e;
    e = emd(&amp;s1, &amp;s2, dist, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>);
    printf(<span class=\"synConstant\">&quot;emd = </span><span class=\"synSpecial\">%f\\n</span><span class=\"synConstant\">&quot;</span>, e);
    <span class=\"synStatement\">return</span> <span class=\"synConstant\">0</span>;
}
</pre><p>emd()関数に2つの分布の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>と特徴量間の距離を計算する関数を指定しています。この実装では、重みは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C9%E2%C6%B0%BE%AE%BF%F4\">浮動小数</a>点になっています。合計するとどちらも1.0になるので荷物総量と倉庫の総容量は等しくなっています。実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>emd = 160.542770</pre><p>よって、分布Pと分布Qの距離は、160.54とわかります。先に書いたようにEMDは、輸送量で正規化しているため下のように比率を保ったまま重みを変えても結果は同じになります。</p>
<pre class=\"code lang-c\" data-lang=\"c\" data-unlink>    <span class=\"synComment\">/* 分布Pの重み */</span>
    <span class=\"synType\">float</span> w1[<span class=\"synConstant\">5</span>] = { <span class=\"synConstant\">4.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span>, <span class=\"synConstant\">1.0</span> };
    <span class=\"synComment\">/* 分布Qの重み */</span>
    <span class=\"synType\">float</span> w2[<span class=\"synConstant\">3</span>] = { <span class=\"synConstant\">5.0</span>, <span class=\"synConstant\">3.0</span>, <span class=\"synConstant\">2.0</span> };
</pre>
</div>
<div class=\"section\">
    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>による実装</h4>
    <p>次は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で同じ例題を解いてみます。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>で輸送問題を解く関数は、<a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a>というライブラリに含まれていますが、標準では入っていないのでインストールします。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>install.packages<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;lpSolve&quot;</span><span class=\"synSpecial\">)</span>
</pre><p>以下のemd_sample.Rファイルを作成します。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>library<span class=\"synSpecial\">(</span>lpSolve<span class=\"synSpecial\">)</span>

<span class=\"synComment\"># ユークリッド距離</span>
euclid_dist <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">,</span> f2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>sqrt<span class=\"synSpecial\">(</span>sum<span class=\"synSpecial\">((</span>f1 - f2<span class=\"synSpecial\">)</span>^<span class=\"synConstant\">2</span><span class=\"synSpecial\">)))</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># EMDを計算</span>
emd <span class=\"synStatement\">&lt;-</span> <span class=\"synType\">function</span><span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synComment\"># lp.transport()を使うための準備</span>
    costs <span class=\"synStatement\">&lt;-</span> dist
    row.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&lt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w1<span class=\"synSpecial\">))</span>
    row.rhs <span class=\"synStatement\">&lt;-</span> w1
    col.signs <span class=\"synStatement\">&lt;-</span> rep<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;&gt;&quot;</span><span class=\"synSpecial\">,</span> length<span class=\"synSpecial\">(</span>w2<span class=\"synSpecial\">))</span>
    col.rhs <span class=\"synStatement\">&lt;-</span> w2
    <span class=\"synComment\"># 輸送問題を解く</span>
    t <span class=\"synStatement\">&lt;-</span> lp.transport<span class=\"synSpecial\">(</span>costs<span class=\"synSpecial\">,</span> <span class=\"synConstant\">&quot;min&quot;</span><span class=\"synSpecial\">,</span> row.signs<span class=\"synSpecial\">,</span> row.rhs<span class=\"synSpecial\">,</span> col.signs<span class=\"synSpecial\">,</span> col.rhs<span class=\"synSpecial\">)</span>
    <span class=\"synComment\"># 最適な輸送量を取得</span>
    flow <span class=\"synStatement\">&lt;-</span> t$solution
    <span class=\"synComment\"># 仕事量を計算</span>
    work <span class=\"synStatement\">&lt;-</span> sum<span class=\"synSpecial\">(</span>flow * dist<span class=\"synSpecial\">)</span>
    <span class=\"synComment\"># 正規化してEMDを計算</span>
    e <span class=\"synStatement\">&lt;-</span> work / sum<span class=\"synSpecial\">(</span>flow<span class=\"synSpecial\">)</span>
    <span class=\"synStatement\">return</span><span class=\"synSpecial\">(</span>e<span class=\"synSpecial\">)</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># 特徴量</span>
f1 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">40</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">22</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">211</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">20</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">32</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">190</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">150</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>
f2 = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span>c<span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">50</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">100</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">80</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">255</span><span class=\"synSpecial\">),</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> byrow=T<span class=\"synSpecial\">)</span>

<span class=\"synComment\"># 重み（要整数！）</span>
w1 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">4</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">)</span>
w2 = c<span class=\"synSpecial\">(</span><span class=\"synConstant\">5</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">3</span><span class=\"synSpecial\">,</span> <span class=\"synConstant\">2</span><span class=\"synSpecial\">)</span>

n1 = length<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>
n2 = length<span class=\"synSpecial\">(</span>f2<span class=\"synSpecial\">[,</span><span class=\"synConstant\">1</span><span class=\"synSpecial\">])</span>

<span class=\"synComment\"># 距離行列を作成</span>
dist = <span class=\"synType\">matrix</span><span class=\"synSpecial\">(</span><span class=\"synConstant\">0</span><span class=\"synSpecial\">,</span> n1<span class=\"synSpecial\">,</span> n2<span class=\"synSpecial\">)</span>
<span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>i <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n1<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
    <span class=\"synStatement\">for</span> <span class=\"synSpecial\">(</span>j <span class=\"synStatement\">in</span> <span class=\"synConstant\">1</span><span class=\"synSpecial\">:</span>n2<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">{</span>
        dist<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,</span> j<span class=\"synSpecial\">]</span> = euclid_dist<span class=\"synSpecial\">(</span>f1<span class=\"synSpecial\">[</span>i<span class=\"synSpecial\">,],</span> f2<span class=\"synSpecial\">[</span>j<span class=\"synSpecial\">,])</span>
    <span class=\"synSpecial\">}</span>
<span class=\"synSpecial\">}</span>

<span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
e = emd<span class=\"synSpecial\">(</span>dist<span class=\"synSpecial\">,</span> w1<span class=\"synSpecial\">,</span> w2<span class=\"synSpecial\">)</span>
cat<span class=\"synSpecial\">(</span>sprintf<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd = %f\\n&quot;</span><span class=\"synSpecial\">,</span> e<span class=\"synSpecial\">))</span>
</pre><p>この実装では、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>を渡さずに、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>から計算した距離行列と重みを渡しています。lp.transport()が距離行列を受け付けるのでそれに合わせましたが、まあ、どっちでもよいと思います。Rを起動して以下のように打つと実行できます。</p>
<pre class=\"code lang-r\" data-lang=\"r\" data-unlink>&gt; source<span class=\"synSpecial\">(</span><span class=\"synConstant\">&quot;emd_sample.R&quot;</span><span class=\"synSpecial\">)</span>
emd = <span class=\"synConstant\">160.542763</span>
</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>版と同じ結果になりました！ただ、距離行列の計算がRっぽい書き方でないので効率悪いかも。もっといい書き方があったら教えてください。</p>

</div>
<div class=\"section\">
    <h4>それでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>で書きたいんだよ！</h4>
    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>の<a href=\"http://www.scipy.org/\">SciPy</a>にはlp.transport()に対応する関数はないようです。他の最適化ライブラリ（<a href=\"http://openopt.org/Welcome\">openopt</a>や<a href=\"http://abel.ee.ucla.edu/cvxopt/\">cvxopt</a>）もざっと探しましたが見つけられませんでした。自分で書いてもよかったのですが、せっかくRの関数があるので<a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>を使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>からRのlp.transport()を呼び出してみます。</p><p><a href=\"http://rpy.sourceforge.net/rpy2.html\">rpy2</a>は、Rの機能を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>から呼び出せるようにする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>ライブラリです。使い方はやや複雑ですが、今回のように<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>になくてRにあるアルゴリズムもたくさんあるので使えるとはかどります。まあ、Rをラッパーしているのでちょっと複雑になっちゃうけどね。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synPreProc\">import</span> numpy <span class=\"synPreProc\">as</span> np
<span class=\"synPreProc\">import</span> rpy2.robjects <span class=\"synPreProc\">as</span> robjects

<span class=\"synComment\"># Rのlp.transport()をインポート</span>
robjects.r['<span class=\"synConstant\">library</span>']('<span class=\"synConstant\">lpSolve</span>')
transport = robjects.r['<span class=\"synConstant\">lp.transport</span>']

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">euclid_dist</span>(feature1, feature2):
    &quot;&quot;&quot;<span class=\"synConstant\">ユークリッド距離を計算</span>&quot;&quot;&quot;
    <span class=\"synStatement\">if</span> len(feature1) != len(feature2):
        <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">ERROR: calc euclid_dist: %d &lt;=&gt; %d</span>&quot; % (len(feature1), len(feature2))
        <span class=\"synStatement\">return</span> -1
    <span class=\"synStatement\">return</span> np.sqrt(np.sum((feature1 - feature2) ** 2))

<span class=\"synStatement\">def</span> <span class=\"synIdentifier\">emd</span>(dist, w1, w2):
    &quot;&quot;&quot;<span class=\"synConstant\">Rのtransport()関数を使ってEMDを計算</span>&quot;&quot;&quot;
    <span class=\"synComment\"># transport()の引数を用意</span>
    costs = robjects.r['<span class=\"synConstant\">matrix</span>'](robjects.FloatVector(dist),
                                 nrow=len(w1), ncol=len(w2),
                                 byrow=True)
    row_signs = [&quot;<span class=\"synConstant\">&lt;</span>&quot;] * len(w1)
    row_rhs = robjects.FloatVector(w1)
    col_signs = [&quot;<span class=\"synConstant\">&gt;</span>&quot;] * len(w2)
    col_rhs = robjects.FloatVector(w2)

    t = transport(costs, &quot;<span class=\"synConstant\">min</span>&quot;, row_signs, row_rhs, col_signs, col_rhs)
    flow = t.rx2('<span class=\"synConstant\">solution</span>')

    dist = dist.reshape(len(w1), len(w2))
    flow = np.array(flow)
    work = np.sum(flow * dist)
    emd = work / np.sum(flow)
    <span class=\"synStatement\">return</span> emd

<span class=\"synStatement\">if</span> __name__ == &quot;<span class=\"synConstant\">__main__</span>&quot;:
    f1 = np.array([ [100, 40, 22], [211, 20, 2], [32, 190, 150], [2, 100, 100] ])
    f2 = np.array([ [0, 0, 0], [50, 100, 80], [255, 255, 255] ])

    <span class=\"synComment\"># 重みは自然数のみ</span>
    w1 = np.array([4, 3, 2, 1])
    w2 = np.array([5, 3, 2])

    n1 = len(f1)
    n2 = len(f2)

    <span class=\"synComment\"># 距離行列を作成</span>
    dist = np.zeros(n1 * n2)
    <span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(n1):
        <span class=\"synStatement\">for</span> j <span class=\"synStatement\">in</span> range(n2):
            dist[i * n2 + j] = euclid_dist(f1[i], f2[j])

    <span class=\"synComment\"># 距離行列と重みからEMDを計算</span>
    <span class=\"synStatement\">print</span> &quot;<span class=\"synConstant\">emd =</span>&quot;, emd(dist, w1, w2)
</pre><p>実行すると、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; python emd_sample.py
emd = 160.542762808</pre><p>となり、CやRと同じ結果が得られました。</p>

</div>
<div class=\"section\">
    <h4>おわりに</h4>
    <p>今回は、EMDについて調べたことをまとめてみました。できるだけ正確に書くようにしましたが、誤りもあるかもしれません。鵜呑みにしないで他の資料も当たってみてください。</p><p>あとで、EMDを類似楽曲検索という具体的な問題に応用してみる予定です。乞うご期待。</p>

</div>
<div class=\"section\">
    <h4>参考文献</h4>
    
<ul>
<li><a href=\"http://en.wikipedia.org/wiki/Earth_Mover%27s_Distance\">Earth mover&#39;s distance</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Wikipedia\">Wikipedia</a></li>
<li>Y. Rubner, C. Tomasi and L. J. Guibas: <a href=\"http://vision.stanford.edu/~rubner/papers/rubnerIjcv00.pdf\">The earth mover&#39;s distance as a metric for image retrieval</a> (PDF), International Journal of Computer Vision, 40(2), pp.99-121, 2000 - EMDの原論文。EMDを類似画像検索に適用しています。</li>
<li><a href=\"http://vision.stanford.edu/~rubner/emd/default.htm\">Code for the Earth Movers Distance (EMD) </a>- Rubnerさんが公開されている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC\">C言語</a>実装</li>
<li><a href=\"http://www.cs.huji.ac.il/~ofirpele/FastEMD/code/\">Fast Earth Mover&#39;s Distance (EMD) Code</a> - EMDを高速計算する実装</li>
<li>柳本, 大松: <a href=\"http://www.ai-gakkai.or.jp/jsai/conf/2007/data/pdf/100206.pdf\">Earth Mover&#39;s Distance&#x3092;&#x7528;&#x3044;&#x305F;&#x30C6;&#x30AD;&#x30B9;&#x30C8;&#x5206;&#x985E;</a>、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BF%CD%B9%A9%C3%CE%C7%BD\">人工知能</a>学会全国大会, 2007. - EMDの説明がわかりやすい。画像や音声の手法がテキストにも使えるんですね。</li>
<li><a href=\"http://cran.r-project.org/web/packages/lpSolve/index.html\">lpSolve</a> - <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/R%B8%C0%B8%EC\">R言語</a>のlpSolveのマニュアル。lp.transform()の詳しい仕様はここで。</li>
</ul>
</div><div class=\"footnote\">
<p class=\"footnote\"><a href=\"#fn1\" name=\"f1\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\">実際はすべてではなくQに入る分だけでOK</span></p>
</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary")))) ("SPTKの使い方 (5) フレーム分割" "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120716/1342414058\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (4)</a>（2012/7/16）の続き。</p><p>今回は、音声波形をフレーム単位に分割するSPTKの<span class=\"deco\" style=\"color:#FF0000;\">frame</span>コマンドを使ってみます。音声でフレームというと、信号の複数のサンプルを一定幅でまとめたものを指すことが多いと思います。前に実装した<a href=\"http://d.hatena.ne.jp/aidiary/20110716#1310824587\">&#x77ED;&#x6642;&#x9593;&#x30D5;&#x30FC;&#x30EA;&#x30A8;&#x5909;&#x63DB;</a>（2011/7/16）では、連続する波形からフレームを切り出し、窓関数をかけて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>というのをフレームを少しずつずらしながら繰り返し行うことでスペクトルの時間変化を求めました。</p><p>ここで、フレームを少しずつずらしながら音声を切り出すのがframeコマンドです。SPTKのマニュアルを見ると、引数で指定するのはフレームの長さLと周期Pになります。周期はフレームの中心をどれくらいずらしていくかを表すパラメータです。LよりPが小さいとオーバーラップしながらずらしていくことになります。</p><p>というわけで簡単なデータを作ってさっそく試してみます。結果がわかりやすいように0, 1, 2, 3, 4, 5, ...という連続した数値が入ったデータを作ります。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synComment\"># make_simple_data.py</span>
<span class=\"synPreProc\">import</span> struct
fp = open(&quot;<span class=\"synConstant\">simple.short</span>&quot;, &quot;<span class=\"synConstant\">wb</span>&quot;)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(100):
fp.write(struct.pack(&quot;<span class=\"synConstant\">h</span>&quot;, i))
fp.close()
</pre><p>実行するとsimple.shortという0から99までのSHORT型データを書き込んだバイナリファイルができます。SPTKのdmpコマンドで見てみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; dmp +s simple.short
0       0
1       1
2       2
...
97      97
98      98
99      99</pre><p>OK。さっそくこのデータからフレーム長L=10、フレーム周期P=5でフレームを抽出してみます。frameの入力はfloat型しかダメなのでx2xでSHORT型からFLOAT型に変換してます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; simple.short | frame -l 10 -p 5  &gt; simple.frame
dmp -l 10 +f simple.frame</pre><p>dmpコマンドの-lオプションでフレーム長を渡すとフレーム単位でインデックスを割り振ってくれるため少し見やすくなります。もう少し整形すると</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink> 0 frame:  0  0  0  0  0  0  1  2  3  4
1 frame:  0  1  2  3  4  5  6  7  8  9
2 frame:  5  6  7  8  9 10 11 12 13 14
3 frame: 10 11 12 13 14 15 16 17 18 19
4 frame: 15 16 17 18 19 20 21 22 23 24
...
18 frame: 85 86 87 88 89 90 91 92 93 94
19 frame: 90 91 92 93 94 95 96 97 98 99</pre><p>このようにフレームが並んでいることがわかります。たしかにフレーム長は10でフレーム周期の5ずつずらしながらフレームを抽出していることがわかります。また、元のサンプル数が100で5ずつずらしながらフレームを抽出しているので全部で100/5=20フレームあることもわかります。</p>
<div class=\"section\">
<h4>フレームを切り出す</h4>
<p>次に、波形から任意の位置のフレームを切り出してみます。波形から任意のサンプルを切り出すコマンドは<a href=\"http://d.hatena.ne.jp/aidiary/20120704#1341409042\">bcut&#x3067;&#x3057;&#x305F;</a>（2012/7/4）が、<span class=\"deco\" style=\"color:#FF0000;\">bcutに-lオプションを与えると単位がフレームになります</span>。たとえば、18フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 18 -e 18 &lt; data.frame | dmp +f
0       85
1       86
2       87
3       88
4       89
5       90
6       91
7       92
8       93
9       94</pre><p>2から4フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 2 -e 4 &lt; data.frame | dmp +f
0       5
1       6
2       7
3       8
...
27      22
28      23
29      24</pre><p>となります。</p>
</div>
<div class=\"section\">
<h4>指定したフレームのスペクトルを求める</h4>
<p>では、frame、bcutを使って音声の任意のフレームのスペクトルを求めてみます。音声はSPTKに付属のサンプル音声data.short（青い植木鉢）で試します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | fftr -l 512 -A &gt; data.fft</pre><p>このようにコマンドをパイプでつなげるだけなのでマジ簡単です。前から順に</p>
<ol>
<li>data.shortをSHORT型からFLOAT型に変換</li>
<li>フレーム長400サンプル、フレーム周期80サンプルでフレームを抽出</li>
<li>フレーム長を400サンプルとし、65フレーム目を切り出す</li>
<li>入力のフレーム長を400サンプル、出力のフレーム長を512サンプルとする窓関数をかける</li>
<li>フレーム長512サンプルで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを出力</li>
</ol><p>となります。さっそく、data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>を<a href=\"http://d.hatena.ne.jp/aidiary/20120716#1342414058\">&#x524D;&#x56DE;</a>（2012/7/16）作ったplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyで表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python plot_fft.py data.fft 512 16000</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212608\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212608.png\" alt=\"f:id:aidiary:20120801212608p:image\" title=\"f:id:aidiary:20120801212608p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>縦軸は対数にすることが多いのでplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyの下の部分を書き換えてみます。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink>plot(freqList[:N/2], fft[:N/2])
↓
plot(freqList[:N/2], np.log2(fft[:N/2]))
</pre><p>実行すると対数スペクトルになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212614\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212614.png\" alt=\"f:id:aidiary:20120801212614p:image\" title=\"f:id:aidiary:20120801212614p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>
</div>
<div class=\"section\">
<h4>SPTKで対数スペクトルを求める</h4>
<p>SPTKにも対数スペクトルを求める<span class=\"deco\" style=\"color:#FF0000;\">spec</span>コマンドとそれを表示する<span class=\"deco\" style=\"color:#FF0000;\">glogsp</span>コマンドがあるので試してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | \\
spec -l 512 | glogsp -l 512 -x 8 -p 2 | xgr</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801214054\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801214054.png\" alt=\"f:id:aidiary:20120801214054p:image\" title=\"f:id:aidiary:20120801214054p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>先の結果と同じです。縦軸のスケールが違うけどこれは特に問題ないのかな？frameコマンドは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>以外にもMFCCやLPCの抽出でも頻繁に使うのでここで慣れておきたいな。</p>
</div>" "http://aidiary.hatenablog.com/entry/20120801/1343825329" (20505 9649) old 7 nil nil ((title nil " SPTKの使い方 (5) フレーム分割") (link ((href . "http://aidiary.hatenablog.com/entry/20120801/1343825329"))) (id nil "http://aidiary.hatenablog.com/id/12704830469096656814") (updated nil "2012-08-01T21:48:49+09:00") (summary nil "SPTKの使い方 (4)（2012/7/16）の続き。今回は、音声波形をフレーム単位に分割するSPTKのframeコマンドを使ってみます。音声でフレームというと、信号の複数のサンプルを一定幅でまとめたものを指すことが多いと思います。前に実装した短時間フーリエ変換（2011/7/1") (content ((type . "html")) "<p><a href=\"http://d.hatena.ne.jp/aidiary/20120716/1342414058\">SPTK&#x306E;&#x4F7F;&#x3044;&#x65B9; (4)</a>（2012/7/16）の続き。</p><p>今回は、音声波形をフレーム単位に分割するSPTKの<span class=\"deco\" style=\"color:#FF0000;\">frame</span>コマンドを使ってみます。音声でフレームというと、信号の複数のサンプルを一定幅でまとめたものを指すことが多いと思います。前に実装した<a href=\"http://d.hatena.ne.jp/aidiary/20110716#1310824587\">&#x77ED;&#x6642;&#x9593;&#x30D5;&#x30FC;&#x30EA;&#x30A8;&#x5909;&#x63DB;</a>（2011/7/16）では、連続する波形からフレームを切り出し、窓関数をかけて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>というのをフレームを少しずつずらしながら繰り返し行うことでスペクトルの時間変化を求めました。</p><p>ここで、フレームを少しずつずらしながら音声を切り出すのがframeコマンドです。SPTKのマニュアルを見ると、引数で指定するのはフレームの長さLと周期Pになります。周期はフレームの中心をどれくらいずらしていくかを表すパラメータです。LよりPが小さいとオーバーラップしながらずらしていくことになります。</p><p>というわけで簡単なデータを作ってさっそく試してみます。結果がわかりやすいように0, 1, 2, 3, 4, 5, ...という連続した数値が入ったデータを作ります。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synComment\">#coding:utf-8</span>
<span class=\"synComment\"># make_simple_data.py</span>
<span class=\"synPreProc\">import</span> struct
fp = open(&quot;<span class=\"synConstant\">simple.short</span>&quot;, &quot;<span class=\"synConstant\">wb</span>&quot;)
<span class=\"synStatement\">for</span> i <span class=\"synStatement\">in</span> range(100):
    fp.write(struct.pack(&quot;<span class=\"synConstant\">h</span>&quot;, i))
fp.close()
</pre><p>実行するとsimple.shortという0から99までのSHORT型データを書き込んだバイナリファイルができます。SPTKのdmpコマンドで見てみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; dmp +s simple.short
0       0
1       1
2       2
...
97      97
98      98
99      99</pre><p>OK。さっそくこのデータからフレーム長L=10、フレーム周期P=5でフレームを抽出してみます。frameの入力はfloat型しかダメなのでx2xでSHORT型からFLOAT型に変換してます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; simple.short | frame -l 10 -p 5  &gt; simple.frame
dmp -l 10 +f simple.frame</pre><p>dmpコマンドの-lオプションでフレーム長を渡すとフレーム単位でインデックスを割り振ってくれるため少し見やすくなります。もう少し整形すると</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink> 0 frame:  0  0  0  0  0  0  1  2  3  4
 1 frame:  0  1  2  3  4  5  6  7  8  9
 2 frame:  5  6  7  8  9 10 11 12 13 14
 3 frame: 10 11 12 13 14 15 16 17 18 19
 4 frame: 15 16 17 18 19 20 21 22 23 24
                    ...
18 frame: 85 86 87 88 89 90 91 92 93 94
19 frame: 90 91 92 93 94 95 96 97 98 99</pre><p>このようにフレームが並んでいることがわかります。たしかにフレーム長は10でフレーム周期の5ずつずらしながらフレームを抽出していることがわかります。また、元のサンプル数が100で5ずつずらしながらフレームを抽出しているので全部で100/5=20フレームあることもわかります。</p>

<div class=\"section\">
    <h4>フレームを切り出す</h4>
    <p>次に、波形から任意の位置のフレームを切り出してみます。波形から任意のサンプルを切り出すコマンドは<a href=\"http://d.hatena.ne.jp/aidiary/20120704#1341409042\">bcut&#x3067;&#x3057;&#x305F;</a>（2012/7/4）が、<span class=\"deco\" style=\"color:#FF0000;\">bcutに-lオプションを与えると単位がフレームになります</span>。たとえば、18フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 18 -e 18 &lt; data.frame | dmp +f
0       85
1       86
2       87
3       88
4       89
5       90
6       91
7       92
8       93
9       94</pre><p>2から4フレーム目を切り出したい時は、</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>&gt; bcut +f -l 10 -s 2 -e 4 &lt; data.frame | dmp +f
0       5
1       6
2       7
3       8
...
27      22
28      23
29      24</pre><p>となります。</p>

</div>
<div class=\"section\">
    <h4>指定したフレームのスペクトルを求める</h4>
    <p>では、frame、bcutを使って音声の任意のフレームのスペクトルを求めてみます。音声はSPTKに付属のサンプル音声data.short（青い植木鉢）で試します。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | fftr -l 512 -A &gt; data.fft</pre><p>このようにコマンドをパイプでつなげるだけなのでマジ簡単です。前から順に</p>

<ol>
<li>data.shortをSHORT型からFLOAT型に変換</li>
<li>フレーム長400サンプル、フレーム周期80サンプルでフレームを抽出</li>
<li>フレーム長を400サンプルとし、65フレーム目を切り出す</li>
<li>入力のフレーム長を400サンプル、出力のフレーム長を512サンプルとする窓関数をかける</li>
<li>フレーム長512サンプルで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FFT\">FFT</a>して振幅スペクトルを出力</li>
</ol><p>となります。さっそく、data.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>を<a href=\"http://d.hatena.ne.jp/aidiary/20120716#1342414058\">&#x524D;&#x56DE;</a>（2012/7/16）作ったplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyで表示してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>python plot_fft.py data.fft 512 16000</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212608\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212608.png\" alt=\"f:id:aidiary:20120801212608p:image\" title=\"f:id:aidiary:20120801212608p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>縦軸は対数にすることが多いのでplot_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/fft\">fft</a>.pyの下の部分を書き換えてみます。</p>
<pre class=\"code lang-python\" data-lang=\"python\" data-unlink>plot(freqList[:N/2], fft[:N/2])
            ↓
plot(freqList[:N/2], np.log2(fft[:N/2]))
</pre><p>実行すると対数スペクトルになります。</p><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801212614\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801212614.png\" alt=\"f:id:aidiary:20120801212614p:image\" title=\"f:id:aidiary:20120801212614p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p>

</div>
<div class=\"section\">
    <h4>SPTKで対数スペクトルを求める</h4>
    <p>SPTKにも対数スペクトルを求める<span class=\"deco\" style=\"color:#FF0000;\">spec</span>コマンドとそれを表示する<span class=\"deco\" style=\"color:#FF0000;\">glogsp</span>コマンドがあるので試してみます。</p>
<pre class=\"code lang-\" data-lang=\"\" data-unlink>x2x +sf &lt; data.short | frame -l 400 -p 80 | \\
bcut +f -l 400 -s 65 -e 65 | window -l 400 -L 512 | \\
spec -l 512 | glogsp -l 512 -x 8 -p 2 | xgr</pre><p><span itemscope itemtype=\"http://schema.org/Photograph\"><a href=\"http://f.hatena.ne.jp/aidiary/20120801214054\" class=\"hatena-fotolife\" itemprop=\"url\"><img src=\"http://cdn-ak.f.st-hatena.com/images/fotolife/a/aidiary/20120801/20120801214054.png\" alt=\"f:id:aidiary:20120801214054p:image\" title=\"f:id:aidiary:20120801214054p:image\" class=\"hatena-fotolife\" itemprop=\"image\"></a></span></p><p>先の結果と同じです。縦軸のスケールが違うけどこれは特に問題ないのかな？frameコマンドは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A1%BC%A5%EA%A5%A8%CA%D1%B4%B9\">フーリエ変換</a>以外にもMFCCやLPCの抽出でも頻繁に使うのでここで慣れておきたいな。</p>

</div>") (category ((term . "音声信号処理") (label . "音声信号処理"))) (author nil (name nil "aidiary")))))